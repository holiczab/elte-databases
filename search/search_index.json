{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"ELTE DATABASES I. AND II. CLASSES PRACTICE NOTES","text":""},{"location":"none/","title":"No contents","text":""},{"location":"topics/","title":"DB1 Practice Guide","text":""},{"location":"topics/#part-1-foundational-topics-sql","title":"Part 1: Foundational Topics (SQL)","text":""},{"location":"topics/#practice-1-introduction-basics-and-set-operators","title":"Practice 1: Introduction, Basics, and Set Operators","text":"<p>Objective: Gain an understanding of the relational model, fundamental data retrieval techniques for datasets.</p> <p>Topics Covered: - Relational Model - Basic <code>SELECT</code> Statement - Set Operators</p> <p>Resources: - Introduction - Basic SQL Statements - Set Operators</p>"},{"location":"topics/#practice-2-data-types-and-single-row-functions","title":"Practice 2: Data Types and Single-Row Functions","text":"<p>Objective: Develop proficiency in working with data types and manipulating individual rows of data.</p> <p>Topics Covered: - Data Types - Character Functions - Number Functions - Date Functions</p> <p>Resources: - Data Types - SQL Functions - Character Functions - Number Functions - Date Functions</p>"},{"location":"topics/#practice-3-advanced-functions-and-data-grouping","title":"Practice 3: Advanced Functions and Data Grouping","text":"<p>Objective: Master advanced SQL functions and techniques for summarizing and analyzing grouped data.</p> <p>Topics Covered: - Conversion Functions - Other Functions - Conditional Expressions - Group Functions - <code>GROUP BY</code></p> <p>Resources: - Conversion Functions - Other Functions - Conditional Expressions - Group Functions - Group By</p>"},{"location":"topics/#practice-4-joins-subqueries-and-common-table-expressions","title":"Practice 4: Joins, Subqueries, and Common Table Expressions","text":"<p>Objective: Learn to combine data from multiple sources, construct complex queries, and utilize Common Table Expressions (CTEs).</p> <p>Topics Covered: - Joins - Subqueries - Common Table Expressions (<code>WITH</code>)</p> <p>Resources: - Joins - Subqueries - With</p>"},{"location":"topics/#practice-5-data-manipulation-definition-and-views","title":"Practice 5: Data Manipulation, Definition, and Views","text":"<p>Objective: Acquire skills to modify data, define database structures, and create reusable virtual tables.</p> <p>Topics Covered: - DML (Data Manipulation Language) - DDL (Data Definition Language) - Views - Basics of Relax</p> <p>Resources: - DML and DDL - Views - Relational Algebra</p>"},{"location":"topics/#practice-6-relational-algebra","title":"Practice 6: Relational Algebra","text":"<p>Objective: Explore the theoretical foundations of relational databases and their operations.</p> <p>Topics Covered: - Relational Algebra</p> <p>Resources: - Relational Algebra</p>"},{"location":"topics/#practice-7-midterm-assessment","title":"Practice 7: Midterm Assessment","text":"<p>Objective: Evaluate understanding and application of foundational SQL concepts.</p>"},{"location":"topics/#part-2-advanced-topics-plsql","title":"Part 2: Advanced Topics (PL/SQL)","text":""},{"location":"topics/#practice-8-plsql-fundamentals","title":"Practice 8: PL/SQL Fundamentals","text":"<p>Objective: Gain an introduction to procedural programming within the database environment.</p> <p>Topics Covered: - PL/SQL Basics</p> <p>Resources: - PL/SQL Basics</p>"},{"location":"topics/#practice-9-cursors-and-collections","title":"Practice 9: Cursors and Collections","text":"<p>Objective: Learn to process multi-row result sets and utilize in-memory data structures effectively.</p> <p>Topics Covered: - Cursors - Collections</p> <p>Resources: - Cursors and Collections</p>"},{"location":"topics/#practice-10-exception-handling","title":"Practice 10: Exception Handling","text":"<p>Objective: Develop techniques to handle runtime errors gracefully and ensure robust code execution.</p> <p>Topics Covered: - Exception Handling</p> <p>Resources: - Exceptions</p>"},{"location":"topics/#practice-11-recursion","title":"Practice 11: Recursion","text":"<p>Objective: Explore advanced querying techniques for hierarchical data structures.</p> <p>Topics Covered: - Recursion</p> <p>Resources: - Recursion</p>"},{"location":"topics/#practice-12-endterm-assessment","title":"Practice 12: Endterm Assessment","text":"<p>Objective: Assess comprehension and application of advanced SQL and PL/SQL concepts.</p>"},{"location":"topics/#practice-13-retake-assessment","title":"Practice 13: Retake Assessment","text":"<p>Objective: Provide an opportunity to revisit and demonstrate mastery of key topics.</p>"},{"location":"advanced_pl_sql/none/","title":"No contents","text":""},{"location":"archive/P1/","title":"Introduction","text":"<ul> <li>Dr. E. F. Codd proposed the relational model fordatabase systems in 1970.</li> <li>It is the basis for the relational databasemanagement system (RDBMS).</li> <li>The relational model consists of the following:<ul> <li>Collection of objects or relations</li> <li>Set of operators to act on the relations</li> <li>Data integrity for accuracy and consistency</li> </ul> </li> </ul> <p>A relational database is a collection of relations or two dimensional tables.</p> <p></p>"},{"location":"archive/P1/#data-models","title":"Data models","text":""},{"location":"archive/P1/#entity-relationship-model","title":"Entity Relationship Model","text":"<p>Create an entity relationship diagram frombusiness specifications or narratives:</p> <p></p> <p>Scenario:</p> <ul> <li>\u201c. . . Assign one or more employees to adepartment . . .\u201d</li> <li>\u201c. . . Some nikovits.departments do not yet have assignedemployees . . .\u201d</li> </ul>"},{"location":"archive/P1/#entity-relationship-modeling-conventions","title":"Entity Relationship Modeling Conventions","text":""},{"location":"archive/P1/#relating-multiple-tables","title":"Relating Multiple Tables","text":"<ul> <li>Each row of data in a table is uniquely identified bya primary key (PK).</li> <li>You can logically relate data from multiple tablesusing foreign keys (FK).</li> </ul>"},{"location":"archive/P1/#relational-database-terminology","title":"Relational Database Terminology","text":""},{"location":"archive/P1/#relational-database-properties","title":"Relational Database Properties:","text":"<ul> <li>Can be accessed and modified by executingstructured query language (SQL) statements</li> <li>Contains a collection of tables with no physicalpointers</li> <li>Uses a set of operators</li> </ul>"},{"location":"archive/P1/#communicating-with-an-rdbms-using-sql","title":"Communicating with an RDBMS Using SQL","text":""},{"location":"archive/P1/#sql-statements","title":"SQL Statements","text":""},{"location":"archive/P1/#order-of-statements","title":"Order of Statements","text":""},{"location":"archive/P1/#tables-used-in-the-course","title":"Tables Used in the Course","text":""},{"location":"archive/P1/#capabilities-of-sql-select-statements","title":"Capabilities of SQL SELECT Statements","text":""},{"location":"archive/P1/#basic-select-statement","title":"Basic SELECT Statement","text":"<pre><code>SELECT * | {[DISTINCT] column|expression [alias], ...}\nFROM table;\n</code></pre> <ul> <li>SELECT identifies the columns to be displayed</li> <li>FROM identifies the table containing those columns</li> </ul>"},{"location":"archive/P1/#selecting-all-columns","title":"Selecting All Columns","text":"<pre><code>SELECT * FROM nikovits.departments;\n</code></pre> DEPARTMENT_ID DEPARTMENT_NAME MANAGER_ID LOCATION_ID 10 Administration 200 1700 20 Marketing 201 1800 30 Purchasing 114 1700 40 Human Resources 203 2400 50 Shipping 121 1500 60 IT 103 1400 70 Public Relations 204 2700 80 Sales 145 2500 90 Executive 100 1700 100 Finance 108 1700 110 Accounting 205 1700 120 Treasury NULL 1700 130 Corporate Tax NULL 1700"},{"location":"archive/P1/#selecting-specific-columns","title":"Selecting Specific Columns","text":"<pre><code>SELECT department_id, location_id\nFROM nikovits.departments;\n</code></pre> DEPARTMENT_ID LOCATION_ID 10 1700 20 1800 30 1700 40 2400 50 1500 60 1400 70 2700 80 2500 90 1700 100 1700 110 1700 120 1700 130 1700 140 1700 150 1700 160 1700"},{"location":"archive/P1/#writing-sql-statements","title":"Writing SQL Statements","text":"<ul> <li>SQL statements are not case-sensitive.</li> <li>SQL statements can be on one or more lines.</li> <li>Keywords cannot be abbreviated or splitacross lines.</li> <li>Clauses are usually placed on separate lines.</li> <li>Indents are used to enhance readability.</li> <li>In SQL*Plus, SQL statements can optionally beterminated by a semicolon (;). Semicolons arerequired if you execute multiple SQLstatements.</li> </ul>"},{"location":"archive/P1/#arithmetic-expressions","title":"Arithmetic Expressions","text":"Operator Description + Add - Subtract * Multiply / Divide"},{"location":"archive/P1/#using-arithmetic-operators","title":"Using Arithmetic Operators","text":"<pre><code>SELECT last_name, salary, salary + 300\nFROM nikovits.employees;\n</code></pre> LAST_NAME SALARY SALARY+300 King 24000 24300 Kochhar 17000 17300 De Haan 17000 17300 Hunold 9000 9300 Ernst 6000 6300 Austin 4800 5100 Pataballa 4800 5100 Lorentz 4200 4500 Greenberg 12000 12300 Faviet 9000 9300 Chen 8200 8500 Sciarra 7700 8000 Urman 7800 8100"},{"location":"archive/P1/#operator-precedence","title":"Operator Precedence","text":"<pre><code>SELECT last_name, salary, 12*salary+100\nFROM nikovits.employees;\n</code></pre> LAST_NAME SALARY 12*SALARY+100 King 24000 288100 Kochhar 17000 204100 De Haan 17000 204100 Hunold 9000 108100 Ernst 6000 72100 Austin 4800 57700 Pataballa 4800 57700 Lorentz 4200 50500 Greenberg 12000 144100 Faviet 9000 108100 Chen 8200 98500 Sciarra 7700 92500 <pre><code>SELECT last_name, salary, 12*(salary+100)\nFROM nikovits.employees;\n</code></pre> LAST_NAME SALARY 12*(SALARY+100) King 24000 289200 Kochhar 17000 205200 De Haan 17000 205200 Hunold 9000 109200 Ernst 6000 73200 Austin 4800 58800 Pataballa 4800 58800 Lorentz 4200 51600 Greenberg 12000 145200 Faviet 9000 109200 Chen 8200 99600 Sciarra 7700 93600 Urman 7800 94800"},{"location":"archive/P1/#defining-a-null-value","title":"Defining a Null Value","text":"<ul> <li>A null is a value that is unavailable, unassigned,unknown, or inapplicable.</li> <li>A null is not the same as a zero or a blank space.</li> </ul> <pre><code>SELECT last_name, job_id, salary, commission_pct\nFROM nikovits.employees;\n</code></pre> LAST_NAME JOB_ID SALARY COMMISSION_PCT King AD_PRES 24000 NULL Kochhar AD_VP 17000 NULL De Haan AD_VP 17000 NULL Hunold IT_PROG 9000 NULL Ernst IT_PROG 6000 NULL Austin IT_PROG 4800 NULL Pataballa IT_PROG 4800 NULL Lorentz IT_PROG 4200 NULL Greenberg FI_MGR 12000 NULL Faviet FI_ACCOUNT 9000 NULL Chen FI_ACCOUNT 8200 NULL Sciarra FI_ACCOUNT 7700 NULL Urman FI_ACCOUNT 7800 NULL"},{"location":"archive/P1/#null-values-in-arithmetic-expressions","title":"Null Values in Arithmetic Expressions","text":"<p>Arithmetic expressions containing a null value evaluate to null.</p> <pre><code>SELECT last_name, 12*salary*commission_pct\nFROM nikovits.employees;\n</code></pre> LAST_NAME 12SALARYCOMMISSION_PCT King NULL Kochhar NULL De Haan NULL Hunold NULL Ernst NULL Austin NULL Pataballa NULL Lorentz NULL Greenberg NULL Faviet NULL Chen NULL Sciarra NULL Urman NULL"},{"location":"archive/P1/#defining-a-column-alias","title":"Defining a Column Alias","text":"<ul> <li>Renames a column heading</li> <li>Is useful with calculations</li> <li>Immediately follows the column name (There canalso be the optional AS keyword between thecolumn name and alias.)</li> <li>Requires double quotation marks if it containsspaces or special characters or if it is case-sensitive</li> </ul>"},{"location":"archive/P1/#using-column-aliases","title":"Using Column Aliases","text":"<pre><code>SELECT last_name AS name, commission_pct comm\nFROM nikovits.employees;\n</code></pre> NAME COMM King NULL Kochhar NULL De Haan NULL Hunold NULL Ernst NULL Austin NULL Pataballa NULL Lorentz NULL Greenberg NULL Faviet NULL Chen NULL Sciarra NULL Urman NULL <pre><code>SELECT last_name \"Name\" , salary*12 \"Annual Salary\"\nFROM nikovits.employees;\n</code></pre> Name Annual Salary King 288000 Kochhar 204000 De Haan 204000 Hunold 108000 Ernst 72000 Austin 57600 Pataballa 57600 Lorentz 50400 Greenberg 144000 Faviet 108000 Chen 98400 Sciarra 92400 Urman 93600"},{"location":"archive/P1/#concatenation-operator","title":"Concatenation Operator","text":"<ul> <li>Links columns or character strings to other columns</li> <li>Is represented by two vertical bars (||)</li> <li>Creates a resultant column that is a characterexpression</li> </ul> <pre><code>SELECT last_name||job_id AS \"Employees\"\nFROM nikovits.employees;\n</code></pre> Employees KingAD_PRES KochharAD_VP De HaanAD_VP HunoldIT_PROG ErnstIT_PROG AustinIT_PROG PataballaIT_PROG LorentzIT_PROG GreenbergFI_MGR FavietFI_ACCOUNT ChenFI_ACCOUNT SciarraFI_ACCOUNT UrmanFI_ACCOUNT"},{"location":"archive/P1/#literal-character-strings","title":"Literal Character Strings","text":"<ul> <li>A literal is a character, a number, or a date that is included in the SELECT statement.</li> <li>Date and character literal values must beenclosed by single quotation marks.</li> <li>Each character string is output once for eachrow returned.</li> </ul> <pre><code>SELECT last_name ||' is a '||job_id\nAS \"Employee Details\"\nFROM nikovits.employees;\n</code></pre>"},{"location":"archive/P1/#alternative-quoteq-operator","title":"Alternative Quote(q) Operator","text":"<ul> <li>Specify your own quotation mark delimiter</li> <li>Choose any delimiter (or {}, [], &lt;&gt; pairs)</li> <li>Increase readability and usability</li> </ul> <pre><code>SELECT department_name ||\n        q'[, it's assigned Manager Id: ]'\n        || manager_id\n        AS \"Department and Manager\"\nFROM nikovits.departments;\n</code></pre>"},{"location":"archive/P1/#duplicate-rows","title":"Duplicate Rows","text":"<pre><code>SELECT department_id\nFROM nikovits.employees;\n</code></pre> DEPARTMENT_ID 90 90 90 60 60 60 60 60 100 100 100 100 100 100 30 30 <pre><code>SELECT DISTINCT department_id\nFROM nikovits.employees;\n</code></pre> DEPARTMENT_ID 100 30 NULL 90 20 70 110 50 80 40 60 10"},{"location":"archive/P1/#sql-statements-versus-sqlplus-commands","title":"SQL Statements Versus SQL*Plus Commands","text":"SQL SQL*Plus A language An environment ANSI standard Oracle-proprietary Keyword cannot be abbreviated Keywords can be abbreviated Statements manipulate data and table definitions in the database Commands do not allow manipulation of values in the database Runs in database Runs on a client machine"},{"location":"archive/P1/#displaying-table-structure","title":"Displaying Table Structure","text":"<pre><code>DESCRIBE nikovits.employees\n</code></pre>"},{"location":"archive/P1/#limiting-the-rows-that-are-selected","title":"Limiting the Rows That Are Selected","text":"<p>Restrict the rows that are returned by using the WHERE clause.</p> <pre><code>SELECT * | {[DISTINCT] column|expression [alias], ...}\nFROM table\n[WHERE condition(s)];\n</code></pre> <p>The WHERE clause follows the FROM clause.</p> <pre><code>SELECT employee_id, last_name, job_id, department_id\nFROM nikovits.employees\nWHERE department_id = 90 ;\n</code></pre> EMPLOYEE_ID LAST_NAME JOB_ID DEPARTMENT_ID 100 King AD_PRES 90 101 Kochhar AD_VP 90 102 De Haan AD_VP 90"},{"location":"archive/P1/#character-strings-and-dates","title":"Character Strings and Dates","text":"<ul> <li>Character strings and date values are enclosed bysingle quotation marks.</li> <li>Character values are case-sensitive, and date valuesare format-sensitive.</li> <li>The default date format is DD-MON-YY.</li> </ul> <p>You can change the default date format with:</p> <pre><code>ALTER SESSION SET nls_date_format='yyyy.mm.dd';\n</code></pre> <pre><code>SELECT last_name, job_id, department_id\nFROM nikovits.employees\nWHERE last_name = 'Whalen' ;\n</code></pre> LAST_NAME JOB_ID DEPARTMENT_ID Whalen AD_ASST 10"},{"location":"archive/P1/#comparison-conditions","title":"Comparison Conditions","text":"Operator Meaning = Equal to &gt; Greater than &gt;= Greater than or equal to &lt; Less than &lt;= Less than or equal to &lt;&gt; Not equal to BETWEEN ... AND ... Between two values (inclusive) IN (set) Match any of a list of values LIKE Match a character pattern IS NULL Is a null value <pre><code>SELECT last_name, salary\nFROM nikovits.employees\nWHERE salary &lt;= 3000 ;\n</code></pre> LAST_NAME SALARY Baida 2900 Tobias 2800 Himuro 2600 Colmenares 2500 Mikkilineni 2700 Landry 2400 Markle 2200 Atkinson 2800 Marlow 2500 Olson 2100 Rogers 2900 Gee 2400 Philtanker 2200"},{"location":"archive/P1/#use-the-between-condition-to-display-rows-based-on-arange-of-values","title":"Use the BETWEEN condition to display rows based on arange of values:","text":"<pre><code>SELECT last_name, salary\nFROM nikovits.employees\nWHERE salary BETWEEN 2500 AND 3500 ;\n</code></pre> LAST_NAME SALARY Khoo 3100 Baida 2900 Tobias 2800 Himuro 2600 Colmenares 2500 Nayer 3200 Mikkilineni 2700 Bissot 3300 Atkinson 2800 Marlow 2500 Mallin 3300 Rogers 2900"},{"location":"archive/P1/#use-the-in-membership-condition-to-test-for-values-in-a-list","title":"Use the IN membership condition to test for values in a list:","text":"<pre><code>SELECT employee_id, last_name, salary, manager_id\nFROM nikovits.employees\nWHERE manager_id IN (100, 101, 201) ;\n</code></pre> EMPLOYEE_ID LAST_NAME SALARY MANAGER_ID 101 Kochhar 17000 100 102 De Haan 17000 100 108 Greenberg 12000 101 114 Raphaely 11000 100 120 Weiss 8000 100 121 Fripp 8200 100 122 Kaufling 7900 100 123 Vollman 6500 100 124 Mourgos 5800 100 145 Russell 14000 100 146 Partners 13500 100"},{"location":"archive/P1/#using-the-like-condition","title":"Using the LIKE Condition","text":"<ul> <li>Use the LIKE condition to perform wildcardsearches of valid search string values.</li> <li>Search conditions can contain either literalcharacters or numbers:<ul> <li>% denotes zero or many characters.</li> <li>_ denotes one character.</li> </ul> </li> </ul> <pre><code>SELECT first_name\nFROM nikovits.employees\nWHERE first_name LIKE 'S%' ;\n</code></pre> FIRST_NAME Steven Shelli Sigal Shanta Steven Stephen Sarath"},{"location":"archive/P1/#using-the-like-condition_1","title":"Using the LIKE Condition","text":"<p>You can use the ESCAPE identifier to search forthe actual % and _ symbols.</p> <pre><code>SELECT employee_id, last_name, job_id\nFROM employees\nWHERE job_id LIKE '%SA\\_%' ESCAPE '\\';\n</code></pre> <pre><code>SELECT last_name\nFROM nikovits.employees\nWHERE last_name LIKE '_o%' ;\n</code></pre> LAST_NAME Kochhar Lorentz Popp Tobias Colmenares Vollman Mourgos Rogers"},{"location":"archive/P1/#using-the-null-conditions","title":"Using the NULL Conditions","text":"<pre><code>SELECT last_name, manager_id\nFROM nikovits.employees\nWHERE manager_id IS NULL ;\n</code></pre> LAST_NAME MANAGER_ID King NULL"},{"location":"archive/P1/#logical-conditions","title":"Logical Conditions","text":"Operator Meaning AND Returns TRUE if both component conditions are true OR Returns TRUE if either component condition is true NOT Returns TRUE if the following condition is false"},{"location":"archive/P1/#3-valued-logic","title":"3-valued logic","text":""},{"location":"archive/P1/#and-operator","title":"AND Operator","text":"AND TRUE FALSE NULL TRUE TRUE FALSE NULL FALSE FALSE FALSE FALSE NULL NULL FALSE NULL"},{"location":"archive/P1/#or-operator","title":"OR Operator","text":"OR TRUE FALSE NULL TRUE TRUE TRUE TRUE FALSE TRUE FALSE NULL NULL TRUE NULL NULL"},{"location":"archive/P1/#not-operator","title":"NOT Operator","text":"NOT Result TRUE FALSE FALSE TRUE NULL NULL"},{"location":"archive/P1/#using-the-and-operator","title":"Using the AND Operator","text":"<pre><code>SELECT employee_id, last_name, job_id, salary\nFROM nikovits.employees\nWHERE salary &gt;=10000\nAND job_id LIKE '%MAN%' ;\n</code></pre> EMPLOYEE_ID LAST_NAME JOB_ID SALARY 114 Raphaely PU_MAN 11000 145 Russell SA_MAN 14000 146 Partners SA_MAN 13500 147 Errazuriz SA_MAN 12000 148 Cambrault SA_MAN 11000 149 Zlotkey SA_MAN 10500 201 Hartstein MK_MAN 13000"},{"location":"archive/P1/#using-the-or-operator","title":"Using the OR Operator","text":"<pre><code>SELECT employee_id, last_name, job_id, salary\nFROM nikovits.employees\nWHERE salary &gt;= 10000\nOR job_id LIKE '%MAN%' ;\n</code></pre> EMPLOYEE_ID LAST_NAME JOB_ID SALARY 100 King AD_PRES 24000 101 Kochhar AD_VP 17000 102 De Haan AD_VP 17000 108 Greenberg FI_MGR 12000 114 Raphaely PU_MAN 11000 120 Weiss ST_MAN 8000 121 Fripp ST_MAN 8200 122 Kaufling ST_MAN 7900 123 Vollman ST_MAN 6500 124 Mourgos ST_MAN 5800 145 Russell SA_MAN 14000"},{"location":"archive/P1/#using-the-not-operator","title":"Using the NOT Operator","text":"<pre><code>SELECT last_name, job_id\nFROM nikovits.employees\nWHERE job_id\nNOT IN ('IT_PROG', 'ST_CLERK', 'SA_REP') ;\n</code></pre> LAST_NAME JOB_ID King AD_PRES Kochhar AD_VP De Haan AD_VP Greenberg FI_MGR Faviet FI_ACCOUNT Chen FI_ACCOUNT Sciarra FI_ACCOUNT Urman FI_ACCOUNT Popp FI_ACCOUNT Raphaely PU_MAN Khoo PU_CLERK Baida PU_CLERK Tobias PU_CLERK Himuro PU_CLERK"},{"location":"archive/P1/#rules-of-precedence","title":"Rules of Precedence","text":"<p>Operators in SQL expressions are evaluated according to the following precedence (highest to lowest):</p> Priority Operator/Condition 1 Arithmetic operators (+, -, *, /) 2 Concatenation operator (||) 3 Comparison conditions (=, &gt;, &lt;, &gt;=, &lt;=, &lt;&gt;) 4 IS [NOT] NULL, LIKE, [NOT] IN 5 [NOT] BETWEEN 6 Not equal to (&lt;&gt;) 7 NOT logical condition 8 AND logical condition 9 OR logical condition <p>You can use parentheses <code>()</code> to override the default precedence rules and explicitly control the order of evaluation.</p> <pre><code>SELECT last_name, job_id, salary\nFROM nikovits.employees\nWHERE job_id = 'SA_REP'\nOR job_id = 'AD_PRES'\nAND salary &gt; 15000;\n</code></pre> LAST_NAME JOB_ID SALARY King AD_PRES 24000 Tucker SA_REP 10000 Bernstein SA_REP 9500 Hall SA_REP 9000 Olsen SA_REP 8000 Cambrault SA_REP 7500 Tuvault SA_REP 7000 King SA_REP 10000 Sully SA_REP 9500 McEwen SA_REP 9000 Smith SA_REP 8000 Doran SA_REP 7500 <pre><code>SELECT last_name, job_id, salary\nFROM nikovits.employees\nWHERE (job_id = 'SA_REP'\nOR job_id = 'AD_PRES')\nAND salary &gt; 15000;\n</code></pre> LAST_NAME JOB_ID SALARY King AD_PRES 24000"},{"location":"archive/P1/#using-the-order-by-clause","title":"Using the ORDER BY Clause","text":"<ul> <li>Sort retrieved rows with the ORDER BY clause:<ul> <li>ASC: ascending order, default</li> <li>DESC: descending order</li> </ul> </li> </ul> <pre><code>SELECT last_name, job_id, department_id, hire_date\nFROM nikovits.employees\nORDER BY hire_date ;\n</code></pre> LAST_NAME JOB_ID DEPARTMENT_ID HIRE_DATE King AD_PRES 90 17/06/87 Whalen AD_ASST 10 17/09/87 Kochhar AD_VP 90 21/09/89 Hunold IT_PROG 60 03/01/90 Ernst IT_PROG 60 21/05/91 De Haan AD_VP 90 13/01/93 Mavris HR_REP 40 07/06/94 Baer PR_REP 70 07/06/94 Higgins AC_MGR 110 07/06/94 Gietz AC_ACCOUNT 110 07/06/94 Faviet FI_ACCOUNT 100 16/08/94 Greenberg FI_MGR 100 17/08/94"},{"location":"archive/P1/#descending-order","title":"Descending order","text":"<pre><code>SELECT last_name, job_id, department_id, hire_date\nFROM nikovits.employees\nORDER BY hire_date DESC ;\n</code></pre> LAST_NAME JOB_ID DEPARTMENT_ID HIRE_DATE Kumar SA_REP 80 21/04/00 Banda SA_REP 80 21/04/00 Ande SA_REP 80 24/03/00 Markle ST_CLERK 50 08/03/00 Lee SA_REP 80 23/02/00 Philtanker ST_CLERK 50 06/02/00 Geoni SH_CLERK 50 03/02/00 Zlotkey SA_MAN 80 29/01/00 Marvins SA_REP 80 24/01/00 Grant SH_CLERK 50 13/01/00 Johnson SA_REP 80 04/01/00 Perkins SH_CLERK 50 19/12/99 Gee ST_CLERK 50 12/12/99"},{"location":"archive/P1/#alias","title":"Alias","text":"<pre><code>SELECT employee_id, last_name, salary*12 annsal\nFROM nikovits.employees\nORDER BY annsal ;\n</code></pre> EMPLOYEE_ID LAST_NAME ANNSAL 132 Olson 25200 128 Markle 26400 136 Philtanker 26400 135 Gee 28800 127 Landry 28800 119 Colmenares 30000 131 Marlow 30000 140 Patel 30000 144 Vargas 30000 182 Sullivan 30000 191 Perkins 30000 143 Matos 31200"},{"location":"archive/P1/#multiple-columns","title":"Multiple columns","text":"<pre><code>SELECT last_name, department_id, salary\nFROM nikovits.employees\nORDER BY department_id, salary DESC;\n</code></pre> LAST_NAME DEPARTMENT_ID SALARY Whalen 10 4400 Hartstein 20 13000 Fay 20 6000 Raphaely 30 11000 Khoo 30 3100 Baida 30 2900 Tobias 30 2800 Himuro 30 2600 Colmenares 30 2500 Mavris 40 6500"},{"location":"archive/P1/#substitution-variables","title":"Substitution Variables","text":""},{"location":"archive/P1/#usesqlplus-substitution-variables-to","title":"UseSQL*Plus substitution variables to:","text":"<ul> <li>Temporarily store values with single-ampersand (&amp;) and double-ampersand(&amp;&amp;) substitution</li> <li>Use substitution variables to supplement the following:<ul> <li>WHERE conditions</li> <li>ORDER BY clauses</li> <li>Column expressions</li> <li>Table names</li> <li>Entire SELECT statements</li> </ul> </li> </ul>"},{"location":"archive/P1/#using-the-substitution-variable","title":"Using the &amp; Substitution Variable","text":"<p>Use a variable prefixed with an ampersand (&amp;) to prompt the user for a value:</p> <pre><code>SELECT employee_id, last_name, salary, department_id\nFROM nikovits.employees\nWHERE employee_id = &amp;employee_num ;\n</code></pre>"},{"location":"archive/P1/#character-and-date-values-with-substitution-variables","title":"Character and Date Values with Substitution Variables","text":"<p>Use single quotation marks for date and character values:</p> <pre><code>SELECT last_name, department_id, salary*12\nFROM nikovits.employees\nWHERE job_id = '&amp;job_title' ;\n</code></pre>"},{"location":"archive/P1/#specifying-column-names-expressions-and-text","title":"Specifying Column Names, Expressions, and Text","text":"<pre><code>SELECT employee_id, last_name, job_id,&amp;column_name\nFROM nikovits.employees\nWHERE &amp;condition\nORDER BY &amp;order_column ;\n</code></pre>"},{"location":"archive/P1/#using-the-substitution-variable_1","title":"Using the &amp;&amp; Substitution Variable","text":"<p>Use the double ampersand (&amp;&amp;) if you want to reuse the variable value without prompting the user eachtime:</p> <pre><code>SELECT employee_id, last_name, job_id, &amp;&amp;column_name\nFROM nikovits.employees\nORDER BY &amp;column_name ;\n</code></pre> <ul> <li>Use the SQLPlus DEFINE* command to create and assign a value to a variable.</li> <li>Use the SQLPlus UNDEFINE* command to remove a variable.</li> </ul> <pre><code>DEFINE employee_num = 200\nSELECT employee_id, last_name, salary, department_id\nFROM nikovits.employees\nWHERE employee_id = &amp;employee_num ;\nUNDEFINE employee_num\n</code></pre>"},{"location":"archive/P10/","title":"Exceptions","text":"<p>Handling Exceptions:</p> <ul> <li>Trap the exception: Exception is raised and trapped within DECLARE, BEGIN, EXCEPTION, END block.</li> <li>Propagate the exception: Exception is raised, not trapped, and propagates to calling environment.</li> </ul> <p>Exception Types:</p> <ul> <li>Predefined Oracle Server: Implicitly raised</li> <li>Non-predefined Oracle Server: Implicitly raised</li> <li>User-defined: Explicitly raised</li> </ul> <p>Trapping Exceptions Guidelines:</p> <ul> <li>WHEN OTHERS is the last clause.</li> <li>EXCEPTION keyword starts exception-handling section.</li> <li>Several exception handlers are allowed.</li> <li>Only one handler is processed before leaving the block.</li> <li>Reference the standard name in the exception-handling routine.</li> <li>Sample predefined exceptions:<ul> <li>NO_DATA_FOUND</li> <li>TOO_MANY_ROWS</li> <li>INVALID_CURSOR</li> <li>ZERO_DIVIDE</li> <li>DUP_VAL_ON_INDEX</li> </ul> </li> </ul> <pre><code>set serveroutput on\nDECLARE\n  except1 EXCEPTION;\n  PRAGMA exception_init(except1, -20000);\nBEGIN\n  raise_application_error('-20001', 'except2');   -- comment this line\n  RAISE except1;                                  -- then comment this line too \n  DECLARE\n    V NUMBER := 1/0;                              -- finally change it to 1/1\n  BEGIN\n    V := 1/0;\n  EXCEPTION \n    WHEN OTHERS THEN dbms_output.put_line('inner block');\n  END;\nEXCEPTION \n  WHEN OTHERS THEN dbms_output.put_line(SQLCODE||' ~~~ '||sqlerrm);\nEND;\n/\n</code></pre> <pre>\nResults:\n----------\nfirst output:  -20001 ~~~ ORA-20001: except2\nsecond output: -20000 ~~~ ORA-20000:\nthird output:  -1476 ~~~ ORA-01476: division by zero\nfourth output: inner block\n</pre> <p>Trapping Non-Predefined Oracle Server Errors:</p> <ul> <li>Declare: Name the exception (Declarative section)</li> <li>Associate: Code the PRAGMA EXCEPTION_INIT</li> <li>Reference: Handle the raised exception (Exception-handling section)</li> </ul> <pre><code>e_emps_remaining EXCEPTION;\nPRAGMA EXCEPTION_INIT (e_emps_remaining, -2292)\n</code></pre> <p>Trapping User-Defined Exceptions:</p> <ul> <li>Declare: Name the exception (Declarative section)</li> <li>Raise: Explicitly raise the exception by using the RAISE statement (Executable section)</li> <li>Reference: Handle the raised exception (Exception-handling section)</li> </ul> <pre><code>e_invalid_product EXCEPTION;\nRAISE e_invalid_product;\n</code></pre> <p>Functions for Trapping Exceptions:</p> <ul> <li>SQLCODE: Returns the numeric value for the error code</li> <li>SQLERRM: Returns the message associated with the error number</li> </ul> <pre><code>/* Raising an error from a subprogram */\n\nDECLARE\n  v1 NUMBER :=0;\n  FUNCTION f1 RETURN NUMBER IS\n  except1 EXCEPTION;\n  BEGIN\n    raise except1;                                    -- comment this line\n    raise_application_error('-20000', 'exception1');  -- finally comment this too\n    RETURN 10;\n  EXCEPTION \n    WHEN except1 THEN RETURN 20;\n    WHEN OTHERS THEN RETURN 30;                       -- then comment this too\n  END f1;\nBEGIN\n  v1 := f1; dbms_output.put_line(v1);\nEXCEPTION \n  WHEN OTHERS THEN dbms_output.put_line(SQLCODE||' ~~~ '||sqlerrm);\nEND;\n/\n</code></pre> <pre>\nResults:\n------------\nfirst output:   20\nsecond output:  30\nthird output:   -20000 ~~~ ORA-20000: exception1\nfourth output:  10\n</pre> <p>Calling Environments:</p> <ul> <li>SQL*Plus: Displays error number and message to screen</li> <li>Sql Developer: Displays error number and message to screen</li> <li>Oracle Developer Forms: Accesses error number and message in a trigger by means of the ERROR_CODE and ERROR_TEXT packaged functions</li> <li>Precompiler application: Accesses exception number through the SQLCA data structure</li> <li>An enclosing PL/SQL block: Traps exception in exception-handling routine of enclosing block</li> </ul> <pre><code>raise_application_error (error_number, message[, {TRUE | FALSE}]);\n</code></pre> <p>RAISE_APPLICATION_ERROR Procedure:</p> <ul> <li>A procedure that lets you issue user-defined error messages from stored subprograms</li> <li>Called only from an executing stored subprogram</li> </ul>"},{"location":"archive/P10/#predefined-exceptions","title":"Predefined exceptions","text":"<pre><code>SELECT text FROM all_source WHERE type = 'PACKAGE'\nAND name = 'STANDARD' AND lower(text) LIKE '%exception_init%';\n</code></pre> <p>Put comments before some statements (or delete comments) to test other exceptions.</p> <pre><code>SET SERVEROUTPUT ON\nBEGIN                       -- 3 nested blocks\n DECLARE\n  v1 emp.sal%TYPE;\n  v2 emp.comm%TYPE;\n  v3 INTEGER := 0;\n BEGIN\n  v3 := 1/v3;                  -- comment this second\n  BEGIN\n   SELECT sal, comm INTO v1, v2 FROM emp WHERE ename LIKE 'S%';  -- then change it to  'X%'\n  EXCEPTION\n   WHEN too_many_rows THEN \n    BEGIN\n     v1 := 1; v2 := 2;\n    END;\n  END;\n  dbms_output.put_line(to_char(v1)||' -- '|| nvl(to_char(v2), 'null'));\n\n EXCEPTION\n  WHEN zero_divide THEN dbms_output.put_line('zero divide');      -- comment this first       \n  WHEN too_many_rows THEN dbms_output.put_line('too many rows');\n END;\n dbms_output.put_line('main program');\nEXCEPTION\n  WHEN OTHERS THEN dbms_output.put_line(SQLCODE || ' -- ' || sqlerrm);\nEND;\n/\n</code></pre> <pre>\nResults:\n-----------\nfirst output:   zero divide\n                main program\nsecond output:  -1476 -- ORA-01476: division by zero\nthird output:   1 -- 2        too many rows handled\n                main program\nfourth output:  100 -- ORA-01403: No Data found\n</pre> <pre><code>-- Printing error codes\n\nBEGIN\n dbms_output.put_line(sqlerrm(-6502));\nEND;\n/\n</code></pre> <pre><code>-- put comments before the first 5 lines one by one to test other exceptions\n\nset serveroutput on\nDECLARE \n  v_nev  VARCHAR2(20);\n  v_szam NUMBER := 0;\n  CURSOR emp_cur IS SELECT ename FROM emp;\n\n  error1 EXCEPTION;\n  pragma EXCEPTION_INIT(error1, -20001);\n  error2 EXCEPTION;\n  pragma EXCEPTION_INIT(error2, -20002);\n\n  PROCEDURE err_proc(v NUMBER) IS\n  BEGIN\n    IF MOD(v, 2) = 0 THEN\n      RAISE_APPLICATION_ERROR('-20001', 'error1');\n    ELSE\n      RAISE_APPLICATION_ERROR('-20002', 'error2');\n    END IF;\n  END;\n\nBEGIN\n  err_proc(1);                                        -- error2\n  err_proc(2);                                        -- error1\n  v_szam := 1/v_szam;                                 -- zero divide\n  SELECT ename INTO v_nev FROM emp WHERE empno &lt; 0;   -- no_data found\n  SELECT ename INTO v_nev FROM emp WHERE empno &gt; 0;   -- too_many_rows\n  OPEN emp_cur;\n  LOOP\n    FETCH emp_cur INTO v_nev;\n    EXIT WHEN emp_cur%notfound;\n    dbms_output.put(v_nev||' -&gt; ');\n    dbms_output.put_line(to_char(emp_cur%rowcount));\n  END LOOP;\n  CLOSE emp_cur;\nEXCEPTION\n  WHEN error1 THEN\n    dbms_output.put_line('error1 occured');\n  WHEN error2 THEN\n    dbms_output.put_line('error2 occured');\n  WHEN zero_divide THEN\n    dbms_output.put_line('zero divide error');\n  WHEN no_data_found THEN\n    dbms_output.put_line('No Data Found error');\n  WHEN too_many_rows THEN\n    dbms_output.put_line('Too many rows error');\n  WHEN OTHERS THEN\n    dbms_output.put_line('something else ...');\nEND;\n/\n</code></pre>"},{"location":"archive/P10/#functions-and-procedures","title":"Functions and procedures","text":""},{"location":"archive/P10/#procedural-parameter-modes","title":"Procedural Parameter Modes","text":""},{"location":"archive/P10/#in-parameters","title":"IN Parameters","text":"<p>7369 \u2194 v_id</p> <pre><code>CREATE OR REPLACE PROCEDURE raise_salary\n(v_id in emp.empno%TYPE)\nIS\nBEGIN\n  UPDATE emp\n  SET sal = sal * 1.10\n  WHERE empno = v_id;\nEND raise_salary;\n/\n</code></pre> <p>Procedure created.</p> <p>SQL&gt; EXECUTE raise_salary (7369)</p> <p>PL/SQL procedure successfully completed.</p>"},{"location":"archive/P10/#out-parameters","title":"OUT Parameters","text":"<p>Calling environment</p> <pre><code>654 \u2194 v_id \u2194 v_name \u2194 v_salary \u2194 v_comm\n</code></pre> <p>QUERY_EMP procedure</p> <pre><code>v_id, MARTIN v_name, 1250 v_salary, 1400 v_comm\n</code></pre> <pre><code>CREATE OR REPLACE PROCEDURE query_emp\n(v_id IN emp.empno%TYPE,\nv_name OUT emp.ename%TYPE,\nv_salary OUT emp.sal%TYPE,\nv_comm OUT emp.comm%TYPE)\nIS\nBEGIN\n  SELECT ename, sal, comm\n  INTO v_name, v_salary, v_comm\n  FROM emp\n  WHERE empno = v_id;\nEND query_emp;\n/\n</code></pre>"},{"location":"archive/P10/#in-out-parameters","title":"IN OUT Parameters","text":"<p>Calling environment</p> <pre><code>'(800)633-0575' \u2194 v_phone_no\n</code></pre> <p>FORMAT_PHONE procedure</p> <pre><code>'(800)633-0575' v_phone_no\n</code></pre> <pre><code>CREATE OR REPLACE PROCEDURE format_phone\n(v_phone_no IN OUT VARCHAR2)\nIS\nBEGIN\n   v_phone_no := '(' || SUBSTR(v_phone_no,1,3) || ')'\n                     || SUBSTR(v_phone_no,4,3) || '-'\n                     || SUBSTR(v_phone_no,7);\nEND format_phone;\n/\n</code></pre> <pre><code>-- Some simple examples for PL/SQL functions and procedures\n-- These are local (not stored) subprograms\nDECLARE\n  num number(6);\n\n  FUNCTION func_plus_1(num number) RETURN number IS\n    v NUMBER(6);\n  BEGIN\n    v := num + 1;\n    return(v);\n  END;\n\n  PROCEDURE proc_plus_1(num number) is\n    v NUMBER(6);\n  BEGIN\n    v := num + 1;\n    dbms_output.put_line(TO_CHAR(v));\n  END;\n\nBEGIN\n  num := func_plus_1(100);\n  proc_plus_1(num);\nEND;\n/\n</code></pre> <pre>\nResults: \n-------\n102\n</pre> <pre><code>-- These are stored (in the database) subprograms, we can call them later at any time.\n\nCREATE OR REPLACE FUNCTION func_plus_2(num number) RETURN number IS\n  v NUMBER(6);\nBEGIN\n  v := num + 2;\n  return(v);\nEND;\n/      \n-- We can call the function from within SQL\nSELECT func_plus_2(1000) FROM dual;\n\nCREATE OR REPLACE PROCEDURE proc_plus_2(num number) is\n  v NUMBER(6);\nBEGIN\n  v := num + 2;\n  dbms_output.put_line(TO_CHAR(v));\nEND;\n/\n\n-- We can call the procedure\nCALL proc_plus_2(2000);\n-- Or equivalently\nEXECUTE proc_plus_2(2000);\n</code></pre> <pre><code>-- subprogram without parameter\nset serveroutput on\nDECLARE\n  num number(6) := 1;\n  PROCEDURE pr1 is           -- don't use paranthesis!\n    v NUMBER(6);\n  BEGIN\n    v := num + 1;\n    dbms_output.put_line(TO_CHAR(v));\n  END;\nBEGIN\n  pr1();    -- you can use paranthesis, but pr1 is ok too\nEND;\n/\n</code></pre>"},{"location":"archive/P10/#examples-of-passing-parameters","title":"Examples of Passing Parameters","text":"<pre><code>begin\n  add_dept(('TRAINING', 'NEW YORK'));\n  add_dept(v_loc =&gt; 'DALLAS', v_name =&gt;'EDUCATION');\n  add_dept(v_loc =&gt; 'BOSTON');\nend;\n/\n</code></pre> <pre><code>/*******  overloading   ******/\nset serveroutput on\nDECLARE\n  PROCEDURE proc1(p IN NUMBER) IS\n  BEGIN\n    DBMS_OUTPUT.PUT_LINE('number param');\n  END;\n\n  PROCEDURE proc1(p IN VARCHAR2) IS\n  BEGIN\n    DBMS_OUTPUT.PUT_LINE('varchar2 param');\n  END;\nBEGIN\n  proc1(100);\n  proc1('100');\nEND;\n/\n</code></pre> <pre>\nResults:\n---------\nnumber param\nvarchar2 param\n</pre> <pre><code>/****************** forward declaration ****************/\nset serveroutput on\nDECLARE\n  PROCEDURE proc2(p IN NUMBER);\n\n  PROCEDURE proc1(p IN NUMBER) IS\n  BEGIN\n    IF p &lt; 10 THEN  DBMS_OUTPUT.PUT_LINE(p); proc2(p+1);  END IF;\n  END;\n\n  PROCEDURE proc2(p IN NUMBER) IS\n  BEGIN\n    IF p &lt; 10 THEN  DBMS_OUTPUT.PUT_LINE(p); proc1(p*2);  END IF;\n  END;\nBEGIN\n  proc1(0);\nEND;\n/\n</code></pre> <pre>\nResults:\n---------\n0; 1; 2; 3; 6; 7;\n</pre>"},{"location":"archive/P10/#executing-functions","title":"Executing Functions","text":"<ul> <li>Invoke a function as part of a PL/SQL expression.</li> <li>Create a host variable to hold the returned value.</li> <li>Execute the function. The host variable will be populated by the RETURN value.</li> </ul>"},{"location":"archive/P10/#executing-functions-in-sqlplus","title":"Executing Functions in SQL*Plus","text":"<pre><code>-- return value of a function as a default parameter of a procedure\nset serveroutput on\nDECLARE\n  cnt pls_integer := 0;\n\n  FUNCTION dflt RETURN pls_integer IS\n  BEGIN\n    cnt := cnt + 1;         -- changes global variable cnt\n    RETURN 42;\n  END dflt;\n\n  PROCEDURE p (i IN pls_integer := dflt() ) IS    -- side effect if parameter is not provided\n  BEGIN\n    DBMS_Output.Put_Line(i);\n  END p;\n\nBEGIN\n  FOR j IN 1..3 LOOP\n   p(j);            -- Actual parameter is provided, no function call\n  END loop;\n  DBMS_Output.Put_Line('cnt: '||cnt);\n  p();              -- Actual parameter is not provided, function call, side effect\n  DBMS_Output.Put_Line('cnt: '||cnt);\nEND;\n/\n</code></pre> <pre>\nResult:\n---------\n1\n2\n3\nCnt: 0\n42\nCnt: 1\n</pre>"},{"location":"archive/P10/#calling-functions-from-sql-expressions-restrictions","title":"Calling Functions from SQL Expressions: Restrictions","text":"<ul> <li>A user-defined function must be a stored function.</li> <li>A user-defined function must be a ROW function, not a GROUP function.</li> <li>A user-defined function only takes IN parameters, not OUT, or IN OUT.</li> <li>Datatypes must be CHAR, DATE, or NUMBER, not PL/SQL types such as BOOLEAN, RECORD, or TABLE.</li> <li>Return type must be an Oracle Server internal type.</li> <li>INSERT, UPDATE, or DELETE commands are not allowed.</li> <li>Calls to subprograms that break the above restriction are not allowed.</li> </ul>"},{"location":"archive/P10/#procedure-or-function","title":"Procedure or Function?","text":"Procedure Function Execute as a PL/SQL statement Invoke as part of an expression No RETURN datatype Must contain a RETURN datatype Can return one or more values Must return a value"},{"location":"archive/P11/","title":"Recursion in SQL and Datalog","text":"<pre><code>-- Create an empty table then insert rows:\nCREATE TABLE Flight(airline VARCHAR2(10), orig VARCHAR2(15), dest VARCHAR2(15), cost NUMBER);\n\nINSERT INTO flight VALUES('Lufthansa', 'San Francisco', 'Denver', 1000);\nINSERT INTO flight VALUES('Lufthansa', 'San Francisco', 'Dallas', 10000);\nINSERT INTO flight VALUES('Lufthansa', 'Denver', 'Dallas', 500);\nINSERT INTO flight VALUES('Lufthansa', 'Denver', 'Chicago', 2000);\nINSERT INTO flight VALUES('Lufthansa', 'Dallas', 'Chicago', 600);\nINSERT INTO flight VALUES('Lufthansa', 'Dallas', 'New York', 2000);\nINSERT INTO flight VALUES('Lufthansa', 'Chicago', 'New York', 3000);\nINSERT INTO flight VALUES('Lufthansa', 'Chicago', 'Denver', 2000);\n\n-- The tuples are not the same as in TextBook. I inserted an extra tuple \n-- in order to have a cycle in the graph of Flight table. \n--&gt; orig = 'Chicago' and dest = 'Denver';\n</code></pre>"},{"location":"archive/P11/#flight-table","title":"Flight Table:","text":"Airline Origin Destination Cost Lufthansa San Francisco Denver 1000 Lufthansa San Francisco Dallas 10000 Lufthansa Denver Dallas 500 Lufthansa Denver Chicago 2000 Lufthansa Dallas Chicago 600 Lufthansa Dallas New York 2000 Lufthansa Chicago New York 3000 Lufthansa Chicago Denver 2000"},{"location":"archive/P11/#datalog-programs","title":"DATALOG programs","text":"<p>Datalog is a logical query language (Data Logic). See textbook (Ullman ch. 5.3, 5.4 and 10.2)</p> <p>Let's see relation Reaches(x,y) which answers the following query.</p> <p>For what pairs of cities (x, y) is it possible to get from city x to city y by taking one or more flights?</p>"},{"location":"archive/P11/#a-recursive-datalog-program-for-the-reaches-table","title":"A recursive DATALOG program for the REACHES table:","text":"<p>Reaches(X,Y)  &lt;--  Flight(,X,Y,)</p> <p>Reaches(X,Y)  &lt;--  Reaches(X,Z) AND Reaches(Z,Y) AND X &lt;&gt; Y</p> <p>Most DBMS-s allow only linear recursion in recursive queries, which means: no rule has more than one subgoal that is mutually recursive with the head. </p> <p>---&gt; if there is a cycle involving R and S, they are mutually recursive</p> <p>In the previous datalog program the second rule violates this requirement.</p> <p>The datalog program below contains only linear recursion:</p> <p>Reaches(X,Y)  &lt;--  Flight(,X,Y,)</p> <p>Reaches(X,Y)  &lt;--  Flight(,X,Z,) AND Reaches(Z,Y) AND X &lt;&gt; Y</p> <pre><code>-- SQL query  (Flight is the first edge on the route)\n---------\nWITH  reaches(orig, dest) AS \n (\n  SELECT orig, dest FROM flight\n   UNION ALL\n  SELECT flight.orig, reaches.dest FROM flight, reaches\n  WHERE flight.dest = reaches.orig AND flight.orig &lt;&gt; reaches.dest\n  )\n  CYCLE orig, dest SET is_cycle TO 'Y' DEFAULT 'N' \nSELECT  distinct orig, dest, is_cycle FROM reaches order by 1,2,3;\n</code></pre> <pre>\nResults:\n---------\nChicago Dallas  N\nChicago Denver  N\nChicago New York N\nChicago New York Y\nDallas Chicago  N\n...\n</pre> <pre><code>-- Another SQL query  (Flight is the last edge on the route)\n-----------------\nWITH  reaches(orig, dest) AS \n (\n  SELECT orig, dest FROM flight\n   UNION ALL\n  SELECT reaches.orig, flight.dest FROM reaches, flight\n  WHERE reaches.dest = flight.orig  AND reaches.orig &lt;&gt; flight.dest\n  )\n  CYCLE orig, dest SET is_cycle TO 'Y' DEFAULT 'N' \nSELECT  distinct orig, dest, is_cycle FROM reaches order by 1,2,3;\n</code></pre> <pre>\nResults:\n---------\nChicago Dallas     N\nChicago Denver      N\nChicago New York    N\nDallas Chicago     N\nDallas Chicago     Y\nDallas Denver     N\nDallas New York    N\nDenver Chicago     N\n...\n</pre> <pre><code>-- SQL query with non-linear recursion      ---&gt; Error message below\n-----------------------------------\nWITH  reaches(orig, dest) AS \n (\n  SELECT orig, dest FROM flight\n   UNION ALL\n  SELECT r1.orig, r2.dest FROM reaches r1, reaches r2\n  WHERE r1.dest = r2.orig AND r1.orig &lt;&gt; r2.dest\n  )\n  CYCLE orig,dest SET is_cycle TO 'Y' DEFAULT 'N' \nSELECT  distinct orig, dest, is_cycle FROM reaches order by 1,2,3;\n</code></pre> <pre>\nError message:\n--------------\n32490. 00000 -  \"recursive query name referenced more than once in recursive branch of recursive WITH clause element\"\n*Cause:    The recursive component of the UNION ALL in a recursive WITH clause\n           element referenced the recursive query name more than once.  Only\n           one reference to the recursive query name is allowed in the\n           recursive branch of a recursive WITH clause element.\n</pre> <pre><code>-- SQL query which lists the edges on the route\n--------------------------------------------\nWITH  reaches(orig, dest, edges) AS \n (\n  SELECT orig, dest, orig||'.'||dest FROM flight\n   UNION ALL\n  SELECT reaches.orig, flight.dest, reaches.edges||'.'||flight.dest FROM reaches, flight\n  WHERE reaches.dest = flight.orig  AND reaches.orig &lt;&gt; flight.dest\n  )\n  CYCLE orig,dest SET is_cycle TO 'Y' DEFAULT 'N' \nSELECT  distinct orig, dest, edges, is_cycle FROM reaches order by 1,2,3;\n</code></pre> <pre>\nResults:\n---------\nChicago Dallas     Chicago.Denver.Dallas           N\nChicago Denver     Chicago.Denver                  N\nChicago New York    Chicago.Denver.Dallas.New York  N\nChicago New York    Chicago.New York                N\nDallas Chicago     Dallas.Chicago                  N\nDallas Chicago     Dallas.Chicago.Denver.Chicago   Y\n...\n</pre>"},{"location":"archive/P11/#another-recursion-in-sql-start-with-connect-by","title":"Another recursion in SQL  (START WITH, CONNECT BY)","text":"<pre><code>SELECT ... FROM ... WHERE ...\nSTART WITH condition\nCONNECT BY condition\n</code></pre> <p>This is a special SQL query type by which we can query tree structures (graphs).</p> <p>We identify the root of the tree with START WITH condition.</p> <p>We identify the parent-child relationship with CONNECT BY condition.</p> <p>In CONNECT BY we have to use the PRIOR keyword to distinguish the column of a parent and a child node (row).</p> <ul> <li>START WITH -&gt; finds root node (or root nodes)</li> <li>CONNECT BY -&gt; relationship between parent and child rows (we should use PRIOR for parent rows)</li> </ul>"},{"location":"archive/P11/#steps-of-evaluation-in-recursive-queries","title":"Steps of evaluation in recursive queries","text":"<ol> <li>START WITH selects root nodes (rows)</li> <li>CONNECT BY finds children of roots</li> <li>Finds ancestors with a depth first strategy</li> <li>WHERE filters rows. If condition is TRUE, record remains in result set.</li> <li>Returns rows in preorder traversal.</li> </ol> <p>If a SELECT uses CONNECT BY, take care with JOINS.</p> <p>We can use several conditions after CONNECT BY. eg.</p> <p>CONNECT BY PRIOR empno = mgr AND sal &gt; comm</p> <p>empno -&gt; parent node or record (see PRIOR), other columns -&gt; child node (record)</p>"},{"location":"archive/P11/#prior-is-a-unary-operator","title":"PRIOR is a unary operator","text":"<p>We must use PRIOR in CONNECT BY clause at least once, otherwise we cannot express the parent-child relationship.</p>"},{"location":"archive/P11/#level-pszeudo-column","title":"LEVEL pszeudo column","text":"<p>It returns 1 for root nodes, 2 for their children, etc.</p> <pre><code>-- Example:\n--------\nSELECT   LPAD(' ', 2*(LEVEL-1)) || ename, empno, mgr, job, LEVEL\nFROM nikovits.emp\nSTART WITH   job='PRESIDENT'\nCONNECT BY  PRIOR empno = mgr;\n</code></pre> <pre>\nResults:\n---------\nKING 7839 PRESIDENT 1\n  JONES 7566 7839 MANAGER 2\n    SCOTT 7788 7566 ANALYST 3\n      ADAMS 7876 7788 CLERK 4\n    FORD 7902 7566 ANALYST 3\n      SMITH 7369 7902 CLERK 4\n  BLAKE 7698 7839 MANAGER 2\n</pre>"},{"location":"archive/P11/#ordering-siblings","title":"Ordering siblings","text":"<p>ORDER BY  -&gt; SIBLINGS [NULLS FIRST | NULLS LAST] </p> <pre><code>-- Example:\n--------\nSELECT   LPAD(' ', 2*(LEVEL-1)) || ename, empno, mgr, job, LEVEL\nFROM nikovits.emp\nSTART WITH   job='PRESIDENT'\nCONNECT BY  PRIOR empno = mgr\nORDER SIBLINGS BY ename;  --  [NULLS FIRST | LAST]\n</code></pre> <pre>\nResults:\n---------\nKING 7839 PRESIDENT 1\n  BLAKE 7698 7839 MANAGER 2\n    ALLEN 7499 7698 SALESMAN 3\n    JAMES 7900 7698 CLERK 3\n    MARTIN 7654 7698 SALESMAN 3\n    TURNER 7844 7698 SALESMAN 3\n    WARD 7521 7698 SALESMAN 3\n  CLARK 7782 7839 MANAGER 2\n    MILLER 7934 7782 CLERK 3\n</pre> <p>We can use aggregation and grouping in these queries.</p> <pre><code>-- Example:\n--------\n-- Give the sum money of the grandchildren of KAIN.\n\nSELECT   SUM(money) -- LPAD(' ', 2*(LEVEL-1)) || name, parent, money\nFROM nikovits.parentof\nWHERE LEVEL = 3\nSTART WITH  name='KAIN'\nCONNECT BY  PRIOR name = parent;\n</code></pre> <pre>\nResults:\n---------\n683000\n</pre> <pre><code>-- A new table: ParentOf(name, parent, money, city)\n------------------------------------------------\nCREATE TABLE ParentOf(name, parent, money, city)\nAS SELECT nev, decode(apja, 'NINCS', 'NO', apja), vagyon, varos FROM nikovits.vagyonok;\n-- grant select on parentof to public;\n\n-- Compare the following queries and notice the role of PRIOR operator.\n\n-- ABEL's all descendants\nSELECT  LPAD(' ', 2*(LEVEL-1)) || name, parent, money\nFROM nikovits.parentof\nWHERE name like '%%'     -- we could omit WHERE clause\nSTART WITH  name='ABEL'\nCONNECT BY  PRIOR name = parent;\n</code></pre> <pre>\nResults:\n---------\nABEL ADAM 280000\n  JANOS ABEL 190000\n    PAL JANOS 133000\n    PETER JANOS 143000\n      MARCSA PETER 177000\n    ROBERT JANOS 131000\n  JOZSEF ABEL 150000\n    BELA JOZSEF 157000\n      GIZI BELA 100000\n    BOTOND JOZSEF 190000\n</pre> <pre><code>-- ABEL's descendants whose all ancestors have a letter 'A' in his name\nSELECT  LPAD(' ', 2*(LEVEL-1)) || name, parent, money\nFROM nikovits.parentof\nWHERE name like '%%'\nSTART WITH  name='ABEL'\nCONNECT BY  PRIOR name = parent and prior name like '%A%';\n</code></pre> <pre>\nResults:\n---------\nABEL ADAM 280000\n  JANOS ABEL 190000\n    PAL JANOS 133000\n    PETER JANOS 143000\n    ROBERT JANOS 131000\n  JOZSEF ABEL 150000\n</pre> <pre><code>-- ABEL's descendants who and whose all ancestors have a letter 'A' in his name\n-- No PRIOR in second condition of CONNECT BY\nSELECT  LPAD(' ', 2*(LEVEL-1)) || name, parent, money\nFROM nikovits.parentof\nWHERE name like '%%'\nSTART WITH  name='ABEL'\nCONNECT BY  PRIOR name = parent and name like '%A%';\n</code></pre> <pre>\nResults:\n---------\nABEL ADAM 280000\n  JANOS ABEL 190000\n    PAL JANOS 133000\n</pre>"},{"location":"archive/P11/#connect_by_root-operator","title":"CONNECT_BY_ROOT operator","text":"<p>At any level we can refer to a column of the root node with this operator.</p> <pre><code>-- Example:\n--------\n-- Give the names whose city is the same as ADAM's city.\n\nSELECT  LPAD(' ', 2*(LEVEL-1)) || name, parent, city, CONNECT_BY_ROOT city\nFROM nikovits.parentof\nWHERE city = CONNECT_BY_ROOT city\nSTART WITH  name='ADAM'\nCONNECT BY  PRIOR name = parent;\n</code></pre> <pre>\nResults:\n---------\nADAM NO Budapest Budapest\n  ABEL ADAM Budapest Budapest\n      PETER JANOS Budapest Budapest\n        MARCSA PETER Budapest Budapest\n    SAMU BARNA Budapest Budapest\n    BALAZS KAIN Budapest Budapest\n</pre>"},{"location":"archive/P11/#sys_connect_by_path-function-sys_connect_by_pathcolumn-char","title":"SYS_CONNECT_BY_PATH function: SYS_CONNECT_BY_PATH(column, char)","text":"<p>SYS_CONNECT_BY_PATH concatenates the given column of the nodes from root to actual node.</p> <p>Second parameter is the delimeter character (or string).</p> <pre><code>-- Example:\n--------\nSELECT  name, SYS_CONNECT_BY_PATH(name,'.'), SYS_CONNECT_BY_PATH(city,'.')\nFROM nikovits.parentof\nSTART WITH  name='ADAM'\nCONNECT BY  PRIOR name = parent;\n</code></pre> <pre>\nResults:\n---------\nADAM .ADAM .Budapest\nABEL .ADAM.ABEL .Budapest.Budapest\nJANOS .ADAM.ABEL.JANOS .Budapest.Budapest.Eger\nPAL .ADAM.ABEL.JANOS.PAL .Budapest.Budapest.Eger.Szeged\nPETER .ADAM.ABEL.JANOS.PETER .Budapest.Budapest.Eger.Budapest\nMARCSA .ADAM.ABEL.JANOS.PETER.MARCSA .Budapest.Budapest.Eger.Budapest.Budapest\nROBERT .ADAM.ABEL.JANOS.ROBERT .Budapest.Budapest.Eger.Eger\nJOZSEF .ADAM.ABEL.JOZSEF .Budapest.Budapest.Szeged\n...\n</pre> <p>If the graph has a cycle we have to use NOCYCLE keyword.</p> <pre><code>-- Our earlier example about flights (The SQL statements below show how I created your table.)\n---------------------------------\nCREATE TABLE Flight(airline, orig, dest, cost)\nAS SELECT legitarsasag, honnan, hova, koltseg from nikovits.jaratok;\nGRANT select on flight to public;\n\n-- or CREATE an empty table then insert rows:\nCREATE TABLE Flight(airline VARCHAR2(10), orig VARCHAR2(15), dest VARCHAR2(15), cost NUMBER);\n\nINSERT INTO flight VALUES('Lufthansa', 'San Francisco', 'Denver', 1000);\nINSERT INTO flight VALUES('Lufthansa', 'San Francisco', 'Dallas', 10000);\nINSERT INTO flight VALUES('Lufthansa', 'Denver', 'Dallas', 500);\nINSERT INTO flight VALUES('Lufthansa', 'Denver', 'Chicago', 2000);\nINSERT INTO flight VALUES('Lufthansa', 'Dallas', 'Chicago', 600);\nINSERT INTO flight VALUES('Lufthansa', 'Dallas', 'New York', 2000);\nINSERT INTO flight VALUES('Lufthansa', 'Chicago', 'New York', 3000);\nINSERT INTO flight VALUES('Lufthansa', 'Chicago', 'Denver', 2000);\n\n-- There is a cycle in the graph of Flight table. \n-- If we delete the last row, there will be no cycle in the graph.\n\ndelete from flight where orig='Chicago' and dest='Denver';\n</code></pre> <pre><code>-- Example:\n--------\n-- Which cities can be reached from San Francisco?\n\nSELECT LPAD(' ', 4*level) ||orig, dest, level-1 turnovers\nFROM flight\nSTART WITH orig = 'San Francisco'\nCONNECT BY PRIOR dest = orig;\n</code></pre> <pre>\nResults:\n---------\nSan Francisco Dallas 0\n    Dallas Chicago 1\n        Chicago New York 2\n    Dallas New York 1\nSan Francisco Denver 0\n    Denver Chicago 1\n        Chicago New York 2\n    Denver Dallas 1\n        Dallas Chicago 2\n            Chicago New York 3\n        Dallas New York 2\n</pre> <pre><code>-- The previous SELECT doesn't work if there is a cycle in the graph.\n-- Use the following instead (-&gt; NOCYCLE):\n\nSELECT LPAD(' ', 4*level) ||orig, dest, level-1 turnovers\nFROM flight\nSTART WITH orig = 'San Francisco'\nCONNECT BY NOCYCLE PRIOR dest = orig;\n</code></pre> <pre>\nResults:\n--------- \nSan Francisco Dallas 0\n    Dallas Chicago 1\n        Chicago New York 2\n    Dallas New York 1\nSan Francisco Denver 0\n    Denver Chicago 1\n        Chicago New York 2\n    Denver Dallas 1\n        Dallas Chicago 2\n            Chicago New York 3\n        Dallas New York 2\n</pre>"},{"location":"archive/P11/#other-pszeudo-columns","title":"Other pszeudo columns","text":"<ul> <li>CONNECT_BY_ISCYCLE: returns 1 if actual row has a child that is an ancestor of it too. (So, it would mean a cycle.)</li> <li>CONNECT_BY_ISLEAF:  returns 1 if actual row has no child. (or has only child that was an ancestor)</li> </ul> <pre><code>-- Example:\n--------\n-- List the routes from San Francisco.\n\nSELECT CONNECT_BY_ROOT orig AS first, dest AS final_dest, LEVEL, \n       SYS_CONNECT_BY_PATH(orig, '-&gt;')||'-&gt;'||dest \"route\",        -- we concatenate the final dest at the end\n       CONNECT_BY_ISCYCLE, CONNECT_BY_ISLEAF\nFROM flight                                                       \nSTART WITH orig='San Francisco'\nCONNECT BY NOCYCLE PRIOR dest = orig\nORDER BY LEVEL;\n</code></pre> <pre>\nResults:\n---------\nSan Francisco Dallas 1 -&gt;San Francisco-&gt;Dallas 0 0\nSan Francisco Denver 1 -&gt;San Francisco-&gt;Denver 0 0\nSan Francisco New York 2 -&gt;San Francisco-&gt;Dallas-&gt;New York 0 1\nSan Francisco Chicago 2 -&gt;San Francisco-&gt;Dallas-&gt;Chicago 0 0\nSan Francisco Chicago 2 -&gt;San Francisco-&gt;Denver-&gt;Chicago 0 0\nSan Francisco Dallas 2 -&gt;San Francisco-&gt;Denver-&gt;Dallas 0 0\nSan Francisco New York 3 -&gt;San Francisco-&gt;Denver-&gt;Chicago-&gt;New York 0 1\n</pre> <p>Let's see our earlier query based on a Datalog query</p> <p>Reaches(X,Y)  &lt;--  Flight(X,Y)</p> <p>Reaches(X,Y)  &lt;--  Flight(X,Z) AND Reaches(Z,Y) AND X &lt;&gt; Y</p> <pre><code>-- SQL query\n---------\n\nWITH  reaches(orig, dest) AS \n (\n  SELECT orig, dest FROM flight\n   UNION ALL\n  SELECT flight.orig, reaches.dest FROM flight, reaches\n  WHERE flight.dest = reaches.orig AND flight.orig &lt;&gt; reaches.dest\n  )\n  CYCLE orig SET is_cycle TO 'Y' DEFAULT 'N' \nSELECT  distinct orig, dest FROM reaches order by orig, dest;\n</code></pre> <pre>\nResults:\n---------\nChicago New York\nDallas Chicago\nDallas New York\nDenver Chicago\nDenver Dallas\nDenver New York\nSan Francisco Chicago\nSan Francisco Dallas\nSan Francisco Denver\nSan Francisco New York\n</pre> <pre><code>-- Create the Reaches table from Flight table with a CONNECT BY query\n------------------------------------------------------------------\n\nSELECT distinct CONNECT_BY_ROOT orig AS orig, dest AS dest\nFROM flight\nWHERE CONNECT_BY_ROOT orig &lt;&gt; dest\nSTART WITH 1=1                         -- we start recursion from each node\nCONNECT BY NOCYCLE PRIOR dest = orig\nORDER BY orig, dest;\n\n-- With recursive statement 'WITH' we can compute (produce) new values, but with\n-- 'CONNECT BY' we can get only existing values from our table.\n-- The query below couldn't be produced by a 'CONNECT BY' recursive query, e.g.\n</code></pre> <pre>\nResults:\n---------\nChicago New York\nDallas Chicago\nDallas New York\nDenver Chicago\nDenver Dallas\nDenver New York\nSan Francisco Chicago\nSan Francisco Dallas\nSan Francisco Denver\nSan Francisco New York\n</pre>"},{"location":"archive/P11/#produce-a-relation-factorialn-val-where-val-n","title":"Produce a relation Factorial(n, val) where val = n!","text":"<p>Factor(X, Y) &lt;-- X=0 AND Y=1</p> <p>Factor(X, Y) &lt;-- Factor(Z, V) AND X=Z+1 AND Y=X*V AND X &lt; 40    </p> <p>(--&gt; X &lt; 40: not to produce an infinite relation, see \"safety\" of a DATALOG rule)</p> <pre><code>WITH  factorial(n, val) AS \n (\n  SELECT 0, 1 FROM dual\n   UNION ALL\n  SELECT n+1, (n+1)*val FROM factorial\n  WHERE n &lt; 40                          \n  )\n  CYCLE n SET is_cycle TO 'Y' DEFAULT 'N'   -- we can omit this line, there is no cycle\nSELECT  n, val FROM factorial order by 1;\n</code></pre> <pre>\nResults:\n---------\n0 1\n1 1\n2 2\n3 6\n4 24\n5 120\n6 720\n7 5040\n8 40320\n9 362880\n10 3628800\n11 39916800\n...\n</pre>"},{"location":"archive/P2/","title":"Set operators","text":""},{"location":"archive/P2/#tables-used","title":"Tables Used","text":"<ul> <li>EMPLOYEES: Provides details regarding all current employees</li> <li>JOB_HISTORY: Records the details of the start date and end date of the former job, and the job identification number and department when an employee switches jobs</li> </ul> <p>When an employee switches jobs, the details of the start date and end date of the former job, the job identification number, and the department are recorded in the JOB_HISTORY table.</p>"},{"location":"archive/P2/#union-operator","title":"UNION Operator","text":"<p>Display the current and previous job details of all employees. Display each employee only once.</p> <pre><code>SELECT employee_id, job_id\nFROM nikovits.employees\nUNION\nSELECT employee_id, job_id\nFROM nikovits.job_history;\n</code></pre> EMPLOYEE_ID JOB_ID 100 AD_PRES 101 AC_ACCOUNT 101 AC_MGR 101 AD_VP 102 AD_VP 102 IT_PROG 103 IT_PROG 104 IT_PROG 105 IT_PROG 106 IT_PROG 107 IT_PROG 108 FI_MGR 109 FI_ACCOUNT 110 FI_ACCOUNT 111 FI_ACCOUNT 112 FI_ACCOUNT 113 FI_ACCOUNT 114 PU_MAN"},{"location":"archive/P2/#union-all-operator","title":"UNION ALL Operator","text":"<p>Display the current and previous departments of all employees.</p> <pre><code>SELECT employee_id, job_id, department_id\nFROM nikovits.employees\nUNION ALL\nSELECT employee_id, job_id, department_id\nFROM nikovits.job_history\nORDER BY employee_id;\n</code></pre> EMPLOYEE_ID JOB_ID DEPARTMENT_ID 100 AD_PRES 90 101 AD_VP 90 101 AC_ACCOUNT 110 101 AC_MGR 110 102 IT_PROG 60 102 AD_VP 90 103 IT_PROG 60 104 IT_PROG 60 105 IT_PROG 60 106 IT_PROG 60 107 IT_PROG 60 108 FI_MGR 100"},{"location":"archive/P2/#intersect-operator","title":"INTERSECT Operator","text":"<p>Display the employee IDs and job IDs of those employees who currently have a job title that is the same as their job title when they were initially hired (that is, they changed jobs but have now gone back to doing their original job).</p> <pre><code>SELECT employee_id, job_id\nFROM nikovits.employees\nINTERSECT\nSELECT employee_id, job_id\nFROM nikovits.job_history;\n</code></pre> EMPLOYEE_ID JOB_ID 176 SA_REP 200 AD_ASST"},{"location":"archive/P2/#minus-operator","title":"MINUS Operator","text":"<p>Display the employee IDs of those employees who have not changed their jobs even once.</p> <pre><code>SELECT employee_id,job_id\nFROM nikovits.employees\nMINUS\nSELECT employee_id,job_id\nFROM nikovits.job_history;\n</code></pre> EMPLOYEE_ID JOB_ID 100 AD_PRES 101 AD_VP 102 AD_VP 103 IT_PROG 104 IT_PROG 105 IT_PROG 106 IT_PROG 107 IT_PROG 108 FI_MGR 109 FI_ACCOUNT 110 FI_ACCOUNT 111 FI_ACCOUNT 112 FI_ACCOUNT"},{"location":"archive/P2/#set-operator-guidelines","title":"Set Operator Guidelines","text":"<p>The expressions in the SELECT lists must match in number and data type. - Parentheses can be used to alter the sequence of execution. - The ORDER BY clause:     - Can appear only at the very end of the statement     - Will accept the column name, aliases from the first SELECT statement, or the positional notation.</p>"},{"location":"archive/P2/#key-behaviors-of-set-operators-in-oracle-server","title":"Key Behaviors of Set Operators in Oracle Server","text":"<p>Set operators (such as <code>UNION</code>, <code>UNION ALL</code>, <code>INTERSECT</code>, <code>MINUS</code>) combine the results of two or more queries.</p>"},{"location":"archive/P2/#important-rules","title":"Important Rules","text":"<p>Duplicate rows are automatically eliminated, except in <code>UNION ALL</code>.</p> <ul> <li><code>UNION</code>, <code>INTERSECT</code>, and <code>MINUS</code> perform distinct processing (remove duplicates).</li> <li><code>UNION ALL</code> retains all duplicates.</li> </ul> <p>Column names from the first query appear in the result.</p> <ul> <li>The final result set uses the column names (and aliases) from the first SELECT statement.</li> <li>Subsequent queries must have compatible columns, but their names/aliases are ignored in the output.</li> </ul> <p>The output is sorted in ascending order by default, except in <code>UNION ALL</code>.</p> <ul> <li><code>UNION</code>, <code>INTERSECT</code>, and <code>MINUS</code> implicitly sort the entire result set in ascending order by all columns (to eliminate duplicates).</li> <li><code>UNION ALL</code> does not sort the results\u2014it returns rows in the order they are retrieved.</li> </ul>"},{"location":"archive/P2/#common-set-operators","title":"Common Set Operators","text":"Operator Description Removes Duplicates? Sorts Result? UNION ALL Returns all rows from both queries No No UNION Returns unique rows from both queries Yes Yes INTERSECT Returns rows common to both queries Yes Yes MINUS Returns rows from first query not in second Yes Yes"},{"location":"archive/P2/#matching-the-select-statements","title":"Matching the SELECT Statements","text":"<p>Using the UNION operator, display the department ID, location, and hire date for all employees.</p> <pre><code>SELECT department_id, TO_NUMBER(null)\nlocation, hire_date\nFROM nikovits.employees\nUNION\nSELECT department_id, location_id, TO_DATE(null)\nFROM nikovits.departments;\n</code></pre> DEPARTMENT_ID LOCATION HIRE_DATE 10 1700 NULL 10 NULL 17/09/87 20 1800 NULL 20 NULL 17/02/96 20 NULL 17/08/97 30 1700 NULL 30 NULL 07/12/94 30 NULL 18/05/95 30 NULL 24/07/97 30 NULL 24/12/97 30 NULL 15/11/98 30 NULL 10/08/99 40 2400 NULL <p>Using the UNION operator, display the employee ID, job ID, and salary of all employees.</p> <pre><code>SELECT employee_id, job_id,salary\nFROM nikovits.employees\nUNION\nSELECT employee_id, job_id,0\nFROM nikovits.job_history;\n</code></pre> EMPLOYEE_ID JOB_ID SALARY 100 AD_PRES 24000 101 AC_ACCOUNT 0 101 AC_MGR 0 101 AD_VP 17000 102 AD_VP 17000 102 IT_PROG 0 103 IT_PROG 9000 104 IT_PROG 6000 105 IT_PROG 4800 106 IT_PROG 4800 107 IT_PROG 4200 108 FI_MGR 12000 109 FI_ACCOUNT 9000"},{"location":"archive/P2/#controlling-the-order-of-rows","title":"Controlling the Order of Rows","text":"<p>Produce an English sentence using two UNION operators.</p> <p>(Run as a script, not as a single statement.)</p> <pre><code>COLUMN a_dummy NOPRINT\nSELECT 'sing' AS \"My dream\", 3 a_dummy\nFROM dual\nUNION\nSELECT 'I''d like to teach', 1 a_dummy\nFROM dual\nUNION\nSELECT 'the world to', 2 a_dummy\nFROM dual\nORDER BY a_dummy;\n</code></pre> My dream A_DUMMY Id like to teach 1 the world to 2 sing 3"},{"location":"archive/P2/#data-types","title":"Data types","text":""},{"location":"archive/P2/#numbers","title":"Numbers","text":"<ul> <li>number(x,y) -- x -&gt; precision (number of stored digits), y -&gt; scale (number of decimals, it can be negative)</li> <li>number(x) -- x -&gt; precision (number of stored digits), scale defaults to 0.</li> <li>int = integer = number(38)</li> <li>numeric(x,y) = number(x,y) (synonyms)</li> <li>positive and natural -- only in PL/SQL (procedural extension of SQL)</li> </ul>"},{"location":"archive/P2/#strings","title":"STRINGS","text":"<ul> <li>varchar2(17) --Variable length string. Maximal length in paranthesis.</li> <li>varchar(n) = varchar2(n) (synonyms)<ul> <li>Insert: if length of string overrides max. length-&gt; error</li> </ul> </li> <li>char(15) --Fixed length string. Stored in fixed length, rigth padded with spaces.<ul> <li>Insert: if length of string over rides max. length-&gt; error</li> <li>Insert: if length of string is fewer-&gt; rigth padded with spaces.</li> </ul> </li> <li>Data type of Character literals e.g. 'ABC' (default) --&gt; char(3).</li> <li>Take care in case of char(n) data type comparison!!! e.g. 'str' = 'str' (!!!)<ul> <li>e.g. SELECT * FROM emp WHERE 'str' = 'str'; -&gt; TRUE for all rows</li> </ul> </li> <li>In case of varchar comparison, it is different (normal).<ul> <li>e.g. SELECT * FROM emp WHERE CAST('str' AS VARCHAR(4)) = 'str'; -&gt; FALSE for all rows</li> </ul> </li> </ul>"},{"location":"archive/P2/#date-and-time","title":"DATE and TIME","text":"<ul> <li>DATE data type -- stores date and time with seconds precision</li> <li>ANSI Date literal: DATE '1998-12-25\u2019<ul> <li>The ANSI date literal contains no time portion, and must be specified in the format 'YYYY-MM-DD\u2019.</li> <li>Alternatively, you can specify an Oracle date value with TO_DATE built-in function.</li> </ul> </li> <li>We can change the date format and language:<ul> <li>ALTER SESSION SET NLS_DATE_FORMAT='YYYY-MM-DD (fmDay) HH24:MI:SS\u2019;</li> <li>ALTER SESSION SET NLS_DATE_LANGUAGE='hungarian'; -- can be english, american, french, german</li> <li>SELECT sysdate FROM dual;SELECT to_char(sysdate, 'day') FROM dual;</li> </ul> </li> </ul>"},{"location":"archive/P2/#datearithmethic","title":"Datearithmethic","text":"<ul> <li>d+1 -- d plus one day</li> <li>d-2 -- d minus 2 days</li> <li>sysdate+7 -- now plus 7 days</li> <li>d+1/24 -- d plus 1 hour</li> <li>d2-d1 -- time elapsed between d1 and d2 in days</li> <li>(d2-d1)2460*60 -- time elapsed between d1 and d2 in seconds</li> <li>months_between(d2,d1)</li> <li>We can get positive and negative result too.<ul> <li>d2 &gt; d1 =&gt; (+)</li> <li>d2 &lt; d1 =&gt; (-)</li> </ul> </li> </ul>"},{"location":"archive/P2/#timestamp-datatype","title":"TIMESTAMP datatype","text":"<ul> <li>Stores fractional seconds as well</li> <li>SELECT SYSTIMESTAMP FROM DUAL; --with Time Zone see NLS_TIMESTAMP_TZ_FORMAT setting<ul> <li>--20-APR-08 11.53.17,384707000 +02:00</li> </ul> </li> <li>SELECT CURRENT_TIMESTAMP FROM DUAL;<ul> <li>--20-APR-08 11.53.55,229284000 EUROPE/PRAGUE</li> </ul> </li> <li>SELECT LOCALTIMESTAMP FROM DUAL; --without Time Zone<ul> <li>--20-APR-08 11.54.13,646841000</li> </ul> </li> <li>SELECT TO_CHAR(SYSTIMESTAMP,'YYYY.MM.DD.HH24:MI:SS.FF TZH:TZM') FROM dual; --using explicit Format Mask<ul> <li>--2020.04.08.11:57:50.274611 +02:00</li> </ul> </li> <li>SELECT TO_CHAR(SYSTIMESTAMP,'SSSSS.FF') FROM dual; --seconds past midnight</li> </ul>"},{"location":"archive/P2/#conversion","title":"CONVERSION","text":"<ul> <li>to_date('2030-OCT-28') -- conversion based on NLS_DATE_FORMAT</li> <li>to_date('2030-12','YYYY-MM') -- giving format elements =&gt; 2030-12-01 0:00.00</li> <li>The elements we don't give in will be default. Default date: actual year, actual month, first day, midnight</li> <li>to_date(2462803,'J') -- Julian date 2462803rd day midnight</li> <li>to_char(d) -- output according to NLS_DATE_FORMAT</li> <li>to_char(d, 'HH24:MI:SS') -- output according to format elements given</li> <li>to_char(127.14) -- number -&gt; string</li> <li>to_number('135.00167') -- string -&gt; number</li> <li>to_number('abc') -- ORA-01722: invalid number</li> </ul>"},{"location":"archive/P2/#oracle-sql-has-no-boolean-type","title":"Oracle SQL has no boolean type","text":""},{"location":"archive/P2/#plsql-has-literals-true-false-null","title":"(PL/SQL has. Literals: TRUE, FALSE, NULL)","text":"<ul> <li>NULL value can be in any datatype column.</li> <li>Two nulls are never equal, however it is not true that they are not equal (x &lt;&gt; y).</li> <li>We can test whether x is null:<ul> <li>x IS NULL (wrong -&gt; x = NULL)</li> <li>x IS NOT NULL</li> </ul> </li> <li>e.g. SELECT * FROM emp WHERE comm IS NOT NULL;</li> </ul>"},{"location":"archive/P3/","title":"SQL Functions","text":""},{"location":"archive/P3/#types-of-sql-functions","title":"Types of SQL Functions","text":""},{"location":"archive/P3/#single-row-functions","title":"Single-Row Functions","text":"<ul> <li>Manipulate data items</li> <li>Accept arguments and return one value</li> <li>Act on each row that is returned</li> <li>Return one result per row</li> <li>May modify the data type</li> <li>Can be nested</li> <li>Accept arguments that can be a column or an expression</li> </ul>"},{"location":"archive/P3/#character-functions","title":"Character Functions","text":""},{"location":"archive/P3/#case-manipulation-functions-in-sql","title":"Case-Manipulation Functions in SQL","text":"<p>These functions convert the case for character strings.</p>"},{"location":"archive/P3/#common-case-manipulation-functions","title":"Common Case-Manipulation Functions","text":"Function Result Description LOWER('SQL Course') sql course Converts all characters to lowercase UPPER('SQL Course') SQL COURSE Converts all characters to uppercase INITCAP('SQL Course') Sql Course Converts the first letter of each word to uppercase and the rest to lowercase"},{"location":"archive/P3/#using-case-manipulation-functions","title":"Using Case-Manipulation Functions","text":"<p>Display the employee number, name, and department number for employee Higgins:</p> <pre><code>SELECT employee_id, last_name, department_id\nFROM nikovits.employees\nWHERE last_name = 'higgins';\n</code></pre> EMPLOYEE_ID LAST_NAME DEPARTMENT_ID <pre><code>SELECT employee_id, last_name, department_id\nFROM nikovits.employees\nWHERE LOWER(last_name) = 'higgins';\n</code></pre> EMPLOYEE_ID LAST_NAME DEPARTMENT_ID 205 Higgins 110"},{"location":"archive/P3/#character-manipulation-functions-in-sql","title":"Character-Manipulation Functions in SQL","text":"<p>These functions manipulate character strings.</p>"},{"location":"archive/P3/#common-character-manipulation-functions","title":"Common Character-Manipulation Functions","text":"Function Result Description CONCAT('Hello', 'World') HelloWorld Concatenates two strings (alternative: use <code>||</code> operator) SUBSTR('HelloWorld', 1, 5) Hello Returns a substring starting at position 1 with length 5 LENGTH('HelloWorld') 10 Returns the length of the string INSTR('HelloWorld', 'W') 6 Returns the position of the first occurrence of 'W' (1-based index) LPAD(salary, 10, '*') ****24000 Left-pads the value to a total length of 10 using '*' (example: salary=24000) RPAD(salary, 10, '*') 24000* Right-pads the value to a total length of 10 using '*' REPLACE('JACK and JUE', 'J', 'BL') BLACK and BLUE Replaces all occurrences of 'J' with 'BL' TRIM('H' FROM 'HelloWorld') elloWorld Removes all leading occurrences of 'H' from the string"},{"location":"archive/P3/#using-the-character-manipulation-functions","title":"Using the Character-Manipulation Functions","text":""},{"location":"archive/P3/#number-functions-in-sql","title":"Number Functions in SQL","text":"<p>Number functions perform operations on numeric values.</p>"},{"location":"archive/P3/#key-number-functions-oracle-sql","title":"Key Number Functions (Oracle SQL)","text":"<ul> <li>ROUND: Rounds value to specified decimal places</li> <li>TRUNC: Truncates value to specified decimal places (no rounding)</li> <li>MOD: Returns remainder of division</li> </ul>"},{"location":"archive/P3/#examples","title":"Examples","text":"Function Result Description ROUND(45.926, 2) 45.93 Rounds to 2 decimal places (standard rounding: 0.006 \u2192 up) TRUNC(45.926, 2) 45.92 Truncates to 2 decimal places (cuts off excess without rounding) MOD(1600, 300) 100 Returns remainder of 1600 \u00f7 300 (1600 - 5\u00d7300 = 100)"},{"location":"archive/P3/#dual-table","title":"DUAL Table","text":"<p>DUAL is a dummy table that you can use to view results from functions and calculations.</p>"},{"location":"archive/P3/#using-the-round-function","title":"Using the ROUND Function","text":""},{"location":"archive/P3/#using-the-trunc-function","title":"Using the TRUNC Function","text":""},{"location":"archive/P3/#using-the-mod-function","title":"Using the MOD Function","text":"<p>For all nikovits.employees with job title of Sales Representative, calculate the remainder of the salary after it is divided by 5,000.</p> <pre><code>SELECT last_name, salary, MOD(salary, 5000)\nFROM nikovits.employees\nWHERE job_id = 'SA_REP';\n</code></pre> LAST_NAME SALARY MOD(SALARY,5000) Tucker 10000 0 Bernstein 9500 4500 Hall 9000 4000 Olsen 8000 3000 Cambrault 7500 2500 Tuvault 7000 2000 King 10000 0"},{"location":"archive/P3/#working-with-dates","title":"Working with Dates","text":"<ul> <li>The Oracle database stores dates in an internal numeric format: century, year, month, day, hours, minutes, and seconds.</li> <li>The default date display format is DD-MON-YY. (DD-MON-RR)<ul> <li>Enables you to store 21st-century dates in the 20th century by specifying only the last two digits of the year</li> <li>Enables you to store 20th-century dates in the 21st century in the same way</li> </ul> </li> </ul> <pre><code>SELECT last_name, hire_date\nFROM nikovits.employees\nWHERE hire_date &lt; '01-FEB-88';\n</code></pre> LAST_NAME HIRE_DATE King 17/06/87 Whalen 17/09/87"},{"location":"archive/P3/#sysdate-is-a-function-that-returns","title":"SYSDATE is a function that returns:","text":"<ul> <li>Date</li> <li>Time</li> </ul>"},{"location":"archive/P3/#arithmetic-with-dates","title":"Arithmetic with Dates","text":"<ul> <li>Add or subtract a number to or from a date for a resultant date value.</li> <li>Subtract two dates to find the number of days between those dates.</li> <li>Add hours to a date by dividing the number of hours by 24.</li> </ul> <pre><code>SELECT last_name, (SYSDATE-hire_date)/7 AS WEEKS\nFROM nikovits.employees\nWHERE department_id = 90;\n</code></pre> LAST_NAME WEEKS King 1995.593908730158730 Kochhar 1877.451051587301587 De Haan 1704.593908730158730"},{"location":"archive/P3/#date-functions","title":"Date Functions","text":"Function Description MONTHS_BETWEEN Number of months between two dates ADD_MONTHS Add calendar months to date NEXT_DAY Next day of the date specified LAST_DAY Last day of the month ROUND Round date TRUNC Truncate date"},{"location":"archive/P3/#using-date-functions","title":"Using Date Functions","text":"Function Result Explanation MONTHS_BETWEEN('01-SEP-95', '11-JAN-94') 19.6774194 Calculates the number of months between the two dates (later date first). Includes fractional months based on days. ADD_MONTHS('11-JAN-94', 6) '11-JUL-94' Adds 6 calendar months to the specified date. NEXT_DAY('01-SEP-95', 'FRIDAY') '08-SEP-95' Returns the date of the next Friday after 01-SEP-1995. LAST_DAY('01-FEB-95') '28-FEB-95' Returns the last day of the month for February 1995 (non-leap year). <p>Assume <code>SYSDATE = '25-JUL-2003'</code>.</p> Function Result Explanation ROUND(SYSDATE, 'MONTH') 01-AUG-2003 Rounds to the nearest month. Since July 25 is past the 15th, rounds up to August 1. ROUND(SYSDATE, 'YEAR') 01-JAN-2004 Rounds to the nearest year. July 25 is past July 1, so rounds up to next year. TRUNC(SYSDATE, 'MONTH') 01-JUL-2003 Truncates to the first day of the current month (always sets day to 1). TRUNC(SYSDATE, 'YEAR') 01-JAN-2003 Truncates to the first day of the current year (January 1)."},{"location":"archive/P3/#conversion-functions","title":"Conversion Functions","text":""},{"location":"archive/P3/#implicit-data-type-conversion","title":"Implicit Data Type Conversion","text":"<p>For assignments (e.g., in <code>INSERT</code>, <code>UPDATE</code>, or variable assignments), the Oracle server can automatically perform implicit data type conversions for certain compatible types.</p> From To Notes VARCHAR2 or CHAR NUMBER String must represent a valid number (e.g., '123.45' \u2192 123.45) VARCHAR2 or CHAR DATE String must be in the default date format or a recognizable format (depends on NLS_DATE_FORMAT) NUMBER VARCHAR2 Number is converted to its string representation DATE VARCHAR2 Date is converted to string using the current NLS_DATE_FORMAT <p>For expression evaluation (e.g., in <code>WHERE</code> clause conditions, <code>SELECT</code> list expressions, or function arguments), the Oracle Server can automatically perform implicit data type conversions for certain compatible types.</p> From To Notes VARCHAR2 or CHAR NUMBER String must represent a valid number; otherwise, runtime error (ORA-01722) VARCHAR2 or CHAR DATE String must match the session's NLS_DATE_FORMAT or be recognizable"},{"location":"archive/P3/#explicit-data-type-conversion","title":"Explicit Data Type Conversion","text":""},{"location":"archive/P3/#using-the-to_char-function-with-dates","title":"Using the TO_CHAR Function with Dates","text":""},{"location":"archive/P3/#to_chardate-format_model","title":"TO_CHAR(date, 'format_model')","text":"<p>The format model:</p> <ul> <li>Must be enclosed by single quotation marks</li> <li>Is case-sensitive</li> <li>Can include any valid date format element</li> <li>Has an fm element to remove padded blanks or suppress leading zeros</li> <li>Is separated from the date value by a comma TO_CHAR(date, 'format_model')</li> </ul>"},{"location":"archive/P3/#elements-of-the-date-format-model","title":"Elements of the Date Format Model","text":"Element Result Example (for December 24, 2025 - Wednesday) YYYY Full year in numbers 2025 YEAR Year spelled out (in English) TWENTY TWENTY-FIVE MM Two-digit value for month 12 MONTH Full name of the month DECEMBER MON Three-letter abbreviation of the month DEC DY Three-letter abbreviation of the day of the week WED DAY Full name of the day of the week WEDNESDAY DD Numeric day of the month 24"},{"location":"archive/P3/#time-elements","title":"Time Elements","text":"<p>Time elements format the time portion of the date.</p> Format Element Example Result Description HH24:MI:SS AM 15:45:32 PM 24-hour format with hours, minutes, seconds, and AM/PM indicator"},{"location":"archive/P3/#literal-text","title":"Literal Text","text":"<p>Add character strings by enclosing them in double quotation marks.</p> Format Example Result Notes DD \"of\" MONTH 12 of OCTOBER \"of\" is output literally"},{"location":"archive/P3/#number-suffixes","title":"Number Suffixes","text":"<p>Number suffixes spell out numbers (ordinal form).</p> Format Element Result Description ddspth fourteenth Spells the day with ordinal suffix (e.g., 1st, 2nd, 3rd, 14th)"},{"location":"archive/P3/#using-the-to_char-function-with-dates_1","title":"Using the TO_CHAR Function with Dates","text":"<pre><code>SELECT last_name,\n    TO_CHAR(hire_date, 'fmDD Month YYYY')\n    AS HIREDATE\nFROM nikovits.employees;\n</code></pre> LAST_NAME HIREDATE King 17 June 1987 Kochhar 21 September 1989 De Haan 13 January 1993 Hunold 3 January 1990 Ernst 21 May 1991 Austin 25 June 1997 Pataballa 5 February 1998 Lorentz 7 February 1999"},{"location":"archive/P3/#using-the-to_char-function-with-numbers","title":"Using the TO_CHAR Function with Numbers","text":"<pre><code>TO_CHAR(number, 'format_model')\n</code></pre> <p>These are some of the format elements that you can use with the TO_CHAR function to display a number value as a character:</p> Element Result/Description 9 Represents a digit (leading zeros suppressed) 0 Forces a zero to be displayed $ Places a floating dollar sign L Uses the floating local currency symbol . Prints a decimal point , Prints a comma as thousands indicator <pre><code>SELECT TO_CHAR(salary, '$99,999.00') SALARY\nFROM nikovits.employees\nWHERE last_name = 'Ernst';\n</code></pre> SALARY $6,000.00"},{"location":"archive/P3/#using-to_number-and-to_date-functions","title":"Using TO_NUMBER and TO_DATE Functions","text":"<p>Convert a character string to a number format using the TO_NUMBER function:</p> <pre><code>TO_NUMBER(char[, 'format_model'])\n</code></pre> <p>Convert a character string to a date format using the TO_DATE function:</p> <pre><code>TO_DATE(char[, 'format_model'])\n</code></pre> <ul> <li>These functions have an FX modifier.</li> <li>This modifier specifies the exact matching for the character argument and the format model of a TO_DATE function.</li> </ul>"},{"location":"archive/P3/#nesting-functions","title":"Nesting Functions","text":"<ul> <li>Single-row functions can be nested to any level.  </li> <li>Nested functions are evaluated from the deepest level to the least deep level (inside-out).</li> </ul> <pre><code>SELECT last_name,\n    UPPER(CONCAT(SUBSTR (LAST_NAME, 1, 8), '_US'))\nFROM nikovits.employees\nWHERE department_id = 60;\n</code></pre> LAST_NAME UPPER(CONCAT(SUBSTR(LAST_NAME,1,8),'_US')) Hunold HUNOLD_US Ernst ERNST_US Austin AUSTIN_US Pataballa PATABALL_US Lorentz LORENTZ_US"},{"location":"archive/P3/#general-functions","title":"General Functions","text":"<p>The following functions work with any data type and pertain to using nulls:</p> <pre><code>- NVL (expr1, expr2)\n- NVL2 (expr1, expr2, expr3)\n- NULLIF (expr1, expr2)\n- COALESCE (expr1, expr2, ..., exprn)\n</code></pre>"},{"location":"archive/P3/#nvl-function","title":"NVL Function","text":"<p>Converts a null value to an actual value:</p> <ul> <li>Data types that can be used are date, character, and number.</li> <li> <p>Data types must match:</p> </li> <li> <p>NVL(commission_pct, 0)</p> </li> <li>NVL(hire_date, '01-JAN-97')</li> <li>NVL(job_id, 'No Job Yet')</li> </ul>"},{"location":"archive/P3/#using-the-nvl-function","title":"Using the NVL Function","text":""},{"location":"archive/P3/#using-the-nvl2-function","title":"Using the NVL2 Function","text":""},{"location":"archive/P3/#using-the-nullif-function","title":"Using the NULLIF Function","text":""},{"location":"archive/P3/#using-the-coalesce-function","title":"Using the COALESCE Function","text":"<ul> <li>The advantage of the COALESCE function over the NVL function is that the COALESCE function can take multiple alternate values.</li> <li>If the first expression is not null, the COALESCE function returns that expression; otherwise, it does a COALESCE of the remaining expressions.</li> </ul> <pre><code>SELECT last_name,\n    COALESCE(manager_id,commission_pct, -1) comm\nFROM nikovits.employees\nORDER BY commission_pct;\n</code></pre> LAST_NAME COMM Lee 147 Johnson 149 Marvins 147 Banda 147 Kumar 148 Ande 147 Greene 147 Grant 149 Tuvault 145 Bates 148"},{"location":"archive/P3/#conditional-expressions","title":"Conditional Expressions","text":"<ul> <li>Provide the use of IF-THEN-ELSE logic within a SQL statement</li> <li>Use two methods:<ul> <li>CASE expression</li> <li>DECODE function</li> </ul> </li> </ul>"},{"location":"archive/P3/#case-expression","title":"CASE Expression","text":"<p>Facilitates conditional inquiries by doing the work of an IF-THEN-ELSE statement:</p> <pre><code>CASE expr WHEN comparison_expr1 THEN return_expr1\n     [WHEN comparison_expr2 THEN return_expr2\n      WHEN comparison_exprn THEN return_exprn\n      ELSE else_expr]\nEND\n</code></pre>"},{"location":"archive/P3/#if-then-else-statement","title":"IF THEN ELSE statement:","text":"<pre><code>SELECT last_name, job_id, salary,\n    CASE job_id WHEN 'IT_PROG' THEN 1.10*salary\n                WHEN 'ST_CLERK' THEN 1.15*salary\n                WHEN 'SA_REP' THEN 1.20*salary\n    ELSE salary END \"REVISED_SALARY\"\nFROM nikovits.employees;\n</code></pre> LAST_NAME JOB_ID SALARY REVISED_SALARY King AD_PRES 24000 24000 Kochhar AD_VP 17000 17000 De Haan AD_VP 17000 17000 Hunold IT_PROG 9000 9900 Ernst IT_PROG 6000 6600 Austin IT_PROG 4800 5280 Pataballa IT_PROG 4800 5280"},{"location":"archive/P3/#decode-function-in-oracle-sql","title":"DECODE Function in Oracle SQL","text":"<p>Facilitates conditional inquiries by doing the work of a CASE expression or an IF-THEN-ELSE statement:</p> <pre><code>DECODE(col|expression, search1, result1\n       [, search2, result2, ...]\n       [, default])\n</code></pre> <pre><code>SELECT last_name, job_id, salary,\n    DECODE(job_id, 'IT_PROG', 1.10*salary,\n            'ST_CLERK', 1.15*salary,\n            'SA_REP', 1.20*salary,\n            salary)\n    REVISED_SALARY\nFROM nikovits.employees;\n</code></pre> LAST_NAME JOB_ID SALARY REVISED_SALARY King AD_PRES 24000 24000 Kochhar AD_VP 17000 17000 De Haan AD_VP 17000 17000 Hunold IT_PROG 9000 9900 Ernst IT_PROG 6000 6600 Austin IT_PROG 4800 5280 Pataballa IT_PROG 4800 5280"},{"location":"archive/P3/#display-the-applicable-tax-rate-for-each-employee-in-department-80","title":"Display the applicable tax rate for each employee in department 80:","text":"<pre><code>SELECT last_name, salary,\n        DECODE (TRUNC(salary/2000, 0),\n                            0, 0.00,\n                            1, 0.09,\n                            2, 0.20,\n                            3, 0.30,\n                            4, 0.40,\n                            5, 0.42,\n                            6, 0.44,\n                            0.45) TAX_RATE\nFROM nikovits.employees\nWHERE department_id = 80;\n</code></pre> LAST_NAME SALARY TAX_RATE Russell 14000 .45 Partners 13500 .44 Errazuriz 12000 .44 Cambrault 11000 .42 Zlotkey 10500 .42 Tucker 10000 .42 Bernstein 9500 .4 Hall 9000 .4 Olsen 8000 .4"},{"location":"archive/P3/#what-are-group-functions","title":"What Are Group Functions?","text":"<p>Group functions operate on sets of rows to give one result per group.</p> <p></p>"},{"location":"archive/P3/#types-of-group-functions","title":"Types of Group Functions","text":"<ul> <li>AVG</li> <li>COUNT</li> <li>MAX</li> <li>MIN</li> <li>STDDEV</li> <li>SUM</li> <li>VARIANCE</li> </ul>"},{"location":"archive/P3/#group-functions-syntax","title":"Group Functions: Syntax","text":"<pre><code>SELECT     [column,] group_function(column), ...\nFROM       table\n[WHERE     condition]\n[GROUP BY  column]\n[ORDER BY  column];\n</code></pre>"},{"location":"archive/P3/#using-the-avg-and-sum-functions","title":"Using the AVG and SUM Functions","text":"<pre><code>SELECT AVG(salary), MAX(salary),\n        MIN(salary), SUM(salary)\n        FROM nikovits.employees\nWHERE job_id LIKE '%REP%';\n</code></pre> AVG(SALARY) MAX(SALARY) MIN(SALARY) SUM(SALARY) 8272.727272727272727 11500 6000 273000"},{"location":"archive/P3/#using-the-min-and-max-functions","title":"Using the MIN and MAX Functions","text":"<pre><code>SELECT MIN(hire_date), MAX(hire_date)\nFROM nikovits.employees;\n</code></pre> MIN(HIRE_DATE) MAX(HIRE_DATE) 17/06/87 21/04/00"},{"location":"archive/P3/#using-the-count-function","title":"Using the COUNT Function","text":""},{"location":"archive/P3/#count-returns-the-number-of-rows-in-a-table","title":"COUNT(*) returns the number of rows in a table:","text":"<pre><code>SELECT COUNT(*)\nFROM nikovits.employees\nWHERE department_id = 50;\n</code></pre> COUNT(*) 45"},{"location":"archive/P3/#countexpr-returns-the-number-of-rows-with-non-null-values-for-expr","title":"COUNT(expr) returns the number of rows with non-null values for expr:","text":"<pre><code>SELECT COUNT(commission_pct)\nFROM nikovits.employees\nWHERE department_id = 80\n</code></pre> COUNT(COMMISSION_PCT) 34"},{"location":"archive/P3/#using-the-distinct-keyword","title":"Using the DISTINCT Keyword","text":"<ul> <li>COUNT(DISTINCT expr) returns the number of distinct non-null values of the expr.</li> <li>To display the number of distinct department values in the nikovits.employees table:</li> </ul> <pre><code>SELECT COUNT(DISTINCT department_id)\nFROM nikovits.employees;\n</code></pre> COUNT(DISTINCT DEPARTMENT_ID) 11"},{"location":"archive/P3/#group-functions-and-null-values","title":"Group Functions and Null Values","text":""},{"location":"archive/P3/#group-functions-ignore-null-values-in-the-column","title":"Group functions ignore null values in the column:","text":"<pre><code>SELECT AVG(commission_pct)\nFROM nikovits.employees;\n</code></pre> AVG(COMMISSION_PCT) .2228571428571428571"},{"location":"archive/P3/#the-nvl-function-forces-group-functions-to-include-null-values","title":"The NVL function forces group functions to include null values:","text":"<pre><code>SELECT AVG(NVL(commission_pct, 0))\nFROM nikovits.employees;\n</code></pre> AVG(NVL(COMMISSION_PCT,0)) .0728971962616822429906542"},{"location":"archive/P4/","title":"Creating Groups of Data","text":""},{"location":"archive/P4/#creating-groups-of-data-group-by-clause-syntax","title":"Creating Groups of Data: GROUP BY Clause Syntax","text":"<pre><code>SELECT     column, group_function(column)\nFROM       table\n[WHERE     condition]\n[GROUP BY  group_by_expression]\n[ORDER BY  column];\n</code></pre> <p>You can divide rows in a table into smaller groups by using the GROUP BY clause.</p>"},{"location":"archive/P4/#using-the-group-by-clause","title":"Using the GROUP BY Clause","text":"<p>All columns in the SELECT list that are not in group functions must be in the GROUP BY clause.</p> <pre><code>SELECT department_id, AVG(salary)\nFROM nikovits.employees\nGROUP BY department_id;\n</code></pre> DEPARTMENT_ID AVG(SALARY) 100 8600 30 4150 NULL 7000 90 19333.33333333333333 20 9500 70 10000 110 10150 50 3475.555555555555555 80 8955.882352941176470 40 6500 60 5760 10 4400"},{"location":"archive/P4/#using-the-group-by-clause_1","title":"Using the GROUP BY Clause","text":"<p>The GROUP BY column does not have to be in the SELECT list.</p> <pre><code>SELECT AVG(salary)\nFROM nikovits.employees\nGROUP BY department_id;\n</code></pre> AVG(SALARY) 8600 4150 7000 19333.33333333333333 9500 10000 10150 3475.555555555555555 8955.882352941176470 6500 5760 4400"},{"location":"archive/P4/#grouping-by-more-than-one-column","title":"Grouping by More Than One Column","text":""},{"location":"archive/P4/#using-the-group-by-clause-on-multiple-columns","title":"Using the GROUP BY Clause on Multiple Columns","text":"<pre><code>SELECT department_id dept_id, job_id, SUM(salary)\nFROM nikovits.employees\nGROUP BY department_id, job_id ;\n</code></pre> DEPT_ID JOB_ID SUM(SALARY) 110 AC_ACCOUNT 8300 90 AD_VP 34000 50 ST_CLERK 55700 80 SA_REP 243500 50 ST_MAN 36400 80 SA_MAN 61000 110 AC_MGR 12000 90 AD_PRES 24000 60 IT_PROG 28800 100 FI_MGR 12000 30 PU_CLERK 13900 50 SH_CLERK 64300 20 MK_MAN 13000 100 FI_ACCOUNT 39600 NULL SA_REP 7000 70 PR_REP 10000 30 PU_MAN 11000 10 AD_ASST 4400 20 MK_REP 6000 40 HR_REP 6500"},{"location":"archive/P4/#illegal-queries-using-group-functions","title":"Illegal Queries Using Group Functions","text":"<p>Any column or expression in the SELECT list that is not an aggregate function must be in the GROUP BY clause:</p> <pre><code>SELECT   department_id, COUNT(last_name)\nFROM     employees;\n</code></pre> <p></p> <p>Column missing in the GROUP BY clause</p>"},{"location":"archive/P4/#illegal-queries-using-group-functions_1","title":"Illegal Queries Using Group Functions","text":"<ul> <li>You cannot use the WHERE clause to restrict groups.</li> <li>You use the HAVING clause to restrict groups.</li> <li>You cannot use group functions in the WHERE clause.</li> </ul> <pre><code>SELECT   department_id, AVG(salary)\nFROM     employees\nWHERE    AVG(salary) &gt; 8000\nGROUP BY department_id;\n</code></pre> <p>Cannot use the WHERE clause to restrict groups</p>"},{"location":"archive/P4/#restricting-group-functions","title":"Restricting Group Functions","text":""},{"location":"archive/P4/#restricting-group-results-with-the-having-clause","title":"Restricting Group Results with the HAVING Clause","text":"<ul> <li>When you use the HAVING clause, the Oracle server restricts groups as follows:</li> <li>Rows are grouped.</li> <li>The group function is applied.</li> <li>Groups matching the HAVING clause are displayed.</li> </ul> <pre><code>SELECT     column, group_function\nFROM       table\n[WHERE     condition]\n[GROUP BY  group_by_expression]\n[HAVING    group_condition]\n[ORDER BY  column];\n</code></pre>"},{"location":"archive/P4/#using-the-having-clause","title":"Using the HAVING Clause","text":"<pre><code>SELECT department_id, MAX(salary)\nFROM nikovits.employees\nGROUP BY department_id\nHAVING MAX(salary)&gt;10000 ;\n</code></pre> DEPARTMENT_ID MAX(SALARY) 100 12000 30 11000 90 24000 20 13000 110 12000 80 14000 <pre><code>SELECT job_id, SUM(salary) PAYROLL\nFROM nikovits.employees\nWHERE job_id NOT LIKE '%REP%'\nGROUP BY job_id\nHAVING SUM(salary) &gt; 13000\nORDER BY SUM(salary);\n</code></pre> JOB_ID PAYROLL PU_CLERK 13900 AD_PRES 24000 IT_PROG 28800 AD_VP 34000 ST_MAN 36400 FI_ACCOUNT 39600 ST_CLERK 55700 SA_MAN 61000 SH_CLERK 64300"},{"location":"archive/P4/#nesting-group-functions","title":"Nesting Group Functions","text":"<ul> <li>Display the maximum average salary:</li> <li>Group functions can be nested to a depth of two.</li> <li>The example displays the maximum average salary.</li> </ul> <pre><code>SELECT MAX(AVG(salary))\nFROM nikovits.employees\nGROUP BY department_id;\n</code></pre> MAX(AVG(SALARY)) 19333.33333333333333"},{"location":"archive/P4/#obtaining-data-from-multiple-tables","title":"Obtaining Data from Multiple Tables","text":""},{"location":"archive/P4/#types-of-joins","title":"Types of Joins","text":"<ul> <li>Joins that are compliant with the SQL:1999 standard include the following:     \u2013 Cross joins     \u2013 Natural joins     \u2013 USING clause     \u2013 Full (or two-sided) outer joins     \u2013 Arbitrary join conditions for outer joins</li> </ul>"},{"location":"archive/P4/#joining-tables-using-sql1999-syntax","title":"Joining Tables Using SQL:1999 Syntax","text":"<p>Use a join to query data from more than one table:</p> <pre><code>SELECT table1.column, table2.column\nFROM   table1\n[NATURAL JOIN table2] |\n[JOIN table2 USING (column_name)] |\n[JOIN table2\n ON (table1.column_name = table2.column_name)] |\n[LEFT|RIGHT|FULL OUTER JOIN table2\n ON (table1.column_name = table2.column_name)] |\n[CROSS JOIN table2];\n</code></pre>"},{"location":"archive/P4/#creating-natural-joins","title":"Creating Natural Joins","text":"<ul> <li>The NATURAL JOIN clause is based on all columns in the two tables that have the same name.</li> <li>It selects rows from the two tables that have equal values in all matched columns.</li> <li>If the columns having the same names have different data types, an error is returned.</li> </ul>"},{"location":"archive/P4/#retrieving-records-with-natural-joins","title":"Retrieving Records with Natural Joins","text":"<pre><code>SELECT department_id, department_name,\nlocation_id, city\nFROM nikovits.departments\nNATURAL JOIN nikovits.locations ;\n</code></pre> DEPARTMENT_ID DEPARTMENT_NAME LOCATION_ID CITY 10 Administration 1700 Seattle 20 Marketing 1800 Toronto 30 Purchasing 1700 Seattle 40 Human Resources 2400 London 50 Shipping 1500 South San Francisco 60 IT 1400 Southlake 70 Public Relations 2700 Munich 80 Sales 2500 Oxford 90 Executive 1700 Seattle 100 Finance 1700 Seattle 110 Accounting 1700 Seattle 120 Treasury 1700 Seattle"},{"location":"archive/P4/#creating-joins-with-the-using-clause","title":"Creating Joins with the USING Clause","text":"<ul> <li>If several columns have the same names but the data types do not match, the NATURAL JOIN clause can be modified with the USING clause to specify the columns that should be used for an equijoin.</li> <li>Use the USING clause to match only one column when more than one column matches.</li> <li>Do not use a table name or alias in the referenced columns.</li> <li>The NATURAL JOIN and USING clauses are mutually exclusive.</li> </ul>"},{"location":"archive/P4/#joining-column-names","title":"Joining Column Names","text":"<pre><code>SELECT nikovits.employees.employee_id, nikovits.employees.last_name,\nnikovits.departments.location_id, department_id\nFROM nikovits.employees JOIN nikovits.departments\nUSING (department_id) ;\n</code></pre> EMPLOYEE_ID LAST_NAME LOCATION_ID DEPARTMENT_ID 100 King 1700 90 101 Kochhar 1700 90 102 De Haan 1700 90 103 Hunold 1400 60 104 Ernst 1400 60 105 Austin 1400 60 106 Pataballa 1400 60 107 Lorentz 1400 60 108 Greenberg 1700 100 109 Faviet 1700 100 110 Chen 1700 100"},{"location":"archive/P4/#qualifying-ambiguous","title":"Qualifying Ambiguous","text":""},{"location":"archive/P4/#column-names","title":"Column Names","text":"<ul> <li>Use table prefixes to qualify column names that are in multiple tables.</li> <li>Use table prefixes to improve performance.</li> <li>Use column aliases to distinguish columns that have identical names but reside in different tables.</li> <li>Do not use aliases on columns that are identified in the USING clause and listed elsewhere in the SQL statement.</li> </ul>"},{"location":"archive/P4/#using-table-aliases","title":"Using Table Aliases","text":"<ul> <li>Use table aliases to simplify queries.</li> <li>Use table aliases to improve performance.</li> </ul> <pre><code>SELECT e.employee_id, e.last_name,\n       d.location_id, department_id\nFROM   employees e JOIN departments d\nUSING  (department_id) ;\n</code></pre>"},{"location":"archive/P4/#creating-joins-with-the-on-clause","title":"Creating Joins with the ON Clause","text":"<ul> <li>The join condition for the natural join is basically an equijoin of all columns with the same name.</li> <li>Use the ON clause to specify arbitrary conditions or specify columns to join.</li> <li>The join condition is separated from other search conditions.</li> <li>The ON clause makes code easy to understand.</li> </ul> <pre><code>SELECT e.employee_id, e.last_name, e.department_id,\nd.department_id, d.location_id\nFROM nikovits.employees e JOIN nikovits.departments d\nON (e.department_id = d.department_id);\n</code></pre> EMPLOYEE_ID LAST_NAME DEPARTMENT_ID DEPARTMENT_ID LOCATION_ID 100 King 90 90 1700 101 Kochhar 90 90 1700 102 De Haan 90 90 1700 103 Hunold 60 60 1400 104 Ernst 60 60 1400 105 Austin 60 60 1400 106 Pataballa 60 60 1400 107 Lorentz 60 60 1400 108 Greenberg 100 100 1700 109 Faviet 100 100 1700 110 Chen 100 100 1700 111 Sciarra 100 100 1700 112 Urman 100 100 1700 113 Popp 100 100 1700 114 Raphaely 30 30 1700"},{"location":"archive/P4/#self-joins-using-the-on-clause","title":"Self-Joins Using the ON Clause","text":"<pre><code>SELECT e.last_name emp, m.last_name mgr\nFROM nikovits.employees e JOIN nikovits.employees m\nON (e.manager_id = m.employee_id);\n</code></pre> EMP MGR Kochhar King De Haan King Raphaely King Weiss King Fripp King Kaufling King Vollman King Mourgos King Russell King Partners King Errazuriz King Cambrault King Zlotkey King"},{"location":"archive/P4/#applying-additional-conditions-to-a-join","title":"Applying Additional Conditions to a Join","text":"<pre><code>SELECT e.employee_id, e.last_name, e.department_id,\n       d.department_id, d.location_id\nFROM   employees e JOIN departments d\nON     (e.department_id = d.department_id)\nAND    e.manager_id = 149;\n</code></pre> EMPLOYEE_ID LAST_NAME DEPARTMENT_ID DEPARTMENT_ID LOCATION_ID 174 Abel 80 80 2500 178 Taylor 80 80 2500 <p>Alternatively, you can use a WHERE clause to apply additional conditions:</p> <pre><code>SELECT e.employee_id, e.last_name, e.department_id,\n       d.department_id, d.location_id\nFROM   employees e JOIN departments d\nON     (e.department_id = d.department_id)\nWHERE  e.manager_id = 149;\n</code></pre>"},{"location":"archive/P4/#creating-three-way-joins-with-the-on-clause","title":"Creating Three-Way Joins with the ON Clause","text":"<pre><code>SELECT employee_id, city, department_name\nFROM nikovits.employees e\nJOIN nikovits.departments d\nON d.department_id = e.department_id\nJOIN nikovits.locations l\nON d.location_id = l.location_id;\n</code></pre> EMPLOYEE_ID CITY DEPARTMENT_NAME 100 Seattle Executive 101 Seattle Executive 102 Seattle Executive 103 Southlake IT 104 Southlake IT 105 Southlake IT 106 Southlake IT 107 Southlake IT 108 Seattle Finance 109 Seattle Finance 110 Seattle Finance 111 Seattle Finance 112 Seattle Finance 113 Seattle Finance"},{"location":"archive/P4/#non-equijoin","title":"Non-Equijoin","text":"<pre><code>SELECT e.last_name, e.salary, j.grade_level\nFROM nikovits.employees e JOIN nikovits.job_grades j\nON e.salary\nBETWEEN j.lowest_sal AND j.highest_sal;\n</code></pre> LAST_NAME SALARY GRADE_LEVEL Olson 2100 A Markle 2200 A Philtanker 2200 A Landry 2400 A Gee 2400 A Colmenares 2500 A Marlow 2500 A Patel 2500 A Vargas 2500 A Sullivan 2500 A Perkins 2500 A Himuro 2600 A"},{"location":"archive/P4/#outer-joins","title":"Outer Joins","text":""},{"location":"archive/P4/#inner-versus-outer-joins","title":"INNER Versus OUTER Joins","text":"<ul> <li>In SQL:1999, the join of two tables returning only matched rows is called an inner join.</li> <li>A join between two tables that returns the results of the inner join as well as the unmatched rows from the left (or right) tables is called a left (or right) outer join.</li> <li>A join between two tables that returns the results of an inner join as well as the results of a left and right join is a full outer join.</li> </ul>"},{"location":"archive/P4/#left-outer-join","title":"LEFT OUTER JOIN","text":"<pre><code>SELECT e.last_name, e.department_id, d.department_name\nFROM nikovits.employees e LEFT OUTER JOIN nikovits.departments d\nON (e.department_id = d.department_id) ;\n</code></pre> LAST_NAME DEPARTMENT_ID DEPARTMENT_NAME Whalen 10 Administration Hartstein 20 Marketing Fay 20 Marketing Raphaely 30 Purchasing Khoo 30 Purchasing Baida 30 Purchasing Tobias 30 Purchasing Himuro 30 Purchasing Colmenares 30 Purchasing Mavris 40 Human Resources Weiss 50 Shipping Fripp 50 Shipping Kaufling 50 Shipping"},{"location":"archive/P4/#right-outer-join","title":"RIGHT OUTER JOIN","text":"<pre><code>SELECT e.last_name, e.department_id, d.department_name\nFROM nikovits.employees e RIGHT OUTER JOIN nikovits.departments d\nON (e.department_id = d.department_id) ;\n</code></pre> LAST_NAME DEPARTMENT_ID DEPARTMENT_NAME King 90 Executive Kochhar 90 Executive De Haan 90 Executive Hunold 60 IT Ernst 60 IT Austin 60 IT Pataballa 60 IT Lorentz 60 IT Greenberg 100 Finance Faviet 100 Finance"},{"location":"archive/P4/#full-outer-join","title":"FULL OUTER JOIN","text":"<pre><code>SELECT e.last_name, d.department_id, d.department_name\nFROM nikovits.employees e FULL OUTER JOIN nikovits.departments d\nON (e.department_id = d.department_id) ;\n</code></pre> LAST_NAME DEPARTMENT_ID DEPARTMENT_NAME King 90 Executive Kochhar 90 Executive De Haan 90 Executive Hunold 60 IT Ernst 60 IT Austin 60 IT Pataballa 60 IT Lorentz 60 IT Greenberg 100 Finance Faviet 100 Finance Chen 100 Finance Sciarra 100 Finance"},{"location":"archive/P4/#cartesian-products","title":"Cartesian Products","text":"<ul> <li> <p>A Cartesian product is formed when:</p> </li> <li> <p>A join condition is omitted</p> </li> <li>A join condition is invalid</li> <li> <p>All rows in the first table are joined to all rows in the second table</p> </li> <li> <p>To avoid a Cartesian product, always include a valid join condition.</p> </li> </ul>"},{"location":"archive/P4/#generating-a-cartesian-product","title":"Generating a Cartesian Product","text":""},{"location":"archive/P4/#creating-cross-joins","title":"Creating Cross Joins","text":"<ul> <li>The CROSS JOIN clause produces the crossproduct of two tables.</li> <li>This is also called a Cartesian product between the two tables.</li> </ul> <pre><code>SELECT last_name, department_name\nFROM nikovits.employees\nCROSS JOIN nikovits.departments ;\n</code></pre> LAST_NAME DEPARTMENT_NAME King Administration Kochhar Administration De Haan Administration Hunold Administration Ernst Administration Austin Administration Pataballa Administration Lorentz Administration Greenberg Administration Faviet Administration Chen Administration Sciarra Administration"},{"location":"archive/P4/#using-a-subquery-to-solve-a-problem","title":"Using a Subquery to Solve a Problem","text":""},{"location":"archive/P4/#subquery-syntax","title":"Subquery Syntax","text":"<pre><code>SELECT  select_list\nFROM    table\nWHERE   expr operator\n        (SELECT select_list\n         FROM   table);\n</code></pre> <ul> <li>The subquery (inner query) executes once before the main query (outer query).</li> <li>The result of the subquery is used by the main query.</li> </ul> <pre><code>SELECT last_name\nFROM nikovits.employees\nWHERE salary &gt;\n(SELECT salary\nFROM nikovits.employees\nWHERE last_name = 'Abel');\n</code></pre> LAST_NAME King Kochhar De Haan Greenberg Russell Partners Errazuriz Ozer Hartstein Higgins"},{"location":"archive/P4/#guidelines-for-using-subqueries","title":"Guidelines for Using Subqueries","text":"<ul> <li>Enclose subqueries in parentheses.</li> <li>Place subqueries on the right side of the comparison condition.</li> <li>The ORDER BY clause in the subquery is not needed unless you are performing Top-N analysis.</li> <li>Use single-row operators with single-row subqueries, and use multiple-row operators with multiple-row subqueries.</li> </ul>"},{"location":"archive/P4/#types-of-subqueries","title":"Types of Subqueries","text":""},{"location":"archive/P4/#single-row-subqueries","title":"Single-Row Subqueries","text":"<ul> <li>Return only one row</li> <li>Use single-row comparison operators</li> </ul> Operator Meaning = Equal to &gt; Greater than &gt;= Greater than or equal to &lt; Less than &lt;= Less than or equal to &lt;&gt; Not equal to"},{"location":"archive/P4/#executing-single-row-subqueries","title":"Executing Single-Row Subqueries","text":"<pre><code>SELECT last_name, job_id, salary\nFROM nikovits.employees\nWHERE job_id =\n(SELECT job_id\nFROM nikovits.employees\nWHERE employee_id = 141)\nAND salary &gt;\n(SELECT salary\nFROM nikovits.employees\nWHERE employee_id = 143);\n</code></pre> LAST_NAME JOB_ID SALARY Nayer ST_CLERK 3200 Mikkilineni ST_CLERK 2700 Bissot ST_CLERK 3300 Atkinson ST_CLERK 2800 Mallin ST_CLERK 3300 Rogers ST_CLERK 2900 Ladwig ST_CLERK 3600 Stiles ST_CLERK 3200 Seo ST_CLERK 2700"},{"location":"archive/P4/#using-group-functions-in-a-subquery","title":"Using Group Functions in a Subquery","text":"<pre><code>SELECT last_name, job_id, salary\nFROM nikovits.employees\nWHERE salary =\n(SELECT MIN(salary)\nFROM nikovits.employees);\n</code></pre> LAST_NAME JOB_ID SALARY Olson ST_CLERK 2100"},{"location":"archive/P4/#the-having-clause-with-subqueries","title":"The HAVING Clause with Subqueries","text":"<ul> <li>The Oracle server executes subqueries first.</li> <li>The Oracle server returns results into the HAVING clause of the main query.</li> </ul> <pre><code>SELECT   department_id, MIN(salary)\nFROM     employees\nGROUP BY department_id\nHAVING   MIN(salary) &gt; \n         (SELECT MIN(salary)\n          FROM   employees\n          WHERE  department_id = 50);\n</code></pre>"},{"location":"archive/P4/#what-is-wrong-with-this-statement","title":"What Is Wrong with This Statement?","text":"<pre><code>SELECT employee_id, last_name\nFROM   employees\nWHERE  salary =\n       (SELECT   MIN(salary)\n        FROM     employees\n        GROUP BY department_id);\n</code></pre> <p>Single-row operator with multiple-row subquery</p>"},{"location":"archive/P4/#will-this-statement-return-rows","title":"Will This Statement Return Rows?","text":"<pre><code>SELECT last_name, job_id\nFROM   employees\nWHERE  job_id =\n       (SELECT job_id\n        FROM   employees\n        WHERE  last_name = 'Haas');\n</code></pre> <p>Subquery returns no values.</p>"},{"location":"archive/P4/#multiple-row-subqueries","title":"Multiple-Row Subqueries","text":"<ul> <li>Return more than one row</li> <li>Use multiple-row comparison operators</li> </ul> Operator Meaning IN Equal to any member in the list ANY Compare value to each value returned by the subquery ALL Compare value to every value returned by the subquery"},{"location":"archive/P4/#using-the-any-operator-in-multiple-row-subqueries","title":"Using the ANY Operator in Multiple-Row Subqueries","text":"<pre><code>SELECT employee_id, last_name, job_id, salary\nFROM nikovits.employees\nWHERE salary &lt; ANY\n(SELECT salary\nFROM nikovits.employees\nWHERE job_id = 'IT_PROG')\nAND job_id &lt;&gt; 'IT_PROG';\n</code></pre> EMPLOYEE_ID LAST_NAME JOB_ID SALARY 132 Olson ST_CLERK 2100 136 Philtanker ST_CLERK 2200 128 Markle ST_CLERK 2200 135 Gee ST_CLERK 2400 127 Landry ST_CLERK 2400 191 Perkins SH_CLERK 2500 182 Sullivan SH_CLERK 2500 144 Vargas ST_CLERK 2500 140 Patel ST_CLERK 2500"},{"location":"archive/P4/#using-the-all-operator-in-multiple-row-subqueries","title":"Using the ALL Operator in Multiple-Row Subqueries","text":"<pre><code>SELECT employee_id, last_name, job_id, salary\nFROM nikovits.employees\nWHERE salary &lt; ALL\n(SELECT salary\nFROM nikovits.employees\nWHERE job_id = 'IT_PROG')\nAND job_id &lt;&gt; 'IT_PROG';\n</code></pre> EMPLOYEE_ID LAST_NAME JOB_ID SALARY 185 Bull SH_CLERK 4100 192 Bell SH_CLERK 4000 193 Everett SH_CLERK 3900 188 Chung SH_CLERK 3800 137 Ladwig ST_CLERK 3600 189 Dilly SH_CLERK 3600 141 Rajs ST_CLERK 3500 186 Dellinger SH_CLERK 3400 133 Mallin ST_CLERK 3300 129 Bissot ST_CLERK 3300 180 Taylor SH_CLERK 3200 138 Stiles ST_CLERK 3200"},{"location":"archive/P4/#null-values-in-a-subquery","title":"Null Values in a Subquery","text":"<pre><code>SELECT  emp.last_name\nFROM    employees emp\nWHERE   emp.employee_id NOT IN\n        (SELECT mgr.manager_id\n         FROM   employees mgr);\n</code></pre> <p>no rows selected</p> <p>x NOT IN (A, B, NULL) \u2192 Unknown</p>"},{"location":"archive/P4/#joins-summary","title":"Joins Summary","text":""},{"location":"archive/P5/","title":"Multiple-Column Subqueries","text":"<pre><code>Main query\nWHERE (MANAGER_ID, DEPARTMENT_ID) IN\n          \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n          \u2502     Subquery        \u2502\n          \u2502 100     90          \u2502\n          \u2502 102     60          \u2502\n          \u2502 124     50          \u2502\n          \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Each row of the main query is compared to values from a multiple-row and multiple-column subquery.</p>"},{"location":"archive/P5/#pairwise-comparison-subquery","title":"Pairwise Comparison Subquery","text":"<p>Display the details of the employees who are managed by the same manager and work in the same department as the employees with <code>EMPLOYEE_ID</code> 199 or 174.</p> <pre><code>SELECT employee_id, manager_id, department_id\nFROM employees\nWHERE (manager_id, department_id) IN\n    (SELECT manager_id, department_id\n     FROM employees\n     WHERE employee_id IN (199, 174))\nAND employee_id NOT IN (199, 174);\n</code></pre>"},{"location":"archive/P5/#nonpairwise-comparison-subquery","title":"Nonpairwise Comparison Subquery","text":"<p>Display the details of the employees who are managed by the same manager as the employees with <code>EMPLOYEE_ID</code> 174 or 199 and work in the same department as the employees with <code>EMPLOYEE_ID</code> 174 or 199.</p> <pre><code>SELECT employee_id, manager_id, department_id\nFROM employees\nWHERE manager_id IN\n    (SELECT manager_id\n     FROM employees\n     WHERE employee_id IN (174, 199))\nAND department_id IN\n    (SELECT department_id\n     FROM employees\n     WHERE employee_id IN (174, 199))\nAND employee_id NOT IN (174, 199);\n</code></pre>"},{"location":"archive/P5/#scalar-subquery-expressions","title":"Scalar Subquery Expressions","text":"<ul> <li>A scalar subquery expression is a subquery that returns exactly one column value from one row.</li> <li>Scalar subqueries can be used in:<ul> <li>Condition and expression parts of <code>DECODE</code> and <code>CASE</code></li> <li>All clauses of a <code>SELECT</code> statement except <code>GROUP BY</code></li> </ul> </li> </ul>"},{"location":"archive/P5/#scalar-subqueries-examples","title":"Scalar Subqueries Examples","text":"<p>Scalar Subqueries in CASE Expressions</p> <pre><code>SELECT employee_id, last_name,\n       (CASE \n            WHEN department_id = \n                    (SELECT department_id\n                      FROM departments\n                      WHERE location_id = 1800)\n            THEN 'Canada' ELSE 'USA'\n        END) location\nFROM employees;\n</code></pre> <p>Scalar subqueries in ORDER BY clause</p> <pre><code>SELECT employee_id, last_name\nFROM employees e\nORDER BY (SELECT department_name\n          FROM departments d\n          WHERE e.department_id = d.department_id);\n</code></pre>"},{"location":"archive/P5/#correlated-subqueries","title":"Correlated Subqueries","text":"<ul> <li>Correlated subqueries are used for row-by-row processing.</li> <li>Each subquery is executed once for every row of the outer query.</li> <li>The inner query references columns from the outer query (making it \"correlated\").</li> </ul> <pre>\nGET\ncandidate row from outer query\n\u2193\nEXECUTE\ninner query using candidate row value\n\u2193\nUSE\nvalues from inner query to qualify or disqualify candidate row\n</pre> <p>The subquery references a column from a table in the parent (outer) query.</p> <pre><code>SELECT column1, column2, ...\nFROM table1 outer\nWHERE column1 operator\n    (SELECT column1, column2\n     FROM table2\n     WHERE expr1 = outer.expr2);\n</code></pre> <p>Find all employees who earn more than the average salary in their department.</p> <pre><code>SELECT last_name, salary, department_id\nFROM employees outer\nWHERE salary &gt; \n    (SELECT AVG(salary)\n     FROM employees\n     WHERE department_id = outer.department_id);\n</code></pre> <p>Each time a row from the outer query is processed, the inner query is evaluated.</p>"},{"location":"archive/P5/#correlated-subquery-example","title":"Correlated Subquery Example","text":"<p>Display details of those employees who have changed jobs at least twice.</p> <pre><code>SELECT e.employee_id, e.last_name, e.job_id\nFROM employees e\nWHERE 2 &lt;= (\n    SELECT COUNT(*)\n    FROM job_history\n    WHERE employee_id = e.employee_id\n);\n</code></pre> EMPLOYEE_ID LAST_NAME JOB_ID 101 Kochar AD_VP 176 Taylor SA_REP 200 Whalen AD_ASST"},{"location":"archive/P5/#using-the-exists-operator","title":"Using the EXISTS Operator","text":"<ul> <li>The EXISTS operator tests for the existence of rows in the result set of the subquery.</li> <li>It returns TRUE if the subquery returns at least one row, FALSE otherwise.</li> <li>NOT EXISTS does the opposite.</li> </ul> <p>If a subquery row value is found:</p> <ul> <li>The search does not continue in the inner query (short-circuits after first match).</li> <li>The condition is flagged TRUE.</li> </ul> <p>If a subquery row value is not found:</p> <ul> <li>The condition is flagged FALSE.</li> <li>The search continues in the inner query until all rows are checked or a match is found.</li> </ul>"},{"location":"archive/P5/#find-employees-who-have-at-least-one-person-reporting-to-them","title":"Find Employees Who Have at Least One Person Reporting to Them","text":"<pre><code>SELECT employee_id, last_name, job_id, department_id\nFROM employees outer\nWHERE EXISTS (\n    SELECT 'X'\n    FROM employees\n    WHERE manager_id = outer.employee_id\n);\n</code></pre> EMPLOYEE_ID LAST_NAME JOB_ID DEPARTMENT_ID 100 King AD_PRES 90 101 Kochhar AD_VP 90 102 De Haan AD_VP 90 103 Hunold IT_PROG 60 108 Greenberg FI_MGR 100 114 Raphaely PU_MAN 30 120 Weiss ST_MAN 50 121 Fripp ST_MAN 50 122 Kaufling ST_MAN 50"},{"location":"archive/P5/#find-all-departments-that-do-not-have-any-employees","title":"Find All Departments That Do Not Have Any Employees","text":"<pre><code>SELECT department_id, department_name\nFROM departments d\nWHERE NOT EXISTS (\n    SELECT 'X'\n    FROM employees\n    WHERE department_id = d.department_id\n);\n</code></pre> DEPARTMENT_ID DEPARTMENT_NAME 120 Treasury 130 Corporate Tax 140 Control And Credit 150 Shareholder Services 160 Benefits 170 Manufacturing"},{"location":"archive/P5/#the-with-clause","title":"The WITH Clause","text":"<ul> <li>Using the WITH clause, you can use the same query block in a <code>SELECT</code> statement when it occurs more than once within a complex query.</li> <li>The WITH clause retrieves the results of a query block and stores it in the user's temporary tablespace.</li> <li>The WITH clause improves performance by avoiding repeated execution of the same subquery.</li> </ul>"},{"location":"archive/P5/#with-clause-example","title":"WITH Clause Example","text":"<p>Using the <code>WITH</code> clause, write a query to display the department name and total salaries for those departments whose total salary is greater than the average salary across departments.</p> <pre><code>WITH \ndept_costs AS (\n    SELECT d.department_name, SUM(e.salary) AS dept_total\n    FROM employees e\n    JOIN departments d ON e.department_id = d.department_id\n    GROUP BY d.department_name\n),\navg_cost AS (\n    SELECT SUM(dept_total)/COUNT(*) AS dept_avg\n    FROM dept_costs\n)\nSELECT *\nFROM dept_costs\nWHERE dept_total &gt; \n    (SELECT dept_avg\n     FROM avg_cost)\nORDER BY department_name;\n</code></pre>"},{"location":"archive/P5/#data-manipulation-language-dml-in-sql","title":"Data Manipulation Language (DML) in SQL","text":"<ul> <li> <p>A DML statement is executed when you:</p> <ul> <li>Add new rows to a table</li> <li>Modify existing rows in a table</li> <li>Remove existing rows from a table</li> </ul> </li> <li> <p>A transaction consists of a collection of DML statements that form a logical unit of work.</p> </li> </ul>"},{"location":"archive/P5/#adding-a-new-row-to-a-table","title":"Adding a New Row to a Table","text":""},{"location":"archive/P5/#insert-statement-syntax","title":"INSERT Statement Syntax","text":"<ul> <li>Add new rows to a table by using the INSERT statement.</li> </ul> <pre><code>INSERT INTO table [(column [, column...])]\nVALUES (value [, value...]);\n</code></pre> <p>With this syntax, only one row is inserted at a time.</p>"},{"location":"archive/P5/#inserting-new-rows","title":"Inserting New Rows","text":"<ul> <li>Insert a new row containing values for each column.</li> <li>List values in the default order of the columns in the table.</li> <li>Optionally, list the columns explicitly in the <code>INSERT</code> clause.</li> <li>Enclose character and date values in single quotation marks.</li> </ul> <pre><code>INSERT INTO departments (department_id, department_name, manager_id, location_id)\nVALUES (70, 'Public Relations', 100, 1700);\n</code></pre>"},{"location":"archive/P5/#inserting-rows-with-null-values","title":"Inserting Rows with NULL Values","text":""},{"location":"archive/P5/#implicit-method","title":"Implicit Method","text":"<ul> <li>Omit the column from the column list.</li> <li>The omitted column(s) will receive NULL (or default value if defined).</li> </ul> <pre><code>INSERT INTO departments (department_id, department_name)\nVALUES (30, 'Purchasing');\n</code></pre>"},{"location":"archive/P5/#explicit-method","title":"Explicit Method","text":"<ul> <li>Specify the NULL keyword in the VALUES clause.</li> </ul> <pre><code>INSERT INTO departments\nVALUES (100, 'Finance', NULL, NULL);\n</code></pre>"},{"location":"archive/P5/#copying-rows-from-another-table","title":"Copying Rows from Another Table","text":"<ul> <li>Write your INSERT statement with a subquery.</li> <li>Do not use the <code>VALUES</code> clause.</li> <li>Match the number of columns in the <code>INSERT</code> clause to those in the subquery.</li> </ul> <pre><code>INSERT INTO target_table [(column1, column2, ...)]\nSELECT column1, column2, ...\nFROM source_table\n[WHERE condition];\n</code></pre>"},{"location":"archive/P5/#changing-data-in-a-table","title":"Changing Data in a Table","text":""},{"location":"archive/P5/#update-statement-syntax-in-oracle-sql","title":"UPDATE Statement Syntax in Oracle SQL","text":"<ul> <li>Modify existing rows with the UPDATE statement.</li> </ul> <pre><code>UPDATE table\nSET column = value [, column = value, ...]\n[WHERE condition];\n</code></pre> <ul> <li> <p>Update more than one row at a time (if required).</p> </li> <li> <p>Specific row or rows are modified if you specify the WHERE clause.</p> </li> </ul> <pre><code>UPDATE employees\nSET department_id = 70\nWHERE employee_id = 113;\n</code></pre> <ul> <li>All rows in the table are modified if you omit the WHERE clause.</li> </ul> <pre><code>UPDATE copy_emp\nSET department_id = 110;\n</code></pre>"},{"location":"archive/P5/#updating-two-columns-with-a-subquery","title":"Updating Two Columns with a Subquery","text":"<p>Update employee 114's job and salary to match that of employee 205.</p> <pre><code>UPDATE employees\nSET job_id = (SELECT job_id\n              FROM employees\n              WHERE employee_id = 205),\n    salary = (SELECT salary\n              FROM employees\n              WHERE employee_id = 205)\nWHERE employee_id = 114;\n</code></pre>"},{"location":"archive/P5/#removing-a-row-from-a-table","title":"Removing a Row from a Table","text":""},{"location":"archive/P5/#delete-statement-in-oracle-sql","title":"DELETE Statement in Oracle SQL","text":"<ul> <li>You can remove existing rows from a table by using the DELETE statement.</li> </ul> <pre><code>DELETE [FROM] table\n[WHERE condition];\n</code></pre> <ul> <li>Specific rows are deleted if you specify the WHERE clause.</li> </ul> <pre><code>DELETE FROM departments\nWHERE department_name = 'Finance';\n</code></pre> <ul> <li>All rows in the table are deleted if you omit the WHERE clause.</li> </ul> <pre><code>DELETE FROM copy_emp;\n</code></pre>"},{"location":"archive/P5/#deleting-rows-based-on-another-table","title":"Deleting Rows Based on Another Table","text":"<ul> <li>Use subqueries in <code>DELETE</code> statements to remove rows from a table based on values from another table.</li> </ul> <pre><code>DELETE FROM employees\nWHERE department_id = \n    (SELECT department_id\n     FROM departments\n     WHERE department_name LIKE '%Public%');\n</code></pre>"},{"location":"archive/P5/#truncate-statement-in-oracle-sql","title":"TRUNCATE Statement in Oracle SQL","text":"<ul> <li>Removes all rows from a table, leaving the table empty and the table structure intact.</li> <li>Is a data definition language (DDL) statement rather than a DML statement.</li> <li>Cannot easily be undone (implicit commit \u2014 no ROLLBACK possible).</li> </ul> <pre><code>TRUNCATE TABLE table_name;\n</code></pre> <p>Example:</p> <pre><code>TRUNCATE TABLE copy_emp;\n</code></pre>"},{"location":"archive/P5/#using-a-subquery-in-an-insert-statement","title":"Using a Subquery in an INSERT Statement","text":"<pre><code>INSERT INTO \n    (SELECT employee_id, last_name, email, hire_date, job_id, salary, department_id\n     FROM employees\n     WHERE department_id = 50)\nVALUES (99999, 'Taylor', 'DTAYLOR', \n       TO_DATE('07-Jun-99', 'DD-MON-RR'), \n       'ST_CLERK', 5000, 50);\n</code></pre> <p>Verify the results:</p> <p></p>"},{"location":"archive/P5/#database-transactions","title":"Database Transactions","text":"<ul> <li>A database transaction consists of one of the following:<ul> <li>DML statements that constitute one consistent change to the data</li> <li>One DDL statement</li> <li>One data control language (DCL) statement</li> </ul> </li> </ul>"},{"location":"archive/P5/#database-transactions_1","title":"Database Transactions","text":"<ul> <li>Begins when the first DML SQL statement is executed.</li> <li>A transaction ends with one of the following events:<ul> <li>A COMMIT or ROLLBACK statement is issued.</li> <li>A DDL or DCL statement executes (automatic commit).</li> <li>The user exits SQL*Developer (or tool) normally (implicit commit in many tools).</li> <li>The system crashes (changes lost \u2014 rollback on restart).</li> </ul> </li> </ul>"},{"location":"archive/P5/#advantages-of-commit-and-rollback-statements","title":"Advantages of COMMIT and ROLLBACK Statements","text":"<p>With COMMIT and ROLLBACK statements, you can:</p> <pre><code>- **Ensure data consistency**  \nAll changes in a transaction succeed together or are undone completely (atomicity).\n\n- **Preview data changes before making changes permanent**  \nExecute DML statements, query the results, and decide whether to commit or rollback.\n\n- **Group logically related operations**  \nTreat multiple DML statements as a single logical unit of work.\n</code></pre>"},{"location":"archive/P5/#controlling-transactions","title":"Controlling Transactions","text":""},{"location":"archive/P5/#rolling-back-changes-to-a-marker","title":"Rolling Back Changes to a Marker","text":"<ul> <li>Create a marker in a current transaction by using the SAVEPOINT statement.</li> <li>Roll back to that marker by using the ROLLBACK TO SAVEPOINT statement.</li> </ul>"},{"location":"archive/P5/#implicit-transaction-processing","title":"Implicit Transaction Processing","text":"<ul> <li> <p>An automatic commit occurs under the following circumstances:</p> <ul> <li>DDL statement is issued</li> <li>DCL statement is issued</li> <li>Normal exit from SQL Developer, without explicitly issuing COMMIT or ROLLBACK statements</li> </ul> </li> <li> <p>An automatic rollback occurs under an abnormal termination of SQL Developer or a system failure.</p> </li> </ul>"},{"location":"archive/P5/#state-of-the-data-before-commit-or-rollback","title":"State of the Data Before COMMIT or ROLLBACK","text":"<ul> <li>The previous state of the data can be recovered.</li> <li>The current user can review the results of the DML operations by using the SELECT statement.</li> <li>Other users cannot view the results of the DML statements by the current user.</li> <li>The affected rows are locked; other users cannot change the data in the affected rows.</li> </ul>"},{"location":"archive/P5/#state-of-the-data-after-commit","title":"State of the Data After COMMIT","text":"<p>After issuing a COMMIT:</p> <ul> <li>Data changes are made permanent in the database.</li> <li>The previous state of the data is permanently lost.</li> <li>All users can view the results.</li> <li>Locks on the affected rows are released; those rows are available for other users to manipulate.</li> <li>All savepoints are erased.</li> </ul>"},{"location":"archive/P5/#committing-data","title":"Committing Data","text":"<p>Step 1: Make the Changes</p> <pre><code>DELETE FROM employees\nWHERE employee_id = 99999;\n\nINSERT INTO departments\nVALUES (290, 'Corporate Tax', NULL, 1700);\n</code></pre> <p>Step 2: Commit the Changes</p> <pre><code>COMMIT;\n</code></pre>"},{"location":"archive/P5/#state-of-the-data-after-rollback","title":"State of the Data After ROLLBACK","text":"<ul> <li>Discard all pending changes by using the ROLLBACK statement:<ul> <li>Data changes are undone.</li> <li>Previous state of the data is restored.</li> <li>Locks on the affected rows are released.</li> </ul> </li> </ul> <pre><code>DELETE FROM copy_emp;\n-- 22 rows deleted.\n\nROLLBACK;\n-- Rollback complete.\n</code></pre>"},{"location":"archive/P5/#state-of-the-data-after-rollback_1","title":"State of the Data After ROLLBACK","text":"<pre><code>DELETE FROM test;               -- ups!, it's a mistake\n-- 25,000 rows deleted.\n\nROLLBACK;                       -- correct the mistake\n-- Rollback complete.\n\nDELETE FROM test WHERE id = 100;  -- it's ok\n-- 1 row deleted.\n\nSELECT * FROM test WHERE id = 100;\n-- No rows selected.  (row successfully removed)\n\nCOMMIT;                           -- make it permanent\n-- Commit complete.\n</code></pre>"},{"location":"archive/P5/#statement-level-rollback","title":"Statement-Level Rollback","text":"<ul> <li>If a single DML statement fails during execution, only that statement is rolled back.</li> <li>The Oracle server implements an implicit savepoint.</li> <li>All other changes (previous successful statements in the transaction) are retained.</li> <li>The user should terminate transactions explicitly by executing a COMMIT or ROLLBACK statement.</li> </ul>"},{"location":"archive/P5/#read-consistency","title":"Read Consistency","text":"<ul> <li>Read consistency guarantees a consistent view of the data at all times.</li> <li>Changes made by one user do not conflict with changes made by another user.</li> <li>Read consistency ensures that on the same data:<ul> <li>Readers do not wait for writers</li> <li>Writers do not wait for readers</li> </ul> </li> </ul>"},{"location":"archive/P5/#database-objects","title":"Database Objects","text":"Object Description Table Basic unit of storage; composed of rows and columns View Logically represents subsets of data from one or more tables Sequence Generates numeric values (e.g., for auto-incrementing IDs) Index Improves the performance of some queries Synonym Gives alternative names to objects"},{"location":"archive/P5/#naming-rules-for-database-objects","title":"Naming Rules for Database Objects","text":"<ul> <li>Must begin with a letter (A\u2013Z or a\u2013z).</li> <li>Must be 1\u201330 characters long (Oracle 12.2 and later: up to 128 bytes for most objects).</li> <li>Must contain only:<ul> <li>Alphanumeric characters (A\u2013Z, a\u2013z, 0\u20139)</li> <li>Underscore (<code>_</code>)</li> <li>Dollar sign (<code>$</code>)</li> <li>Pound sign (<code>#</code>)</li> </ul> </li> <li>Must not duplicate the name of another object owned by the same user.</li> <li>Must not be an Oracle server reserved word (e.g., SELECT, TABLE, FROM).</li> </ul>"},{"location":"archive/P5/#create-table-statement","title":"CREATE TABLE Statement","text":"<p>You must have:</p> <ul> <li>CREATE TABLE privilege</li> <li>A storage area (quota in a tablespace)</li> </ul> <pre><code>CREATE TABLE [schema.]table\n    (column datatype [DEFAULT expr] [, ...]);\n</code></pre> <p>What You Specify - Table name - Column name, column data type, and column size</p>"},{"location":"archive/P5/#referencing-another-users-tables","title":"Referencing Another User's Tables","text":"<ul> <li>Tables belonging to other users are not in the user's schema.</li> <li>You should use the owner's name as a prefix to those tables.</li> </ul> <p>This is called schema-qualified table reference.</p> <pre><code>SELECT * FROM schema_name.table_name;\n</code></pre>"},{"location":"archive/P5/#default-option","title":"DEFAULT Option","text":"<ul> <li>Specify a default value for a column during an INSERT.</li> <li>If no value is provided for the column in the INSERT, the default is used automatically.</li> </ul> <pre><code>column_name datatype DEFAULT expression\n</code></pre> <ul> <li>Literal values, expressions, or SQL functions are legal values.</li> <li>Another column's name or a pseudocolumn are illegal values.</li> <li>The default data type must match the column data type (Oracle performs implicit conversion if possible).</li> </ul> <pre><code>CREATE TABLE hire_dates\n    (id          NUMBER(8),\n     hire_date   DATE DEFAULT SYSDATE);\n</code></pre>"},{"location":"archive/P5/#creating-tables","title":"Creating Tables","text":"<p>Create the Table</p> <pre><code>CREATE TABLE dept\n    (deptno      NUMBER(2),\n     dname       VARCHAR2(14),\n     loc         VARCHAR2(13),\n     create_date DATE DEFAULT SYSDATE);\n</code></pre> <p>Confirm Table Creation</p> <pre><code>DESCRIBE dept; -- not SQL Statement\n</code></pre> <p></p>"},{"location":"archive/P5/#data-types","title":"Data Types","text":"<p>Oracle provides a variety of data types to store different kinds of information efficiently.</p> Data Type Description VARCHAR2(size) Variable-length character data (up to 4000 bytes; size in bytes or characters) CHAR(size) Fixed-length character data (padded with spaces; up to 2000 bytes) NUMBER(p, s) Variable-length numeric data (p = precision, s = scale) DATE Date and time values (century to seconds) LONG Variable-length character data (up to 2 GB) \u2014 deprecated CLOB Character large object (up to 4 GB) RAW and LONG RAW Raw binary data (deprecated) BLOB Binary large object (up to 4 GB) BFILE Binary data stored in an external file (up to 4 GB) ROWID A base-64 number system representing the unique address of a row in its table"},{"location":"archive/P5/#date-and-interval-types","title":"Date and Interval Types","text":"Data Type Description TIMESTAMP Date with fractional seconds INTERVAL YEAR TO MONTH Stored as an interval of years and months INTERVAL DAY TO SECOND Stored as an interval of days, hours, minutes, and seconds"},{"location":"archive/P5/#datetime-data-types","title":"Datetime Data Types","text":"<ul> <li>The TIMESTAMP data type is an extension of the DATE data type.</li> <li>It stores the year, month, and day of the DATE data type plus hour, minute, and second values as well as the fractional second value.</li> <li>You can optionally specify the time zone.</li> </ul> Data Type Description TIMESTAMP [(fractional_seconds_precision)] Stores date, time, and fractional seconds (precision 0\u20139, default 6) TIMESTAMP [(fractional_seconds_precision)] WITH TIME ZONE Includes time zone offset (e.g., +05:30) or time zone region name TIMESTAMP [(fractional_seconds_precision)] WITH LOCAL TIME ZONE Stores in database time zone, automatically converts to user\u2019s local time zone on retrieval"},{"location":"archive/P5/#interval-data-types","title":"Interval Data Types","text":"<p>Oracle provides interval data types to store periods of time.</p>"},{"location":"archive/P5/#interval-year-to-month","title":"INTERVAL YEAR TO MONTH","text":"<ul> <li>Stores a period of time using the YEAR and MONTH datetime fields.</li> </ul> <pre><code>INTERVAL YEAR [(year_precision)] TO MONTH\n</code></pre>"},{"location":"archive/P5/#interval-day-to-second","title":"INTERVAL DAY TO SECOND","text":"<ul> <li>Stores a period of time in terms of days, hours, minutes, and seconds.</li> </ul> <pre><code>INTERVAL DAY [(day_precision)] TO SECOND [(fractional_seconds_precision)]\n</code></pre>"},{"location":"archive/P5/#including-constraints","title":"Including Constraints","text":"<ul> <li>Constraints enforce rules at the table level.</li> <li>Constraints prevent the deletion of a table if there are dependencies.</li> <li>They ensure data integrity by restricting what data can be inserted, updated, or deleted.</li> </ul>"},{"location":"archive/P5/#valid-constraint-types","title":"Valid Constraint Types","text":"Constraint Type Description Example Use Case NOT NULL Column cannot contain NULL values email, last_name UNIQUE All values in the column (or combination) must be unique employee_id (if not PK), email PRIMARY KEY Combines NOT NULL + UNIQUE; uniquely identifies each row employee_id, dept_id FOREIGN KEY Enforces referential integrity \u2014 value must exist in referenced table/key department_id references departments(dept_id) CHECK Ensures column value satisfies a specific condition salary &gt; 0, job_id IN ('SA_REP','IT_PROG')"},{"location":"archive/P5/#constraint-guidelines","title":"Constraint Guidelines","text":"<ul> <li>You can name a constraint, or the Oracle server generates a name by using the SYS_Cn format.</li> <li>Create a constraint at either of the following times:<ul> <li>At the same time as the table is created</li> <li>After the table has been created</li> </ul> </li> <li>Define a constraint at the column or table level.</li> <li>View a constraint in the data dictionary.</li> </ul>"},{"location":"archive/P5/#defining-constraints","title":"Defining Constraints","text":"<pre><code>CREATE TABLE [schema.]table\n(\n    column datatype [DEFAULT expr]\n        [column_constraint],\n    ...\n    [table_constraint] [, ...]\n);\n</code></pre> <p>Column-Level Constraint</p> <pre><code>column [CONSTRAINT constraint_name] constraint_type\n</code></pre> <pre><code>CREATE TABLE employees (\n    employee_id NUMBER(6)\n        CONSTRAINT emp_emp_id_pk PRIMARY KEY,\n    first_name  VARCHAR2(20),\n    ...\n);\n</code></pre> <p>Table-Level Constraint</p> <pre><code>[CONSTRAINT constraint_name] constraint_type (column [, ...])\n</code></pre> <pre><code>CREATE TABLE employees (\n    employee_id NUMBER(6),\n    first_name  VARCHAR2(20),\n    ...\n    job_id      VARCHAR2(10) NOT NULL,\n    CONSTRAINT emp_emp_id_pk PRIMARY KEY (employee_id)\n);\n</code></pre>"},{"location":"archive/P5/#not-null-constraint","title":"NOT NULL Constraint","text":"<ul> <li>Ensures that null values are not permitted for the column.</li> </ul>"},{"location":"archive/P5/#unique-constraint","title":"UNIQUE Constraint","text":""},{"location":"archive/P5/#primary-key-constraint","title":"PRIMARY KEY Constraint","text":""},{"location":"archive/P5/#foreign-key-constraint","title":"FOREIGN KEY Constraint","text":""},{"location":"archive/P5/#foreign-key-constraint-keywords","title":"FOREIGN KEY Constraint: Keywords","text":"<ul> <li>FOREIGN KEY: Defines the column in the child table at the table-constraint level</li> <li>REFERENCES: Identifies the table and column in the parent table</li> <li>ON DELETE CASCADE: Deletes the dependent rows in the child table when a row in the parent table is deleted</li> <li>ON DELETE SET NULL: Converts dependent foreign key values to null</li> </ul>"},{"location":"archive/P5/#check-constraint","title":"CHECK Constraint","text":"<ul> <li>Defines a condition that each row must satisfy</li> <li>The following expressions are not allowed:<ul> <li>References to CURRVAL, NEXTVAL, LEVEL, and ROWNUM pseudocolumns</li> <li>Calls to SYSDATE, UID, USER, and USERENV functions</li> <li>Queries that refer to other values in other rows</li> </ul> </li> </ul> <pre><code>..., salary NUMBER(2)\n    CONSTRAINT emp_salary_min\n    CHECK (salary &gt; 0), ...\n</code></pre>"},{"location":"archive/P5/#violating-constraints-1","title":"Violating Constraints 1","text":"<pre><code>UPDATE employees\nSET    department_id = 55\nWHERE  department_id = 110;\n</code></pre> <pre><code>UPDATE employees\n*\nERROR at line 1:\nORA-02291: integrity constraint (HR.EMP_DEPT_FK)\nviolated - parent key not found\n</code></pre> <p>Department 55 does not exist.</p>"},{"location":"archive/P5/#violating-constraints-2","title":"Violating Constraints 2","text":"<ul> <li>You cannot delete a row that contains a primary key that is used as a foreign key in</li> </ul> <pre><code>DELETE FROM departments\nWHERE  department_id = 60;\n</code></pre> <pre><code>DELETE FROM departments\n*\nERROR at line 1:\nORA-02292: integrity constraint (HR.EMP_DEPT_FK)\nviolated - child record found\n</code></pre>"},{"location":"archive/P5/#creating-a-table-by-using-a-subquery","title":"Creating a Table by Using a Subquery","text":"<ul> <li>Create a table and insert rows by combining the <code>CREATE TABLE</code> statement and the <code>AS subquery</code> option.</li> </ul> <pre><code>CREATE TABLE table\n    [(column, column...)]\nAS subquery;\n</code></pre> <ul> <li>Match the number of specified columns to the number of subquery columns.</li> <li>Define columns with column names and default values.</li> </ul>"},{"location":"archive/P5/#creating-a-table-by-using-a-subquery_1","title":"Creating a Table by Using a Subquery","text":"<pre><code>CREATE TABLE dept80\nAS\n    SELECT  employee_id, last_name,\n            salary*12 ANNSAL,\n            hire_date\n    FROM    employees\n    WHERE   department_id = 80;\n</code></pre>"},{"location":"archive/P5/#alter-table-statement","title":"ALTER TABLE Statement","text":"<ul> <li>Use the ALTER TABLE statement to:<ul> <li>Add a new column</li> <li>Modify an existing column</li> <li>Define a default value for the new column</li> <li>Drop a column</li> </ul> </li> </ul>"},{"location":"archive/P5/#dropping-a-table","title":"Dropping a Table","text":"<ul> <li>All data and structure in the table are deleted.</li> <li>Any pending transactions are committed.</li> <li>All indexes are dropped.</li> <li>All constraints are dropped.</li> <li>You cannot roll back the DROP TABLE statement.</li> </ul> <pre><code>DROP TABLE dept80;\n</code></pre>"},{"location":"archive/P5/#what-is-a-view","title":"What is a VIEW?","text":"<p>You can present logical subsets or combinations of data by creating views of tables.</p> <p>A view is a logical table based on a table or another view.</p> <p>A view contains no data of its own but is like a window through which data from tables can be viewed or changed.</p> <p>The tables on which a view is based are called base tables. The view is stored as a SELECT statement in the data dictionary.</p>"},{"location":"archive/P5/#advantages-of-views","title":"Advantages of Views","text":""},{"location":"archive/P5/#simple-views-and-complex-views","title":"Simple Views and Complex Views","text":"Feature Simple Views Complex Views Number of tables One One or more Contain functions No Yes Contain groups of data No Yes DML operations through a view Yes Not always"},{"location":"archive/P5/#creating-a-view","title":"Creating a View","text":"<ul> <li>You embed a subquery in the CREATE VIEW statement:</li> </ul> <pre><code>CREATE [OR REPLACE] [FORCE|NOFORCE] VIEW view\n    [(alias[, alias]...)]\nAS subquery\n[WITH CHECK OPTION [CONSTRAINT constraint]]\n[WITH READ ONLY [CONSTRAINT constraint]];\n</code></pre> <ul> <li>The subquery can contain complex SELECT syntax.</li> </ul> <p>Create the EMPVU80 view, which contains details of employees in department 80:</p> <pre><code>CREATE VIEW empvu80\nAS SELECT  employee_id, last_name, salary\n   FROM    employees\n   WHERE   department_id = 80;\n\nView created.\n</code></pre> <p>Describe the structure of the view by using the SQL*Plus DESCRIBE command:</p> <pre><code>DESCRIBE empvu80\n</code></pre> <p>Retrieving Data from a View</p> <pre><code>SELECT *\nFROM   salvu50;\n</code></pre>"},{"location":"archive/P5/#modifying-a-view","title":"Modifying a View","text":"<ul> <li>Modify the EMPVU80 view by using a CREATE OR REPLACE VIEW clause. Add an alias for each column name:</li> </ul> <pre><code>CREATE OR REPLACE VIEW empvu80\n    (id_number, name, sal, department_id)\nAS SELECT  employee_id, first_name || ' ' || last_name, salary, department_id\n   FROM    employees\n   WHERE   department_id = 80;\n\nView created.\n</code></pre> <p>Column aliases in the CREATE OR REPLACE VIEW clause are listed in the same order as the columns in the subquery.</p>"},{"location":"archive/P5/#creating-a-complex-view","title":"Creating a Complex View","text":"<ul> <li>Create a complex view that contains group functions to display values from two tables:</li> </ul> <pre><code>CREATE OR REPLACE VIEW dept_sum_vu\n    (name, minsal, maxsal, avgsal)\nAS SELECT   d.department_name, MIN(e.salary),\n            MAX(e.salary), AVG(e.salary)\n   FROM     employees e JOIN departments d\n            ON (e.department_id = d.department_id)\n   GROUP BY d.department_name;\n</code></pre>"},{"location":"archive/P5/#rules-for-performing-dml-operations-on-a-view","title":"Rules for Performing DML Operations on a View","text":"<ul> <li>You can usually perform DML operations on simple views.</li> <li>You cannot remove a row if the view contains the following:<ul> <li>Group functions</li> <li>A GROUP BY clause</li> <li>The DISTINCT keyword</li> <li>The pseudocolumn ROWNUM keyword</li> </ul> </li> <li>You cannot modify data in a view if it contains:<ul> <li>Group functions</li> <li>A GROUP BY clause</li> <li>The DISTINCT keyword</li> <li>The pseudocolumn ROWNUM keyword</li> <li>Columns defined by expressions</li> </ul> </li> <li>You cannot add data through a view if the view includes:<ul> <li>Group functions</li> <li>A GROUP BY clause</li> <li>The DISTINCT keyword</li> <li>The pseudocolumn ROWNUM keyword</li> <li>Columns defined by expressions</li> <li>NOT NULL columns in the base tables that are not selected by the view</li> </ul> </li> </ul>"},{"location":"archive/P5/#using-the-with-check-option-clause","title":"Using the WITH CHECK OPTION Clause","text":"<ul> <li>You can ensure that DML operations performed on the view stay in the domain of the view by using the WITH CHECK OPTION clause:</li> </ul> <pre><code>CREATE OR REPLACE VIEW empvu20\nAS SELECT *\n   FROM   employees\n   WHERE  department_id = 20\n   WITH CHECK OPTION CONSTRAINT empvu20_ck;\n</code></pre> <p>Any attempt to change the department number for any row in the view fails because it violates the WITH CHECK OPTION constraint.</p>"},{"location":"archive/P5/#denying-dml-operations","title":"Denying DML Operations","text":"<ul> <li>You can ensure that no DML operations occur by adding the WITH READ ONLY option to your view definition.</li> <li>Any attempt to perform a DML operation on any row in the view results in an Oracle server error.</li> </ul> <pre><code>CREATE OR REPLACE VIEW empvu10\n    (employee_number, employee_name, job_title)\nAS SELECT  employee_id, last_name, job_id\n   FROM    employees\n   WHERE   department_id = 10\n   WITH READ ONLY;\n</code></pre>"},{"location":"archive/P5/#removing-a-view","title":"Removing a View","text":"<ul> <li>You can remove a view without losing data because a view is based on underlying tables in the database.</li> </ul> <pre><code>DROP VIEW view;\n</code></pre>"},{"location":"archive/P5/#relation-algebra","title":"Relation Algebra","text":""},{"location":"archive/P5/#a-relational-algebra-calculator-relax","title":"A relational algebra calculator - RelaX","text":"<ul> <li>https://dbis-uibk.github.io/relax/landing</li> <li>An online tool designed to help users learn and practice relational algebra by executing queries and visualizing the results</li> <li>How to create relations and insert tuples into them:<ol> <li>Click on 'Group Editor' tab</li> <li>Copy into 'Group Editor' window your data. Find below my examples!</li> <li>Click on \"preview\" button then double click on \"use Group in editor\" button</li> <li>Now you can run your queries clicking on 'Relational Algebra' or 'SQL' tab.</li> </ol> </li> <li>This implementation allows only sets and not multisets.</li> <li>There are differences between Oracle and Relax SQL syntax.</li> <li>Name of a relation is case-sensitive.</li> </ul>"},{"location":"archive/P5/#relax-example","title":"RelaX Example","text":""},{"location":"archive/P6/","title":"RelaX Website","text":"<p>(Free online tool to practice relational algebra expressions with instant results and SQL comparison.)</p>"},{"location":"archive/P6/#core-relational-algebra","title":"Core Relational Algebra","text":"<ul> <li>Union, intersection, and difference.<ul> <li>Usual set operations, but both operands must have the same relation schema.</li> </ul> </li> <li>Selection: picking certain rows.</li> <li>Projection: picking certain columns.</li> <li>Products and joins: compositions of relations.</li> <li>Renaming of relations and attributes.</li> </ul>"},{"location":"archive/P6/#union-intersection-difference","title":"Union, intersection, difference","text":"<ul> <li>\\( R \\cup S \\)<ul> <li><code>SELECT ... UNION SELECT ...;</code></li> <li>(Duplicate elimination: UNION ALL: multiset, UNION: set)</li> </ul> </li> <li>\\( R \\cap S \\)<ul> <li><code>SELECT ... INTERSECT SELECT ...;</code></li> </ul> </li> <li>\\( R - S \\)<ul> <li><code>SELECT ... MINUS SELECT ...;</code></li> <li>(Some DBMS uses EXCEPT)</li> </ul> </li> </ul>"},{"location":"archive/P6/#selection","title":"Selection","text":"<ul> <li>\\( R1 := \\sigma_{C}(R2) \\)<ul> <li>\\( C \\) is a condition (as in \"if\" statements) that refers to attributes of \\( R2 \\).</li> <li>\\( R1 \\) is all those tuples of \\( R2 \\) that satisfy \\( C \\).</li> <li><code>SELECT * FROM R2 WHERE C;</code></li> </ul> </li> </ul>"},{"location":"archive/P6/#projection","title":"Projection","text":"<ul> <li>\\( R1 := \\pi_{L}(R2) \\)<ul> <li>\\( L \\) is a list of attributes from the schema of \\( R2 \\).</li> <li>\\( R1 \\) is constructed by looking at each tuple of \\( R2 \\), extracting the attributes on list \\( L \\), in the order specified, and creating from those components a tuple for \\( R1 \\).</li> <li>Eliminate duplicate tuples, if any.</li> <li><code>SELECT DISTINCT L FROM R2;</code></li> </ul> </li> </ul>"},{"location":"archive/P6/#extended-projection","title":"Extended Projection","text":"<ul> <li>Using the same \\( \\pi_L \\) operator, we allow the list \\( L \\) to contain arbitrary expressions involving attributes:<ol> <li>Arithmetic on attributes, e.g., \\( A+B \\rightarrow C \\).</li> <li>Duplicate occurrences of the same attribute.</li> </ol> </li> <li><code>SELECT A+B AS C FROM R;</code></li> <li>(AS -&gt; optional)</li> </ul>"},{"location":"archive/P6/#product","title":"Product","text":"<ul> <li>\\( R3 := R1 \\times R2 \\)<ul> <li>Pair each tuple \\( t1 \\) of \\( R1 \\) with each tuple \\( t2 \\) of \\( R2 \\).</li> <li>Concatenation \\( t1t2 \\) is a tuple of \\( R3 \\).</li> <li>Schema of \\( R3 \\) is the attributes of \\( R1 \\) and then \\( R2 \\), in order.</li> <li>But beware attribute \\( A \\) of the same name in \\( R1 \\) and \\( R2 \\): use \\( R1.A \\) and \\( R2.A \\).</li> </ul> </li> <li><code>SELECT * FROM R1, R2;</code> or</li> <li><code>SELECT * FROM R1 CROSS JOIN R2;</code></li> </ul>"},{"location":"archive/P6/#theta-join","title":"Theta-Join","text":"<ul> <li>\\( R3 := R1 \\bowtie_{C} R2 \\)<ul> <li>Take the product \\( R1 \\times R2 \\).</li> <li>Then apply \\( \\sigma_{C} \\) to the result.</li> </ul> </li> <li>As for \\( \\sigma \\), \\( C \\) can be any boolean-valued condition.<ul> <li>Historic versions of this operator allowed only \\( A\\ \\theta\\ B \\), where \\( \\theta \\) is \\( =, &lt; \\), etc.; hence the name \"theta-join.\"</li> </ul> </li> <li><code>SELECT * FROM R1 JOIN R2 ON (C);</code></li> </ul>"},{"location":"archive/P6/#natural-join","title":"Natural Join","text":"<ul> <li>A useful join variant (natural join) connects two relations by:<ul> <li>Equating attributes of the same name, and</li> <li>Projecting out one copy of each pair of equated attributes.</li> </ul> </li> <li>Denoted \\( R3 := R1 \\bowtie R2 \\).</li> <li><code>SELECT * FROM R1 NATURAL JOIN R2;</code></li> </ul>"},{"location":"archive/P6/#renaming","title":"Renaming","text":"<ul> <li>The \\( \\rho \\) operator gives a new schema to a relation.</li> <li>\\( R1 := \\rho_{R1(A1, ..., An)}(R2) \\) makes \\( R1 \\) be a relation with attributes \\( A1, ..., An \\) and the same tuples as \\( R2 \\).</li> <li>Simplified notation: \\( R1(A1, ..., An) := R2 \\).</li> <li><code>SELECT X1 A1, X2 A2, ... Xn An FROM R2;</code></li> <li><code>CREATE TABLE R1 AS SELECT X1 A1, X2 A2, ... Xn An FROM R2;</code></li> </ul>"},{"location":"archive/P6/#sequences-of-assignments","title":"Sequences of Assignments","text":"<ul> <li>Create temporary relation names.</li> <li>Renaming can be implied by giving relations a list of attributes.</li> <li>Example: \\( R3 := R1 \\bowtie_{C} R2 \\) can be written:<ul> <li>\\( R4 := R1 \\times R2 \\) (<code>CREATE TABLE R4 ...</code>)</li> <li>\\( R3 := \\sigma_{C}(R4) \\) (<code>SELECT ... FROM R4 ...</code>)</li> </ul> </li> </ul>"},{"location":"archive/P6/#expressions-in-a-single-assignment","title":"Expressions in a Single Assignment","text":"<ul> <li>Example: the theta-join \\( R3 := R1 \\bowtie_{C} R2 \\) can be written:<ul> <li>\\( R3 := \\sigma_{C}(R1 \\times R2) \\)</li> </ul> </li> <li>Precedence of relational operators:<ol> <li>\\( [\\sigma, \\pi, \\rho] \\) (highest).</li> <li>\\( [\\times, \\bowtie] \\).</li> <li>\\( \\cap \\).</li> <li>\\( [\\cup, -] \\).</li> </ol> </li> </ul>"},{"location":"archive/P6/#the-extended-algebra","title":"The Extended Algebra","text":"<ul> <li>\\( \\pi_{L} \\) extended projection</li> <li>\\( \\delta \\) = eliminate duplicates from bags.</li> <li>\\( \\tau \\) = sort tuples.</li> <li>\\( \\gamma \\) = grouping and aggregation.</li> <li>Outerjoin: avoids \"dangling tuples\" = tuples that do not join with anything.</li> </ul>"},{"location":"archive/P6/#extended-projection_1","title":"Extended Projection","text":"<ul> <li>Using the same \\( \\pi_{L} \\) operator, we allow the list \\( L \\) to contain arbitrary expressions involving attributes:<ol> <li>Arithmetic on attributes, e.g., \\( A+B \\rightarrow C \\)<ul> <li>\"\u2192\" stands for renaming the attribute in the result to \"\\( C \\)\"</li> </ul> </li> <li>Duplicate occurrences of the same attribute.</li> </ol> </li> <li><code>SELECT A+B AS C FROM R;</code></li> <li>(\"AS\" is optional)</li> </ul>"},{"location":"archive/P6/#duplicate-elimination","title":"Duplicate Elimination","text":"<ul> <li>\\( R1 := \\delta(R2) \\).</li> <li>\\( R1 \\) consists of one copy of each tuple that appears in \\( R2 \\) one or more times.</li> </ul>"},{"location":"archive/P6/#sorting","title":"Sorting","text":"<ul> <li>\\( R1 := \\tau_{L}(R2) \\).<ul> <li>\\( L \\) is a list of some of the attributes of \\( R2 \\).</li> </ul> </li> <li>\\( R1 \\) is the list of tuples of \\( R2 \\) sorted first on the value of the first attribute on \\( L \\), then on the second attribute of \\( L \\), and so on.<ul> <li>Break ties arbitrarily.</li> </ul> </li> <li>\\( \\tau \\) is the only operator whose result is neither a set nor a bag.</li> </ul>"},{"location":"archive/P6/#aggregation-operators","title":"Aggregation Operators","text":"<ul> <li>Aggregation operators are not operators of relational algebra.</li> <li>Rather, they apply to entire columns of a table and produce a single result.</li> <li>The most important examples: SUM, AVG, COUNT, MIN, and MAX.<ul> <li>Example with Table \\( R(A, B) \\):<ul> <li>\\( SUM(A) = 7 \\)</li> <li>\\( COUNT(A) = 3 \\)</li> <li>\\( MAX(B) = 4 \\)</li> <li>\\( AVG(B) = 3 \\)</li> </ul> </li> </ul> </li> </ul>"},{"location":"archive/P6/#grouping-operator","title":"Grouping Operator","text":"<ul> <li>\\( R1 := \\gamma_{L}(R2) \\). \\( L \\) is a list of elements that are either:<ol> <li>Individual (grouping) attributes.</li> <li>\\( AGG(A) \\), where \\( AGG \\) is one of the aggregation operators and \\( A \\) is an attribute.<ul> <li>An arrow and a new attribute name renames the component.</li> </ul> </li> </ol> </li> </ul>"},{"location":"archive/P6/#applying-gamma-l-r","title":"Applying \\( \\gamma\\ L\\ (R) \\)","text":"<ul> <li>Group \\( R \\) according to all the grouping attributes on list \\( L \\).<ul> <li>That is: form one group for each distinct list of values for those attributes in \\( R \\).</li> </ul> </li> <li>Within each group, compute \\( AGG(A) \\) for each aggregation on list \\( L \\).</li> <li>Result has one tuple for each group:<ol> <li>The grouping attributes and</li> <li>Their group\u2019s aggregations.</li> </ol> </li> </ul>"},{"location":"archive/P6/#outer-join","title":"Outer join","text":"<ul> <li>Suppose we join \\( R \\bowtie_{C} S \\).</li> <li>A tuple of \\( R \\) that has no tuple of \\( S \\) with which it joins is said to be dangling.<ul> <li>Similarly for a tuple of \\( S \\).</li> </ul> </li> <li>Outerjoin preserves dangling tuples by padding them NULL.</li> </ul>"},{"location":"archive/P6/#examples","title":"Examples","text":"Relational Algebra Expression SQL Equivalent \\( \\pi_{A, B+C \\rightarrow X}(R) \\) <code>SELECT A, B+C AS X FROM R;</code> \\( \\delta(R) \\) <code>SELECT DISTINCT * FROM R;</code> \\( R \\cup S \\) <code>SELECT * FROM R UNION ALL SELECT * FROM S;</code> (multiset) \\( R \\cap S \\) <code>SELECT * FROM R INTERSECT ALL SELECT * FROM S;</code> (!) \\( R - S \\) <code>SELECT * FROM R MINUS ALL SELECT * FROM S;</code> (!) \\( \\delta(R \\cup S) \\) <code>SELECT * FROM R UNION SELECT * FROM S;</code> (set) \\( \\delta(R \\cap S) \\) <code>SELECT * FROM R INTERSECT SELECT * FROM S;</code> (set) \\( \\delta(R) - \\delta(S) \\) <code>SELECT * FROM R MINUS SELECT * FROM S;</code> (set) \\( R \\bowtie S \\) <code>SELECT * FROM R NATURAL JOIN S;</code> \\( R \\bowtie_{\\theta} S \\) <code>SELECT * FROM R JOIN S ON (\\theta);</code> \\( R \\times S \\) <code>SELECT * FROM R CROSS JOIN S;</code> or <code>SELECT * FROM R, S;</code> \\( \\gamma_{A, SUM(B)}(R) \\) <code>SELECT A, SUM(B) FROM R GROUP BY A;</code> \\( \\gamma_{A, COUNT(B)}(\\delta \\pi_{A,B} R) \\) <code>SELECT A, COUNT(DISTINCT B) FROM R GROUP BY A;</code> \\( \\tau_{A, B+C}(R) \\) <code>SELECT * FROM R ORDER BY A, B+C;</code> Outer join <code>SELECT * FROM R NATURAL LEFT OUTER JOIN S;</code> Outer join <code>SELECT * FROM R LEFT OUTER JOIN S ON R.B &gt; S.D;</code>"},{"location":"archive/P6/#execution-steps","title":"Execution steps","text":"<p>Execution steps of a SELECT statement expressed in relational algebra:</p> <ol> <li>Replace all usages of the temporary-tables defined in the WITH-clause.</li> <li>\\( \\bowtie \\) joins or product operations after FROM-clause.</li> <li>\\( \\sigma \\) selection based on the WHERE-clause.</li> <li>\\( \\gamma \\) creating groups and computing aggregations, based on GROUP BY-clause.</li> <li>\\( \\sigma \\) selection for the groups or tuples created from the groups, based on HAVING-clause.</li> <li>\\( \\pi \\) projection based on SELECT-clause.</li> <li>\\( \\rho \\) rename result attributes based on AS keyword.</li> <li>\\( \\cup \\cap - \\) UNION, INTERSECT, MINUS set operations.</li> <li>\\( \\delta \\) duplicate elimination if we have DISTINCT.</li> <li>\\( \\tau \\) sorting based on ORDER BY clause.</li> </ol>"},{"location":"archive/P8/","title":"Benefits of PL/SQL","text":"<p>Improved Performance</p> <p></p> <p>Parts of a PL/SQL block: declaration, executable, exception handling</p> <pre><code>set serveroutput on  -- required if we want to see the output\nDECLARE                 \n  v NUMBER := 0;\nBEGIN\n  DBMS_OUTPUT.PUT_LINE('It''s ok ...');  -- notice the double quotes\n  v := 1/v;\n  DBMS_OUTPUT.PUT_LINE('It is not ...');\nEXCEPTION\n  WHEN ZERO_DIVIDE THEN\n    DBMS_OUTPUT.PUT_LINE('Division by zero');\nEND;\n/        -- !!! Always end PL/SQL blocks with a '/' character !!!\n</code></pre> <pre>\nResults:\n---------\nIt's ok ...\nDivision by zero\n</pre>"},{"location":"archive/P8/#block-types","title":"Block Types","text":""},{"location":"archive/P8/#lexical-elements-of-the-plsql-language","title":"Lexical elements of the PL/SQL language:","text":""},{"location":"archive/P8/#delimiters-identifiers-literals-comments","title":"Delimiters, identifiers, literals, comments","text":"<p>Examples for delimiters:</p> <ul> <li>'+'   Addition operator</li> <li>':=' Assignment operator</li> <li>'&lt;&lt;'  Label delimiter (begin)</li> <li>'&gt;&gt;'  Label delimiter (end)</li> <li>'!='  Relational operator (not equal)</li> </ul>"},{"location":"archive/P8/#identifiers-can-denote-the-following-plsql-objects","title":"Identifiers can denote the following PL/SQL objects:","text":"<ul> <li>Constants, Cursors,  Exceptions, Keywords, Labels,  Packages Reserved words, Subprograms, Variables, Types</li> <li>Predefined identifiers in STANDARD package, e.g. ZERO_DIVIDE exception</li> </ul>"},{"location":"archive/P8/#literals-numeric-character-string-logical-date","title":"Literals (numeric, character, string, logical, date)","text":"<ul> <li>integer:       12</li> <li>real:          12.0</li> <li>char:          'a'</li> <li>string:      'abc', ''  (null string, actually NULL)</li> <li>logical:     TRUE, FALSE, NULL</li> <li>date:        DATE '2011-12-25' </li> </ul>"},{"location":"archive/P8/#comments-single-line-and-multiline","title":"Comments: single line and multiline","text":"<p>-- single line comment</p> <p>/ multiline    comment /</p>"},{"location":"archive/P8/#variables","title":"Variables","text":"<ul> <li> <p>PL/SQL variables:</p> <ul> <li>Scalar</li> <li>Composite</li> <li>Reference</li> <li>LOB (large objects)</li> </ul> </li> <li> <p>Non-PL/SQL variables: Bind and host variables</p> </li> </ul> <pre><code>-- we cannot put a space into delimiters ( := )\nBEGIN\n  count := count + 1;   -- correct\n  count : = count + 1;  -- incorrect\nEND;\n/\n</code></pre> <pre><code>-- DATETIME and INTERVAL literals\nDECLARE\n  d1 DATE      := DATE '1998-12-25';\n  t1 TIMESTAMP := TIMESTAMP '1997-10-22 13:01:01';\n  t2 TIMESTAMP WITH TIME ZONE :=   TIMESTAMP '1997-01-31 09:26:56.66 +02:00';\n\n  -- Three years and two months\n  -- For greater precision, use the day-to-second interval\n  i1 INTERVAL YEAR TO MONTH := INTERVAL '3-2' YEAR TO MONTH;\n\n  -- Five days, four hours, three minutes, two and 1/100 seconds\n   i2 INTERVAL DAY TO SECOND := INTERVAL '5 04:03:02.01' DAY TO SECOND;\nBEGIN\n  NULL;\nEND;\n/\n</code></pre>"},{"location":"archive/P8/#variable-initialization-and-keywords","title":"Variable Initialization and Keywords","text":"<p>Using:</p> <ul> <li>Assignment operator (:=)</li> <li>DEFAULT keyword</li> <li>NOT NULL constraint</li> </ul>"},{"location":"archive/P8/#base-scalar-datatypes","title":"Base Scalar Datatypes","text":"<ul> <li>VARCHAR2 (maximum_length)</li> <li>NUMBER [(precision, scale)]</li> <li>DATE</li> <li>CHAR [(maximum_length)]</li> <li>LONG</li> <li>LONG RAW</li> <li>BOOLEAN</li> <li>BINARY_INTEGER</li> <li>PLS_INTEGER</li> </ul> <pre><code>-- variable declarations\nDECLARE\n  part_number       NUMBER(6);     -- SQL data type\n  part_name         VARCHAR2(20);  -- SQL data type\n  in_stock          BOOLEAN;       -- PL/SQL-only data type\n  part_price        NUMBER(6,2);   -- SQL data type\n  part_description  VARCHAR2(50);  -- SQL data type\nBEGIN\n  NULL;\nEND;\n/\n</code></pre> <pre><code>-- Constant declarations\nDECLARE\n  credit_limit     CONSTANT REAL    := 5000.00;  -- SQL data type\n  max_days_in_year CONSTANT INTEGER := 366;      -- SQL data type\n  urban_legend     CONSTANT BOOLEAN := FALSE;     -- PL/SQL-only data type;\nBEGIN\n  NULL;\nEND;\n/\n</code></pre>"},{"location":"archive/P8/#declaring-boolean-variables","title":"Declaring Boolean Variables","text":"<ul> <li>Only the values TRUE, FALSE, and NULL can be assigned to a Boolean variable.</li> <li>The variables are connected by the logical operators AND, OR, and NOT.</li> <li>The variables always yield TRUE, FALSE, or NULL.</li> <li>Arithmetic, character, and date expressions can be used to return a Boolean value.</li> </ul>"},{"location":"archive/P8/#composite-datatypes","title":"Composite Datatypes","text":"<ul> <li>PL/SQL TABLES</li> <li>PL/SQL RECORDS</li> </ul> <pre><code>-- Initialization\nDECLARE\n  hours_worked    INTEGER := 40;\n  employee_count  INTEGER := 0;\n  pi     CONSTANT REAL := 3.14159;\n  radius          REAL := 1;\n  area            REAL := (pi * radius**2);\nBEGIN\n  NULL;\nEND;\n/\n</code></pre> <pre><code>-- Default initializations\nDECLARE\n  counter INTEGER;  -- initial value is NULL by default\nBEGIN\n  counter := counter + 1;  -- NULL + 1 is still NULL\n  IF counter IS NULL THEN\n    DBMS_OUTPUT.PUT_LINE('counter is NULL.');\n  END IF;\nEND;\n/\n</code></pre> <pre>\nResults:\n---------\ncounter is NULL.\n</pre> <pre><code>-- All variables will be NULL\nDECLARE\n  null_string  VARCHAR2(80) := TO_CHAR('');\n  address      VARCHAR2(80);\n  zip_code     VARCHAR2(80) := SUBSTR(address, 25, 0);\n  name         VARCHAR2(80);\n  valid        BOOLEAN      := (name != '');\nBEGIN\n  NULL;\nEND;\n/\n</code></pre> <pre><code>-- %TYPE type inheritance from a column or from other variable\n-- in case of column it doesn't inherit constraint, only data type\nDECLARE\n  v_name  emp.ename%TYPE;\nBEGIN\n  DBMS_OUTPUT.PUT_LINE('name=' || v_name);\nEND;\n/\n</code></pre> <ul> <li> <p>Declare a variable according to:</p> <ul> <li>A database column definition</li> <li>Another previously declared variable</li> </ul> </li> <li> <p>Prefix %TYPE with:</p> <ul> <li>The database table and column</li> <li>The previously declared variable name</li> </ul> </li> </ul> <pre><code>DECLARE\n  name     VARCHAR(25) NOT NULL := 'Smith';\n  surname  name%TYPE := 'Jones';               -- inherits NOT NULL constraint too\nBEGIN\n  DBMS_OUTPUT.PUT_LINE('name=' || name);\n  DBMS_OUTPUT.PUT_LINE('surname=' || surname);\nEND;\n/\n</code></pre> <pre>\nResults:\n---------\nname=Smith\nsurname=Jones\n</pre> <pre><code>-- %ROWTYPE record type inheritance (from table, view, cursor, record)\nCREATE TABLE employees_temp (\n  empid NUMBER(6) NOT NULL PRIMARY KEY,\n  deptid NUMBER(6) CONSTRAINT c_employees_temp_deptid CHECK (deptid BETWEEN 100 AND 200),\n  deptname VARCHAR2(30) DEFAULT 'Sales' );\n\nDECLARE\n  emprec  employees_temp%ROWTYPE;\nBEGIN\n  emprec.empid := NULL;         -- NOT Null constraint not inherited\n  emprec.deptid := 50;          -- Check constraint not inherited\n  DBMS_OUTPUT.PUT_LINE ('emprec.deptname: ' || emprec.deptname);  -- Initial value not inherited\nEND;\n/\n</code></pre> <pre><code>-- Error if identical names within a PL/SQL unit\nDECLARE\n  id  BOOLEAN;\n  id  VARCHAR2(5);  -- duplicate identifier\nBEGIN\n  id := FALSE;\nEND;\n/\n</code></pre>"},{"location":"archive/P8/#plsql-units-are-the-following","title":"PL/SQL units are the following:","text":"<ul> <li>PL/SQL anonymous block</li> <li>FUNCTION</li> <li>LIBRARY</li> <li>PACKAGE</li> <li>PACKAGE BODY</li> <li>PROCEDURE</li> <li>TRIGGER</li> <li>TYPE</li> <li>TYPE BODY</li> </ul> <pre><code>-- qualified names (within the procedure it refers to local identifier)\n-- 'echo' -&gt; name of a label and a procedure\nSET SERVEROUTPUT ON\n&lt;&lt;echo&gt;&gt;    -- name of a label (we can use labels to qualify PL/SQL program blocks)\nDECLARE\n  x  NUMBER := 5;\n\n  PROCEDURE echo IS   -- name of a procedure\n    x  NUMBER := 0;\n  BEGIN\n    DBMS_OUTPUT.PUT_LINE('x = ' || x);             -- output: x = 0\n    DBMS_OUTPUT.PUT_LINE('echo.x = ' || echo.x);   -- output: echo.x = 0 (variable of the procedure)\n  END;\n\nBEGIN\n  echo;\nEND;\n/\n</code></pre> <pre>\nResults:\n---------\nx = 0\necho.x = 0\n</pre> <pre><code>-- initialization of a logical variable\nDECLARE\n  done    BOOLEAN;               -- Initial value is NULL by default\n  counter NUMBER := 0;\nBEGIN\n  done := FALSE;                 -- Assign literal value\n  WHILE done != TRUE             -- Compare to literal value\n  LOOP\n    counter := counter + 1;\n    done := (counter &gt; 500);     -- Assign value of BOOLEAN expression\n  END LOOP;\n  DBMS_OUTPUT.PUT_LINE(counter);  -- output: 501\nEND;\n/\n</code></pre> <pre>\nResults:\n---------\n501\n</pre>"},{"location":"archive/P8/#operators-in-plsql","title":"Operators in PL/SQL","text":"<p>Examples:</p> <ul> <li> <p>Increment the index for a loop.</p> <ul> <li>v_count := v_count + 1;</li> </ul> </li> <li> <p>Set the value of a Boolean flag.</p> <ul> <li>v_equal := (v_n1 = v_n2);</li> </ul> </li> <li> <p>Validate an employee number if it contains a value.</p> <ul> <li>v_valid := (v_empno IS NOT NULL);</li> </ul> </li> </ul> <pre><code>-- SELECT data from a table into a variable\nset serveroutput on\nDECLARE\n  bonus   NUMBER(7,2);\nBEGIN\n  SELECT sal * 0.10 INTO bonus\n  FROM emp                        -- you need table EMP !!!\n  WHERE empno = 7900;\n  DBMS_OUTPUT.PUT_LINE('bonus = ' || TO_CHAR(bonus));\nEND;\n/\n</code></pre> <pre>\nResults:\n---------\nbonus = 95\n</pre>"},{"location":"archive/P8/#datatype-conversion","title":"Datatype Conversion","text":"<ul> <li>Convert data to comparable datatypes.</li> <li>Mixed datatypes can result in an error and affect performance.</li> <li> <p>Conversion functions:</p> </li> <li> <p>TO_CHAR</p> </li> <li>TO_DATE</li> <li>TO_NUMBER</li> </ul> <p>Example:</p> <pre><code>DECLARE\n    v_date VARCHAR2(15);\nBEGIN\n    SELECT TO_CHAR(hiredate, 'MON. DD, YYYY')\n    INTO v_date\n    FROM emp\n    WHERE empno = 7839;\nEND;\n</code></pre> <pre><code>-- Two NULLs are not equal. Neither != is TRUE for them.\nset serveroutput on\nDECLARE\n  a NUMBER := NULL;\n  b NUMBER := NULL;\nBEGIN\n  IF a = b THEN                         -- yields NULL, not TRUE\n    DBMS_OUTPUT.PUT_LINE('a = b');      -- not run\n  ELSIF a != b THEN                     -- yields NULL, not TRUE\n    DBMS_OUTPUT.PUT_LINE('a != b');     -- not run\n  ELSE\n    DBMS_OUTPUT.PUT_LINE('Can''t tell if two NULLs are equal');\n  END IF;\nEND;\n/\n</code></pre> <pre>\nResults:\n---------\nCan't tell if two NULLs are equal\n</pre> <pre><code>-- Concatenation operator ignores NULL.\nset serveroutput on\nBEGIN\n  DBMS_OUTPUT.PUT_LINE ('apple' || NULL || NULL || 'sauce');  -- output: applesauce\nEND;\n/\n</code></pre> <pre>\nResults:\n---------\napplesauce\n</pre> <pre><code>-- use brackets\nDECLARE\n  a INTEGER := 2**2*3**2;\n  b INTEGER := (2**2)*(3**2);\nBEGIN\n  DBMS_OUTPUT.PUT_LINE('a = ' || TO_CHAR(a));   -- output: a = 36\n  DBMS_OUTPUT.PUT_LINE('b = ' || TO_CHAR(b));   -- output: b = 36\nEND;\n/\n</code></pre> <pre>\nResults:\n---------\na = 36\nb = 36\n</pre> <pre><code>-- lazy evaluation\nDECLARE\n  on_hand  INTEGER := 0;\n  on_order INTEGER := 100;\nBEGIN \n  IF (on_hand = 0) OR ((on_order / on_hand) &lt; 5) THEN   -- Will not cause ZERO_DIVIDE exception\n    DBMS_OUTPUT.PUT_LINE('On hand quantity is zero.');\n  END IF;\nEND;\n/\n</code></pre> <pre>\nResults:\n---------\nOn hand quantity is zero.\n</pre>"},{"location":"archive/P8/#subtypes","title":"Subtypes","text":"<p>Unconstrained (gives only an alias for compatibility purpose)</p> <pre><code>SUBTYPE CHARACTER IS CHAR;\n</code></pre> <p>Contrained (a real subset)</p> <pre><code>SUBTYPE INTEGER IS NUMBER(38,0);\n</code></pre> <p>Predefined subtypes in STANDARD package, you can see them with the following query:</p> <pre><code>SELECT text FROM all_source WHERE type='PACKAGE' and name='STANDARD' ORDER BY line;\n</code></pre>"},{"location":"archive/P8/#examples-from-the-package","title":"Examples from the package:","text":"<pre><code>type BOOLEAN is (FALSE, TRUE);\nsubtype INTEGER is NUMBER(38,0);\nsubtype DECIMAL is NUMBER(38,0);\nsubtype BINARY_INTEGER is INTEGER range '-2147483647'..2147483647;\nsubtype NATURAL is BINARY_INTEGER range 0..2147483647;\nsubtype NATURALN is NATURAL not null;\ntype sys_refcursor is ref cursor;\n</code></pre> <pre><code>-- user-defined subtypes (record, table, type inheritance + constraint)\nDECLARE\n  SUBTYPE BirthDate IS DATE NOT NULL;         -- Based on DATE type\n  SUBTYPE Counter IS NATURAL;                 -- Based on NATURAL subtype\n\n  SUBTYPE pinteger IS PLS_INTEGER RANGE -9..9;  \n\n  TYPE NameList IS TABLE OF VARCHAR2(10);\n  SUBTYPE DutyRoster IS NameList;             -- Based on TABLE type\n\n  TYPE TimeRec IS RECORD (minutes INTEGER, hours INTEGER);\n  SUBTYPE FinishTime IS TimeRec;                -- Based on RECORD type\n  SUBTYPE ID_Num IS employees.employee_id%TYPE; -- Based on column type\nBEGIN\n  NULL;\nEND;\n/\n</code></pre> <pre><code>-- implicit conversion CHAR -&gt; NUMBER\nset serveroutput on\nDECLARE\n  V1  CHAR(10):='1234';\n  V2  NUMBER;\nBEGIN\n  V2 := V1 + 1;                          -- CHAR -&gt; NUMBER\n  DBMS_OUTPUT.PUT_LINE ('V2: ' || TO_CHAR(V2));\nEND;\n/\n</code></pre> <pre>\nResults:\n---------\nV2: 1235\n</pre> <pre><code>-- Take care of blank-padded semantics in case of CHAR data type !!!\nset serveroutput on\nDECLARE\n  last_name1 CHAR(5)  := 'BELLO';     -- no trailing blanks\n  last_name2 CHAR(10) := 'BELLO   ';  -- trailing blanks\nBEGIN\n  IF last_name1 = last_name2 THEN\n    DBMS_OUTPUT.PUT_LINE(last_name1 || '(length:'|| length(last_name1)||') equals ' ||\n    last_name2  || '(length:'|| length(last_name2)||')');\n  ELSE\n    DBMS_OUTPUT.PUT_LINE(last_name2 || ' does not equal ' || last_name1);\n  END IF;\nEND;\n/\n</code></pre> <pre>\nResults:\n---------\nBELLO(length:5) equals BELLO     (length:10)\n</pre> <pre><code>-- Using TIMESTAMP data type \n-- TIMESTAMP stores the fractional seconds\nDECLARE\n  start_time   VARCHAR2(50);\n  finish_time  VARCHAR2(50);\n  elapsed_time NUMBER(30,10);\nBEGIN\n  -- Get system time as seconds and fractional seconds past midnight:\n  SELECT TO_CHAR(SYSTIMESTAMP,'SSSSS.FF') INTO start_time FROM sys.DUAL;\n  -- Get system time again:\n  SELECT TO_CHAR(SYSTIMESTAMP,'SSSSS.FF') INTO finish_time FROM sys.DUAL;\n  elapsed_time := TO_NUMBER(finish_time, '99999.999999') \n                - TO_NUMBER(start_time, '99999.999999');\n  DBMS_OUTPUT.PUT_LINE ('Elapsed time: ' || TO_CHAR(elapsed_time,'0.999999'));\nEND;\n/\n</code></pre> <pre>\nResults:\n---------\nElapsed time:  0.000055\n</pre> <pre><code>-- simple CASE expression (this is not a statement but an expression!)\nset serveroutput on\nDECLARE\n  grade CHAR(1) := 'B';\n  appraisal VARCHAR2(20);\nBEGIN\n  appraisal :=\n    CASE grade\n      WHEN 'A' THEN 'Excellent'\n      WHEN 'B' THEN 'Very Good'\n      WHEN 'C' THEN 'Good'\n      WHEN 'D' THEN 'Fair'\n      WHEN 'F' THEN 'Poor'\n      ELSE 'No such grade'\n    END;\n    DBMS_OUTPUT.PUT_LINE ('Grade ' || grade || ' is ' || appraisal);  -- Very Good\nEND;\n/\n</code></pre> <pre>\nResults:\n---------\nGrade B is Very Good\n</pre> <pre><code>-- This form of CASE tests equality so grade = NULL will not be TRUE !!!\n-- use the other form, see in the next example below\nset serveroutput on\nDECLARE\n  grade CHAR(1); -- NULL by default\n  appraisal VARCHAR2(20);\nBEGIN\n  appraisal :=\n  CASE grade\n    WHEN NULL THEN 'No grade assigned'  -- grade = NULL\n    WHEN 'A' THEN 'Excellent'\n    WHEN 'B' THEN 'Very Good'\n    WHEN 'C' THEN 'Good'\n    WHEN 'D' THEN 'Fair'\n    WHEN 'F' THEN 'Poor'\n    ELSE 'No such grade'\n  END;\n  DBMS_OUTPUT.PUT_LINE ('Grade ' || grade || ' is: ' || appraisal);  -- No such grade\nEND;\n/\n</code></pre> <pre>\nResults:\n---------\nGrade  is: No such grade\n</pre> <pre><code>-- logical expressions after WHEN\n-- First TRUE condition will be returned\nset serveroutput on\nDECLARE\n  grade CHAR(1); -- NULL by default\n  appraisal VARCHAR2(20);\nBEGIN\n  appraisal :=\n    CASE\n      WHEN grade IS NULL THEN 'No grade assigned'\n      WHEN grade = 'A' THEN 'Excellent'\n      WHEN grade = 'B' THEN 'Very Good'\n      WHEN grade = 'C' THEN 'Good'\n      WHEN grade = 'D' THEN 'Fair'\n      WHEN grade = 'F' THEN 'Poor'\n      ELSE 'No such grade'\n    END;\n    DBMS_OUTPUT.PUT_LINE ('Grade ' || grade || ' is: ' || appraisal);  -- No grade assigned\nEND;\n/\n</code></pre>"},{"location":"archive/P8/#logic-tables","title":"Logic Tables","text":"<p>Build a simple Boolean condition with a comparison operator.</p> <p></p> <p>Any arithmetic expression containing a null value evaluates to NULL.</p>"},{"location":"archive/P8/#retrieving-data-in-plsql","title":"Retrieving Data in PL/SQL","text":"<p>Retrieve the order date and the ship date for the specified order.</p> <pre><code>DECLARE\n  v_orderdate ord.orderdate%TYPE;\n  v_shipdate ord.shipdate%TYPE;\nBEGIN\n  SELECT orderdate, shipdate\n  INTO v_orderdate, v_shipdate\n  FROM ord\n  WHERE id = 620;\n  ...\nEND;\n</code></pre>"},{"location":"archive/P8/#updating-data","title":"Updating Data","text":"<p>Increase the salary of all employees in the emp table who are Analysts.</p> <pre><code>DECLARE\n  v_sal_increase emp.sal%TYPE := 2000;\nBEGIN\n  UPDATE emp\n  SET sal = sal + v_sal_increase\n  WHERE job = 'ANALYST';\nEND;\n</code></pre>"},{"location":"archive/P8/#control-statements","title":"Control statements","text":""},{"location":"archive/P8/#if-then","title":"IF THEN","text":"<pre><code>IF condition THEN\n  statements\nEND IF;\n</code></pre>"},{"location":"archive/P8/#if-then-else","title":"IF THEN ELSE","text":"<pre><code>IF condition THEN\n  statements\nELSE\n  else_statements\nEND IF;\n</code></pre>"},{"location":"archive/P8/#if-then-elsif","title":"IF THEN ELSIF","text":"<pre><code>IF condition_1 THEN\n  statements_1\nELSIF condition_2 THEN\n  statements_2\n[ ELSIF condition_3 THEN\n    statements_3\n]...\n[ ELSE\n    else_statements\n]\nEND IF;\n</code></pre>"},{"location":"archive/P8/#simple-case-statement","title":"Simple CASE statement","text":"<p>CASE_NOT_FOUND exception if none of them is true</p> <pre><code>CASE selector \nWHEN selector_value_1 THEN statements_1\nWHEN selector_value_2 THEN statements_2\n...\nWHEN selector_value_n THEN statements_n\n[ ELSE   else_statements ]\nEND CASE;\n</code></pre>"},{"location":"archive/P8/#searched-case-statement","title":"Searched CASE statement","text":"<p>CASE_NOT_FOUND exception if none of them is true</p> <pre><code>CASE\nWHEN condition_1 THEN statements_1\nWHEN condition_2 THEN statements_2\n...\nWHEN condition_n THEN statements_n\n[ ELSE   else_statements ]\nEND CASE;\n</code></pre>"},{"location":"archive/P8/#basic-loop","title":"Basic LOOP","text":"<pre><code>[ label ] LOOP\n  statements\nEND LOOP [ label ];\n</code></pre>"},{"location":"archive/P8/#exit-from-loop-starting-a-new-iteration","title":"Exit from loop / starting a new iteration","text":"<pre><code>EXIT\nEXIT WHEN \nCONTINUE\nCONTINUE WHEN\n</code></pre>"},{"location":"archive/P8/#while-loop","title":"WHILE LOOP","text":"<pre><code>[ label ] WHILE condition LOOP\n  statements\nEND LOOP [ label ];\n</code></pre>"},{"location":"archive/P8/#for-loop","title":"FOR LOOP","text":"<pre><code>[ label ] FOR index IN [ REVERSE ] lower_bound..upper_bound LOOP\n  statements\nEND LOOP [ label ];\n</code></pre> <pre><code>BEGIN\n FOR i IN REVERSE 1..3 loop\n  dbms_output.put_line(to_char(i));\n END loop;\nEND;\n/\n</code></pre> <pre><code>-- NULL statement\nNULL;\n\n-- GOTO statement \nGOTO label\n\n-- RETURN statement (return from a subprogram or from an anonymous block)\n\nBEGIN\n FOR i IN 1..3 loop\n  dbms_output.put_line(i);\n  IF i=2 THEN RETURN; END IF;\n END loop;\nEND;\n/\n</code></pre> <pre><code>-- index of FOR loop is local within the loop\nset serveroutput on\n&lt;&lt;main&gt;&gt;  -- Label block.\nDECLARE\n  i NUMBER := 5;\nBEGIN\n  FOR i IN 1..3 LOOP\n    DBMS_OUTPUT.PUT_LINE ('local: ' || TO_CHAR(i) || ', global: ' || TO_CHAR(main.i));\n  END LOOP;\nEND main;\n/\n</code></pre> <pre>\nResults:\n---------\nlocal: 1, global: 5\nlocal: 2, global: 5\nlocal: 3, global: 5\n</pre> <pre><code>-- Loop indexes in nested loops\n/*\n- Nest loops to multiple levels.\n- Use labels to distinguish between blocks and loops.\n- Exit the outer loop with the EXIT statement referencing the label. */\nset serveroutput on\nBEGIN\n  &lt;&lt;outer_loop&gt;&gt;\n  FOR i IN 1..3 LOOP\n    &lt;&lt;inner_loop&gt;&gt;\n    FOR i IN 1..3 LOOP\n      IF outer_loop.i = 2 THEN\n        DBMS_OUTPUT.PUT_LINE('outer: ' || TO_CHAR(outer_loop.i) || ' inner: ' || TO_CHAR(inner_loop.i));\n      END IF;\n    END LOOP inner_loop;\n  END LOOP outer_loop;\nEND;\n/\n</code></pre> <pre>\nResults:\n---------\nouter: 2 inner: 1\nouter: 2 inner: 2\nouter: 2 inner: 3\n</pre> <pre><code>/*************** scope and visibility *************/\n&lt;&lt;label1&gt;&gt;\nDECLARE\n  a  NUMBER;\nBEGIN\n  a:=2;\n  &lt;&lt;label2&gt;&gt;\n  DECLARE\n    a number;\n  BEGIN\n    a:=4;\n    dbms_output.put_line(label1.a);\n    dbms_output.put_line(label2.a);\n    dbms_output.put_line(a);\n  END;\n  dbms_output.put_line(a);\nEND;\n/\n</code></pre> <pre>\nResults:\n---------\n2\n4\n4\n2\n</pre> <pre><code>/************** outer (bind) variables, it works only in SQL*PLUS environment, not in SqlDeveloper *************/\n/* program gets a pointer, so it can modify the variable*/\nVariable v number;\nBEGIN\n :v := mod(121,3);\nEND;\n/\nprint v;\n</code></pre>"},{"location":"archive/P8/#using-bind-variables","title":"Using Bind Variables","text":"<p>To reference a bind variable in PL/SQL, you must prefix its name with a colon (:).</p> <pre><code>VARIABLE g_salary NUMBER\nDECLARE\n  v_sal emp.sal%TYPE;\nBEGIN\n  SELECT sal\n  INTO v_sal\n  FROM emp\n  WHERE empno = 7369;\n  :g_salary := v_sal;\nEND;\n</code></pre> <pre><code>/************** printing on the screen *************/\nset serveroutput on\nBEGIN\n  DBMS_OUTPUT.PUT_LINE('Hello World!');\nEND;\n/\n</code></pre>"},{"location":"archive/P8/#use-set-serveroutput-on","title":"Use SET SERVEROUTPUT ON","text":"<p>A PL/SQL program actually doesn't print on the screen.</p> <p>It prints into a buffer on the server side.</p> <p>You can use GET_LINE to read from the buffer.</p> <pre><code>SET SERVEROUTPUT ON\nDECLARE\n  v_status  INTEGER := 0;\n  v_line    VARCHAR2(100); \n  v_buff    VARCHAR2(1000);\nBEGIN \n  -- We print 3 lines into the buffer.\n  DBMS_OUTPUT.PUT_LINE('1-bubu'); DBMS_OUTPUT.PUT_LINE('2-bibi'); DBMS_OUTPUT.PUT_LINE('3-baba');\n  -- We empty the buffer.\n  WHILE v_status = 0 LOOP\n    DBMS_OUTPUT.GET_LINE (v_line, v_status);\n    v_buff := v_buff || v_line;\n  END LOOP;\n  -- We print the concatenated string into the buffer.\n  DBMS_OUTPUT.PUT_LINE(v_buff);\nEND;\n/\n</code></pre> <pre>\nResults:\n---------\n1-bubu2-bibi3-baba\n</pre> <p>Runtime environment reads the buffer only after the program terminated. </p> <p>Without 'set serveroutput on' result remains in buffer.</p> <pre><code>set serveroutput off     -- notice OFF !!!\nBEGIN \n  DBMS_OUTPUT.PUT_LINE('first program');      \n  DBMS_OUTPUT.PUT_LINE('second program');     \nEND;\n/\n</code></pre> <pre><code>SET SERVEROUTPUT ON\nDECLARE\n  v_status  INTEGER := 0;\n  v_line    VARCHAR2(100); \nBEGIN \n  WHILE v_status = 0 LOOP\n    DBMS_OUTPUT.GET_LINE (v_line, v_status);       -- reads buffer\n  END LOOP;\n  DBMS_OUTPUT.PUT_LINE('second program');          -- writes into buffer\nEND;\n/\n</code></pre> <pre><code>/****************** Input from the user ****************/\n/* substitution happens before SQL statement is sent to Oracle Server */\n\nACCEPT v1 NUMBER FORMAT '99' PROMPT 'Give the department number:'\nACCEPT v2 DATE FORMAT 'yyyy.mm.dd' DEFAULT 1982.01.01 PROMPT 'Date (format: 2013.01.30)'\nset serveroutput on\nDECLARE \n  v_sum NUMBER;\nBEGIN\n  SELECT sum(sal) INTO v_sum FROM emp WHERE deptno = &amp;v1 AND hiredate &lt; to_date('&amp;v2', 'yyyy.mm.dd');\n  dbms_output.put_line(v_sum);\nEND;\n/\n</code></pre> <pre><code>/****************** records ****************/\nDECLARE\n  TYPE rektip IS RECORD(m1 INTEGER, m2 VARCHAR2(10));\n  rec rektip;\nBEGIN\n  rec.m1 := 1; rec.m2 := 'Bubu';\n  DBMS_OUTPUT. PUT_LINE(rec.m2);\nEND;\n</code></pre> <pre><code>/****************** records, arrays ****************/\nset serveroutput on\nDECLARE\n  TYPE rek_type IS RECORD(f1 INTEGER DEFAULT 10, f2 dept%ROWTYPE);  -- nested record (ROWTYPE)\n  rec rek_type;\n  TYPE tab_type IS TABLE OF INTEGER INDEX BY BINARY_INTEGER;   -- associative (index by) array\n  TYPE rek_type2 IS RECORD(f1 INTEGER, f2 tab_type);           -- nested array within a field\n  rec2 rek_type2;\n  rec_oszt dept%ROWTYPE;                                       -- a record too\nBEGIN\n rec_oszt.dname := 'SALES';\n dbms_output.put_line(rec.f1);                             -- default value of the field\n\n SELECT * INTO rec.f2 FROM dept WHERE deptno = 10;         -- rec (nested record)\n dbms_output.put_line(rec.f2.loc);\n\n rec2.f2(1) := 100; rec2.f2(2) := 200; rec2.f2(3) := 300;  -- rec2 (array within a field)\n FOR i IN rec2.f2.FIRST .. rec2.f2.LAST LOOP\n   dbms_output.put_line(rec2.f2(i));\n END LOOP;\nEND;\n/\n</code></pre> <pre>\nResults:\n---------\n10\nNEW YORK\n100\n200\n300\n</pre>"},{"location":"archive/P8/#plsql-records","title":"PL/SQL Records","text":"<ul> <li>Must contain one or more components of any scalar, RECORD, or PL/SQL TABLE datatype, called fields</li> <li>Are similar in structure to records in a 3GL</li> <li>Are not the same as rows in a database table</li> <li>Treat a collection of fields as a logical unit</li> <li>Are convenient for fetching a row of data from a table for processing</li> </ul>"},{"location":"archive/P8/#using-plsql-table-methods","title":"Using PL/SQL Table Methods","text":"<p>The following methods make PL/SQL tables easier to use:</p> <ul> <li>EXISTS</li> <li>COUNT</li> <li>FIRST and LAST</li> <li>PRIOR</li> <li>NEXT</li> <li>EXTEND</li> <li>TRIM</li> <li>DELETE</li> </ul>"},{"location":"archive/P8/#plsql-tables","title":"PL/SQL Tables","text":"<ul> <li> <p>Are composed of two components:</p> <ul> <li>Primary key of datatype BINARY_INTEGER</li> <li>Column of scalar or record datatype</li> </ul> </li> <li> <p>Increase dynamically because they are unconstrained</p> </li> </ul>"},{"location":"archive/P8/#the-rowtype-attribute","title":"The %ROWTYPE Attribute","text":"<ul> <li>Declare a variable according to a collection of columns in a database table or view.</li> <li>Prefix %ROWTYPE with the database table.</li> <li>Fields in the record take their names and datatypes from the columns of the table or view.</li> </ul>"},{"location":"archive/P9/","title":"Cursor","text":"<p>Every SQL statement executed by the Oracle Server has an individual cursor associated with it:</p> <ul> <li>Implicit cursors: Declared for all DML and PL/SQL SELECT statements</li> <li>Explicit cursors: Declared and named by the programmer</li> </ul> <p>Controlling Explicit Cursors:</p> <ul> <li>DECLARE: Create a named SQL area</li> <li>OPEN: Identify the active set</li> <li>FETCH: Load the current row into variables</li> <li>EMPTY?: Test for existing rows, return to FETCH if rows found</li> <li>CLOSE: Release the active set</li> </ul> <pre><code>-- examples for cursors (implicit and explicit cursor)\n\nset serveroutput on\nDECLARE \n  CURSOR curs1 IS SELECT deptno, ename FROM nikovits.emp WHERE deptno = 10;\n  rec curs1%ROWTYPE;\nBEGIN\n  OPEN curs1;\n  LOOP\n    FETCH curs1 INTO rec;\n    EXIT WHEN curs1%NOTFOUND;\n    dbms_output.put_line(to_char(rec.deptno)||' - '||rec.ename);\n  END LOOP;\n  CLOSE curs1;\nEND;\n/\n</code></pre> <pre>\nResults:\n-----------\n10 - MILLER\n10 - CLARK\n10 - KING\n</pre> <p>Controlling Explicit Cursors:</p> <ul> <li>Open the cursor.</li> <li>Fetch a row from the cursor.</li> <li>Continue until empty.</li> <li>Close the cursor.</li> </ul> <p>Opening the Cursor:</p> <ul> <li>Open the cursor to execute the query and identify the active set.</li> <li>If the query returns no rows, no exception is raised.</li> <li>Use cursor attributes to test the outcome after a fetch.</li> </ul> <p>Fetching Data from the Cursor:</p> <ul> <li>Retrieve the current row values into output variables.</li> <li>Include the same number of variables.</li> <li>Match each variable to correspond to the columns positionally.</li> <li>Test to see if the cursor contains rows.</li> </ul> <p>Declaring the Cursor:</p> <ul> <li>Do not include the INTO clause in the cursor declaration.</li> <li>If processing rows in a specific sequence is required, use the ORDER BY clause in the query.</li> </ul> <p>Closing the Cursor:</p> <ul> <li>Close the cursor after completing the processing of the rows.</li> <li>Reopen the cursor, if required.</li> <li>Do not attempt to fetch data from a cursor once it has been closed.</li> </ul> <p>Explicit Cursor Attributes:</p> <ul> <li>Obtain status information about a cursor.</li> <li>%ISOPEN (Boolean): Evaluates to TRUE if the cursor is open</li> <li>%NOTFOUND (Boolean): Evaluates to TRUE if the most recent fetch does not return a row</li> <li>%FOUND (Boolean): Evaluates to TRUE if the most recent fetch returns a row; complement of %NOTFOUND</li> <li>%ROWCOUNT (Number): Evaluates to the total number of rows returned so far</li> </ul> <pre><code>-- Implicit cursor (for a DELETE statement)\nset serveroutput on\nDECLARE\n  v_rows_deleted VARCHAR2(30);\n  v_job emp.job%TYPE := 'SALESMAN';\nBEGIN\n  DELETE FROM emp WHERE job = v_job;\n  v_rows_deleted := (SQL%ROWCOUNT ||' row(s) deleted.');\n  DBMS_OUTPUT.PUT_LINE (v_rows_deleted);\n  ROLLBACK;  -- rollback the transaction, we don't really want to delete\nEND;\n/\n</code></pre> <pre>\nResults:\n-----------\n5 row(s) deleted.\n</pre> <p>Cursors and Records:</p> <ul> <li>Process the rows of the active set conveniently by fetching values into a PL/SQL RECORD.</li> </ul> <p>Cursor FOR Loop:</p> <ul> <li>The cursor FOR loop is a shortcut to process explicit cursors.</li> <li>Implicit open, fetch, and close occur.</li> <li>The record is implicitly declared.</li> </ul> <p>Cursor Parameters:</p> <ul> <li>Pass parameter values to a cursor when the cursor is opened and the query is executed.</li> <li>Open an explicit cursor several times with a different active set each time.</li> </ul> <pre><code>-- Explicit cursors, 3 forms of cursor usage and cursors with parameter\nset serveroutput on\nDECLARE \n  CURSOR curs1(p_deptno NUMBER DEFAULT 10) IS SELECT ename, sal FROM emp WHERE deptno = p_deptno;\n  CURSOR curs2(p_deptno NUMBER) IS SELECT ename, sal from emp where deptno = p_deptno;\n  rec curs1%ROWTYPE;\nBEGIN\n  OPEN curs1();            -- default parameter\n  LOOP\n    FETCH curs1 INTO rec;\n    EXIT WHEN curs1%NOTFOUND;\n    dbms_output.put_line('curs1: '||rec.ename||' - '||to_char(rec.sal));\n  END LOOP;\n  CLOSE curs1;\n\n  FOR rec IN curs2(20) LOOP   -- parameter\n    dbms_output.put_line('curs2: '||rec.ename||' - '||to_char(rec.sal));\n  END LOOP;\n\n  FOR rec IN (SELECT ename, sal FROM emp WHERE deptno=30) LOOP\n    dbms_output.put_line('curs3: '||rec.ename||' - '||to_char(rec.sal));\n  END LOOP;\nEND;\n/\n</code></pre> <pre>\nResults:\n-----------\ncurs1: CLARK - 2450\ncurs1: KING - 5000\ncurs1: MILLER - 1300\ncurs2: SMITH - 800\ncurs2: JONES - 2975\ncurs2: SCOTT - 3000\ncurs2: ADAMS - 1100\ncurs2: FORD - 3000\ncurs3: ALLEN - 1600\ncurs3: WARD - 1250\ncurs3: MARTIN - 1250\ncurs3: BLAKE - 4250\ncurs3: TURNER - 1500\ncurs3: JAMES - 950\n</pre> <pre><code>-- Using a CURSOR for a WITH statement\nDECLARE \n  CURSOR curs1 IS \n  WITH\n  tmp1 AS (\n    SELECT deptno, round(AVG(sal)) dept_avg FROM emp\n    GROUP BY deptno),\n  tmp2 AS (\n    SELECT round(AVG(sal)) gen_avg FROM emp)\n  SELECT dname, dept_avg, gen_avg, dept_avg-gen_avg diff\n  FROM tmp1, tmp2, dept WHERE tmp1.deptno = dept.deptno;\n  rec curs1%ROWTYPE;\nBEGIN\n  OPEN curs1;\n  LOOP\n    FETCH curs1 INTO rec;\n    EXIT WHEN curs1%NOTFOUND;\n    dbms_output.put_line(rec.dname||' | '||rec.dept_avg||' | '||rec.diff);\n  END LOOP;\n  CLOSE curs1;\nEND;\n/\n</code></pre> <pre>\nResults:\n-----------\nACCOUNTING | 2917 | 751\nRESEARCH | 2175 | 9\nSALES | 1800 | -366\nMARKETING | 2133 | -33\n</pre> <p>Explicit Locking:</p> <ul> <li>Explicit locking lets you deny access for the duration of a transaction.</li> <li>Lock the rows before the update or delete.</li> </ul> <p>Cursor Updates and Deletes:</p> <ul> <li>Use cursors to update or delete the current row.</li> <li>Include the FOR UPDATE clause in the cursor query to lock the rows first.</li> <li>Use the WHERE CURRENT OF clause to reference the current row from an explicit cursor.</li> </ul> <pre><code>-- Update with a cursor  -&gt; WHERE CURRENT OF\n-- FOR UPDATE locks rows in the table\nDECLARE \n  CURSOR curs1 IS SELECT ename, sal FROM emp WHERE deptno = 10 FOR UPDATE;\n  rec curs1%ROWTYPE;\nBEGIN\n  OPEN curs1;\n  LOOP\n    FETCH curs1 INTO rec;\n    EXIT WHEN curs1%NOTFOUND;\n    UPDATE emp SET sal = sal + length(rec.ename) WHERE CURRENT OF curs1;\n    dbms_output.put_line(rec.ename||' - '||to_char(rec.sal));\n  END LOOP;\n  CLOSE curs1;\nEND;\n/\n</code></pre> <pre><code>SELECT ename, sal FROM emp WHERE deptno=10;  -- you can see the updated values\nROLLBACK;\nSELECT ename, sal FROM emp WHERE deptno=10;  -- old values are restored\n</code></pre> <pre><code>-- What happens when we update the table during cursor loop?\n-- answer: cursor doesn't see the new values\n-- result set will be fixed when opening the cursor\nset serveroutput on\nDECLARE\n v_date    date := SYSDATE + 1;\nBEGIN\n  FOR rec IN (SELECT * FROM dept for update) LOOP\n    dbms_output.put(to_char(sysdate, 'hh24:mi:ss')||' --&gt; ');\n    dbms_output.put_line(rec.deptno);\n    SELECT SYSDATE + 2/(24*60*60) INTO v_date FROM dual; -- 2 seconds\n    WHILE sysdate &lt; v_date LOOP  NULL;   END LOOP;   \n    update dept set deptno = deptno+1;\n  END LOOP;\nEND;\n/\n</code></pre> <pre><code>-- Cursor update for a join\n-- LOC column will be updated in each step of iteration\n-- Result set of the cursor:\n-- TURNER  SALES\n-- MARTIN  SALES\n-- WARD    SALES\n-- ALLEN   SALES\n\nDECLARE\n  CURSOR c1 IS  SELECT ename, dname  FROM emp, dept\n    WHERE emp.deptno = dept.deptno AND job = 'SALESMAN' FOR UPDATE OF loc;\nBEGIN\n  FOR rec IN c1 LOOP\n   -- UPDATE emp SET sal = sal + 1 WHERE CURRENT OF c1;\n    UPDATE dept SET loc = loc|| '1' WHERE CURRENT OF c1;\n  END LOOP;\nEND;\n/\n</code></pre> <pre><code>-- cursor variable\n-- can be strongly typed (with return type) or weakly typed (without return type)\nDECLARE \n  TYPE empcurtyp IS REF CURSOR RETURN emp%ROWTYPE;  -- strong\n  TYPE genericcurtyp IS REF CURSOR;                 -- weak\n  TYPE t_cur IS REF CURSOR;\n  v_cur t_cur;\n\n  PROCEDURE cursor_open(p_cur IN OUT t_cur) IS\n  BEGIN\n    OPEN p_cur FOR SELECT ename FROM emp WHERE sal &gt; 3000;\n  END;\n\n  FUNCTION read_cursor(p_cur IN t_cur) RETURN varchar2 IS\n    v emp.ename%TYPE;\n  BEGIN\n    FETCH p_cur INTO v;\n    RETURN v;\n  END;\nBEGIN\n  cursor_open(v_cur);\n  dbms_output.put_line(read_cursor(v_cur));\n  CLOSE v_cur;\nEND;\n/\n</code></pre> <pre>\nResults:\n-----------\nBLAKE\n</pre>"},{"location":"archive/P9/#collection","title":"Collection","text":"<ul> <li>A collection is an ordered group of elements having the same data type.</li> <li>Each element is identified by a unique subscript that represents its position in the collection.</li> <li>Associative array (or index-by table): Unbounded, String or Integer subscript, Either dense or sparse, Only in PL/SQL block, No Object Type Attribute</li> <li>Nested table: Unbounded, Integer subscript, Starts dense, can become sparse, Either in PL/SQL block or at schema level, Yes Object Type Attribute</li> <li>Variablesize array (Varray): Bounded, Integer subscript, Always dense, Either in PL/SQL block or at schema level, Yes Object Type Attribute</li> </ul> <p>PL/SQL has three collection types: </p> <ol> <li>associative array (INDEX BY ...; we call it also PL/SQL table)</li> <li>VARRAY (variable-size array), </li> <li>NESTED TABLE</li> </ol>"},{"location":"archive/P9/#collection-methods","title":"Collection methods","text":"<p>A collection method is a PL/SQL subprogram: either a function that returns information about a collection, or a procedure that operates on a collection.</p> Method Type Description DELETE Procedure Deletes elements from collection. TRIM Procedure Deletes elements from end of varray or nested table. EXTEND Procedure Adds elements to end of varray or nested table. EXISTS Function Returns TRUE if and only if specified element of varray or nested table exists. FIRST Function Returns first index in a collection. LAST Function Returns last index in a collection. COUNT Function Returns number of elements in a collection. LIMIT Function Returns maximum number of elements that a collection can have. PRIOR Function Returns the index that precedes specified index. NEXT Function Returns the index that succeeds specified index. <pre><code>/****************** record and associative array ****************/\n\nset serveroutput on\nDECLARE\n  TYPE rek_type IS RECORD(f1 INTEGER DEFAULT 10, f2 emp.ename%TYPE);     -- type declaration\n  rec rek_type;                                                          -- variable definition\n  TYPE tab_type IS TABLE OF VARCHAR2(30) INDEX BY BINARY_INTEGER;        -- associative array type\n  tab tab_type;                                                          -- variable of type assoc. array\n  rec_dept dept%ROWTYPE;                                                 -- record variable\n  TYPE tab_type2 IS TABLE OF rec_dept%ROWTYPE INDEX BY BINARY_INTEGER;   -- array of records\n  tab2 tab_type2;\nBEGIN\n  rec.f2 := 'KING';\n  dbms_output.put_line(rec.f1||' -- '||rec.f2);                          -- default value\n  tab(1) := 'Bubu'; tab(2) := 'Baba'; tab(3) := 'Bobo';\n  FOR i IN tab.FIRST .. tab.LAST LOOP\n    dbms_output.put_line(tab(i));\n  END LOOP;\n  SELECT * INTO rec_dept FROM dept WHERE deptno = 10;\n  tab2(1) := rec_dept;\n  dbms_output.put_line(tab2(1).deptno||' -- '||tab2(1).dname||' -- '||tab2(1).loc);\nEND;\n/\n</code></pre> <pre>\nResults:\n-----------\n10 -- KING\nBubu\nBaba\nBobo\n10 -- ACCOUNTING -- NEW YORK\n</pre> <p>Index-By Table:</p> <ul> <li>An index-by table (also called an associative array) is a set of key-value pairs. Each key is unique and is used to locate the corresponding value.</li> <li>The key can be either an integer or a string.</li> <li>An index-by table is created using the following syntax. Here, we are creating an index-by table named salary_list, the keys of which will be of the subscript_type and associated values will be of the element_type.</li> </ul> <p>Nested Tables:</p> <ul> <li>A nested table is like a one-dimensional array with an arbitrary number of elements. However, a nested table differs from an array in the following aspects\u2014</li> <li>An array has a declared number of elements, but a nested table does not. The size of a nested table can increase dynamically.</li> <li>An array is always dense, i.e., it always has consecutive subscripts. A nested array is dense initially, but it can become sparse when elements are deleted from it.</li> </ul>"},{"location":"pl_sql/01_PL_SQL_basics/","title":"PL/SQL Basics","text":""},{"location":"pl_sql/01_PL_SQL_basics/#benefits-of-plsql","title":"Benefits of PL/SQL","text":"<p>Improved Performance</p> <p></p> <p>Parts of a PL/SQL block: declaration, executable, exception handling</p> <pre><code>set serveroutput on  -- required if we want to see the output\nDECLARE                 \n  v NUMBER := 0;\nBEGIN\n  DBMS_OUTPUT.PUT_LINE('It''s ok ...');  -- notice the double quotes\n  v := 1/v;\n  DBMS_OUTPUT.PUT_LINE('It is not ...');\nEXCEPTION\n  WHEN ZERO_DIVIDE THEN\n    DBMS_OUTPUT.PUT_LINE('Division by zero');\nEND;\n/        -- !!! Always end PL/SQL blocks with a '/' character !!!\n</code></pre> <pre>\nResults:\n---------\nIt's ok ...\nDivision by zero\n</pre>"},{"location":"pl_sql/01_PL_SQL_basics/#block-types","title":"Block Types","text":""},{"location":"pl_sql/01_PL_SQL_basics/#lexical-elements-of-the-plsql-language","title":"Lexical elements of the PL/SQL language:","text":""},{"location":"pl_sql/01_PL_SQL_basics/#delimiters-identifiers-literals-comments","title":"Delimiters, identifiers, literals, comments","text":"<p>Examples for delimiters:</p> <ul> <li>'+'   Addition operator</li> <li>':=' Assignment operator</li> <li>'&lt;&lt;'  Label delimiter (begin)</li> <li>'&gt;&gt;'  Label delimiter (end)</li> <li>'!='  Relational operator (not equal)</li> </ul>"},{"location":"pl_sql/01_PL_SQL_basics/#identifiers-can-denote-the-following-plsql-objects","title":"Identifiers can denote the following PL/SQL objects:","text":"<ul> <li>Constants, Cursors,  Exceptions, Keywords, Labels,  Packages Reserved words, Subprograms, Variables, Types</li> <li>Predefined identifiers in STANDARD package, e.g. ZERO_DIVIDE exception</li> </ul>"},{"location":"pl_sql/01_PL_SQL_basics/#literals-numeric-character-string-logical-date","title":"Literals (numeric, character, string, logical, date)","text":"<ul> <li>integer:       12</li> <li>real:          12.0</li> <li>char:          'a'</li> <li>string:      'abc', ''  (null string, actually NULL)</li> <li>logical:     TRUE, FALSE, NULL</li> <li>date:        DATE '2011-12-25' </li> </ul>"},{"location":"pl_sql/01_PL_SQL_basics/#comments-single-line-and-multiline","title":"Comments: single line and multiline","text":"<p>-- single line comment</p> <p>/ multiline    comment /</p>"},{"location":"pl_sql/01_PL_SQL_basics/#variables","title":"Variables","text":"<ul> <li> <p>PL/SQL variables:</p> <ul> <li>Scalar</li> <li>Composite</li> <li>Reference</li> <li>LOB (large objects)</li> </ul> </li> <li> <p>Non-PL/SQL variables: Bind and host variables</p> </li> </ul> <pre><code>-- we cannot put a space into delimiters ( := )\nBEGIN\n  count := count + 1;   -- correct\n  count : = count + 1;  -- incorrect\nEND;\n/\n</code></pre> <pre><code>-- DATETIME and INTERVAL literals\nDECLARE\n  d1 DATE      := DATE '1998-12-25';\n  t1 TIMESTAMP := TIMESTAMP '1997-10-22 13:01:01';\n  t2 TIMESTAMP WITH TIME ZONE :=   TIMESTAMP '1997-01-31 09:26:56.66 +02:00';\n\n  -- Three years and two months\n  -- For greater precision, use the day-to-second interval\n  i1 INTERVAL YEAR TO MONTH := INTERVAL '3-2' YEAR TO MONTH;\n\n  -- Five days, four hours, three minutes, two and 1/100 seconds\n   i2 INTERVAL DAY TO SECOND := INTERVAL '5 04:03:02.01' DAY TO SECOND;\nBEGIN\n  NULL;\nEND;\n/\n</code></pre>"},{"location":"pl_sql/01_PL_SQL_basics/#variable-initialization-and-keywords","title":"Variable Initialization and Keywords","text":"<p>Using:</p> <ul> <li>Assignment operator (:=)</li> <li>DEFAULT keyword</li> <li>NOT NULL constraint</li> </ul>"},{"location":"pl_sql/01_PL_SQL_basics/#base-scalar-datatypes","title":"Base Scalar Datatypes","text":"<ul> <li>VARCHAR2 (maximum_length)</li> <li>NUMBER [(precision, scale)]</li> <li>DATE</li> <li>CHAR [(maximum_length)]</li> <li>LONG</li> <li>LONG RAW</li> <li>BOOLEAN</li> <li>BINARY_INTEGER</li> <li>PLS_INTEGER</li> </ul> <pre><code>-- variable declarations\nDECLARE\n  part_number       NUMBER(6);     -- SQL data type\n  part_name         VARCHAR2(20);  -- SQL data type\n  in_stock          BOOLEAN;       -- PL/SQL-only data type\n  part_price        NUMBER(6,2);   -- SQL data type\n  part_description  VARCHAR2(50);  -- SQL data type\nBEGIN\n  NULL;\nEND;\n/\n</code></pre> <pre><code>-- Constant declarations\nDECLARE\n  credit_limit     CONSTANT REAL    := 5000.00;  -- SQL data type\n  max_days_in_year CONSTANT INTEGER := 366;      -- SQL data type\n  urban_legend     CONSTANT BOOLEAN := FALSE;     -- PL/SQL-only data type;\nBEGIN\n  NULL;\nEND;\n/\n</code></pre>"},{"location":"pl_sql/01_PL_SQL_basics/#declaring-boolean-variables","title":"Declaring Boolean Variables","text":"<ul> <li>Only the values TRUE, FALSE, and NULL can be assigned to a Boolean variable.</li> <li>The variables are connected by the logical operators AND, OR, and NOT.</li> <li>The variables always yield TRUE, FALSE, or NULL.</li> <li>Arithmetic, character, and date expressions can be used to return a Boolean value.</li> </ul>"},{"location":"pl_sql/01_PL_SQL_basics/#composite-datatypes","title":"Composite Datatypes","text":"<ul> <li>PL/SQL TABLES</li> <li>PL/SQL RECORDS</li> </ul> <pre><code>-- Initialization\nDECLARE\n  hours_worked    INTEGER := 40;\n  employee_count  INTEGER := 0;\n  pi     CONSTANT REAL := 3.14159;\n  radius          REAL := 1;\n  area            REAL := (pi * radius**2);\nBEGIN\n  NULL;\nEND;\n/\n</code></pre> <pre><code>-- Default initializations\nDECLARE\n  counter INTEGER;  -- initial value is NULL by default\nBEGIN\n  counter := counter + 1;  -- NULL + 1 is still NULL\n  IF counter IS NULL THEN\n    DBMS_OUTPUT.PUT_LINE('counter is NULL.');\n  END IF;\nEND;\n/\n</code></pre> <pre>\nResults:\n---------\ncounter is NULL.\n</pre> <pre><code>-- All variables will be NULL\nDECLARE\n  null_string  VARCHAR2(80) := TO_CHAR('');\n  address      VARCHAR2(80);\n  zip_code     VARCHAR2(80) := SUBSTR(address, 25, 0);\n  name         VARCHAR2(80);\n  valid        BOOLEAN      := (name != '');\nBEGIN\n  NULL;\nEND;\n/\n</code></pre> <pre><code>-- %TYPE type inheritance from a column or from other variable\n-- in case of column it doesn't inherit constraint, only data type\nDECLARE\n  v_name  emp.ename%TYPE;\nBEGIN\n  DBMS_OUTPUT.PUT_LINE('name=' || v_name);\nEND;\n/\n</code></pre> <ul> <li> <p>Declare a variable according to:</p> <ul> <li>A database column definition</li> <li>Another previously declared variable</li> </ul> </li> <li> <p>Prefix %TYPE with:</p> <ul> <li>The database table and column</li> <li>The previously declared variable name</li> </ul> </li> </ul> <pre><code>DECLARE\n  name     VARCHAR(25) NOT NULL := 'Smith';\n  surname  name%TYPE := 'Jones';               -- inherits NOT NULL constraint too\nBEGIN\n  DBMS_OUTPUT.PUT_LINE('name=' || name);\n  DBMS_OUTPUT.PUT_LINE('surname=' || surname);\nEND;\n/\n</code></pre> <pre>\nResults:\n---------\nname=Smith\nsurname=Jones\n</pre> <pre><code>-- %ROWTYPE record type inheritance (from table, view, cursor, record)\nCREATE TABLE employees_temp (\n  empid NUMBER(6) NOT NULL PRIMARY KEY,\n  deptid NUMBER(6) CONSTRAINT c_employees_temp_deptid CHECK (deptid BETWEEN 100 AND 200),\n  deptname VARCHAR2(30) DEFAULT 'Sales' );\n\nDECLARE\n  emprec  employees_temp%ROWTYPE;\nBEGIN\n  emprec.empid := NULL;         -- NOT Null constraint not inherited\n  emprec.deptid := 50;          -- Check constraint not inherited\n  DBMS_OUTPUT.PUT_LINE ('emprec.deptname: ' || emprec.deptname);  -- Initial value not inherited\nEND;\n/\n</code></pre> <pre><code>-- Error if identical names within a PL/SQL unit\nDECLARE\n  id  BOOLEAN;\n  id  VARCHAR2(5);  -- duplicate identifier\nBEGIN\n  id := FALSE;\nEND;\n/\n</code></pre>"},{"location":"pl_sql/01_PL_SQL_basics/#plsql-units-are-the-following","title":"PL/SQL units are the following:","text":"<ul> <li>PL/SQL anonymous block</li> <li>FUNCTION</li> <li>LIBRARY</li> <li>PACKAGE</li> <li>PACKAGE BODY</li> <li>PROCEDURE</li> <li>TRIGGER</li> <li>TYPE</li> <li>TYPE BODY</li> </ul> <pre><code>-- qualified names (within the procedure it refers to local identifier)\n-- 'echo' -&gt; name of a label and a procedure\nSET SERVEROUTPUT ON\n&lt;&lt;echo&gt;&gt;    -- name of a label (we can use labels to qualify PL/SQL program blocks)\nDECLARE\n  x  NUMBER := 5;\n\n  PROCEDURE echo IS   -- name of a procedure\n    x  NUMBER := 0;\n  BEGIN\n    DBMS_OUTPUT.PUT_LINE('x = ' || x);             -- output: x = 0\n    DBMS_OUTPUT.PUT_LINE('echo.x = ' || echo.x);   -- output: echo.x = 0 (variable of the procedure)\n  END;\n\nBEGIN\n  echo;\nEND;\n/\n</code></pre> <pre>\nResults:\n---------\nx = 0\necho.x = 0\n</pre> <pre><code>-- initialization of a logical variable\nDECLARE\n  done    BOOLEAN;               -- Initial value is NULL by default\n  counter NUMBER := 0;\nBEGIN\n  done := FALSE;                 -- Assign literal value\n  WHILE done != TRUE             -- Compare to literal value\n  LOOP\n    counter := counter + 1;\n    done := (counter &gt; 500);     -- Assign value of BOOLEAN expression\n  END LOOP;\n  DBMS_OUTPUT.PUT_LINE(counter);  -- output: 501\nEND;\n/\n</code></pre> <pre>\nResults:\n---------\n501\n</pre>"},{"location":"pl_sql/01_PL_SQL_basics/#operators-in-plsql","title":"Operators in PL/SQL","text":"<p>Examples:</p> <ul> <li> <p>Increment the index for a loop.</p> <ul> <li>v_count := v_count + 1;</li> </ul> </li> <li> <p>Set the value of a Boolean flag.</p> <ul> <li>v_equal := (v_n1 = v_n2);</li> </ul> </li> <li> <p>Validate an employee number if it contains a value.</p> <ul> <li>v_valid := (v_empno IS NOT NULL);</li> </ul> </li> </ul> <pre><code>-- SELECT data from a table into a variable\nset serveroutput on\nDECLARE\n  bonus   NUMBER(7,2);\nBEGIN\n  SELECT sal * 0.10 INTO bonus\n  FROM emp                        -- you need table EMP !!!\n  WHERE empno = 7900;\n  DBMS_OUTPUT.PUT_LINE('bonus = ' || TO_CHAR(bonus));\nEND;\n/\n</code></pre> <pre>\nResults:\n---------\nbonus = 95\n</pre>"},{"location":"pl_sql/01_PL_SQL_basics/#datatype-conversion","title":"Datatype Conversion","text":"<ul> <li>Convert data to comparable datatypes.</li> <li>Mixed datatypes can result in an error and affect performance.</li> <li> <p>Conversion functions:</p> </li> <li> <p>TO_CHAR</p> </li> <li>TO_DATE</li> <li>TO_NUMBER</li> </ul> <p>Example:</p> <pre><code>DECLARE\n    v_date VARCHAR2(15);\nBEGIN\n    SELECT TO_CHAR(hiredate, 'MON. DD, YYYY')\n    INTO v_date\n    FROM emp\n    WHERE empno = 7839;\nEND;\n</code></pre> <pre><code>-- Two NULLs are not equal. Neither != is TRUE for them.\nset serveroutput on\nDECLARE\n  a NUMBER := NULL;\n  b NUMBER := NULL;\nBEGIN\n  IF a = b THEN                         -- yields NULL, not TRUE\n    DBMS_OUTPUT.PUT_LINE('a = b');      -- not run\n  ELSIF a != b THEN                     -- yields NULL, not TRUE\n    DBMS_OUTPUT.PUT_LINE('a != b');     -- not run\n  ELSE\n    DBMS_OUTPUT.PUT_LINE('Can''t tell if two NULLs are equal');\n  END IF;\nEND;\n/\n</code></pre> <pre>\nResults:\n---------\nCan't tell if two NULLs are equal\n</pre> <pre><code>-- Concatenation operator ignores NULL.\nset serveroutput on\nBEGIN\n  DBMS_OUTPUT.PUT_LINE ('apple' || NULL || NULL || 'sauce');  -- output: applesauce\nEND;\n/\n</code></pre> <pre>\nResults:\n---------\napplesauce\n</pre> <pre><code>-- use brackets\nDECLARE\n  a INTEGER := 2**2*3**2;\n  b INTEGER := (2**2)*(3**2);\nBEGIN\n  DBMS_OUTPUT.PUT_LINE('a = ' || TO_CHAR(a));   -- output: a = 36\n  DBMS_OUTPUT.PUT_LINE('b = ' || TO_CHAR(b));   -- output: b = 36\nEND;\n/\n</code></pre> <pre>\nResults:\n---------\na = 36\nb = 36\n</pre> <pre><code>-- lazy evaluation\nDECLARE\n  on_hand  INTEGER := 0;\n  on_order INTEGER := 100;\nBEGIN \n  IF (on_hand = 0) OR ((on_order / on_hand) &lt; 5) THEN   -- Will not cause ZERO_DIVIDE exception\n    DBMS_OUTPUT.PUT_LINE('On hand quantity is zero.');\n  END IF;\nEND;\n/\n</code></pre> <pre>\nResults:\n---------\nOn hand quantity is zero.\n</pre>"},{"location":"pl_sql/01_PL_SQL_basics/#subtypes","title":"Subtypes","text":"<p>Unconstrained (gives only an alias for compatibility purpose)</p> <pre><code>SUBTYPE CHARACTER IS CHAR;\n</code></pre> <p>Contrained (a real subset)</p> <pre><code>SUBTYPE INTEGER IS NUMBER(38,0);\n</code></pre> <p>Predefined subtypes in STANDARD package, you can see them with the following query:</p> <pre><code>SELECT text FROM all_source WHERE type='PACKAGE' and name='STANDARD' ORDER BY line;\n</code></pre>"},{"location":"pl_sql/01_PL_SQL_basics/#examples-from-the-package","title":"Examples from the package:","text":"<pre><code>type BOOLEAN is (FALSE, TRUE);\nsubtype INTEGER is NUMBER(38,0);\nsubtype DECIMAL is NUMBER(38,0);\nsubtype BINARY_INTEGER is INTEGER range '-2147483647'..2147483647;\nsubtype NATURAL is BINARY_INTEGER range 0..2147483647;\nsubtype NATURALN is NATURAL not null;\ntype sys_refcursor is ref cursor;\n</code></pre> <pre><code>-- user-defined subtypes (record, table, type inheritance + constraint)\nDECLARE\n  SUBTYPE BirthDate IS DATE NOT NULL;         -- Based on DATE type\n  SUBTYPE Counter IS NATURAL;                 -- Based on NATURAL subtype\n\n  SUBTYPE pinteger IS PLS_INTEGER RANGE -9..9;  \n\n  TYPE NameList IS TABLE OF VARCHAR2(10);\n  SUBTYPE DutyRoster IS NameList;             -- Based on TABLE type\n\n  TYPE TimeRec IS RECORD (minutes INTEGER, hours INTEGER);\n  SUBTYPE FinishTime IS TimeRec;                -- Based on RECORD type\n  SUBTYPE ID_Num IS employees.employee_id%TYPE; -- Based on column type\nBEGIN\n  NULL;\nEND;\n/\n</code></pre> <pre><code>-- implicit conversion CHAR -&gt; NUMBER\nset serveroutput on\nDECLARE\n  V1  CHAR(10):='1234';\n  V2  NUMBER;\nBEGIN\n  V2 := V1 + 1;                          -- CHAR -&gt; NUMBER\n  DBMS_OUTPUT.PUT_LINE ('V2: ' || TO_CHAR(V2));\nEND;\n/\n</code></pre> <pre>\nResults:\n---------\nV2: 1235\n</pre> <pre><code>-- Take care of blank-padded semantics in case of CHAR data type !!!\nset serveroutput on\nDECLARE\n  last_name1 CHAR(5)  := 'BELLO';     -- no trailing blanks\n  last_name2 CHAR(10) := 'BELLO   ';  -- trailing blanks\nBEGIN\n  IF last_name1 = last_name2 THEN\n    DBMS_OUTPUT.PUT_LINE(last_name1 || '(length:'|| length(last_name1)||') equals ' ||\n    last_name2  || '(length:'|| length(last_name2)||')');\n  ELSE\n    DBMS_OUTPUT.PUT_LINE(last_name2 || ' does not equal ' || last_name1);\n  END IF;\nEND;\n/\n</code></pre> <pre>\nResults:\n---------\nBELLO(length:5) equals BELLO     (length:10)\n</pre> <pre><code>-- Using TIMESTAMP data type \n-- TIMESTAMP stores the fractional seconds\nDECLARE\n  start_time   VARCHAR2(50);\n  finish_time  VARCHAR2(50);\n  elapsed_time NUMBER(30,10);\nBEGIN\n  -- Get system time as seconds and fractional seconds past midnight:\n  SELECT TO_CHAR(SYSTIMESTAMP,'SSSSS.FF') INTO start_time FROM sys.DUAL;\n  -- Get system time again:\n  SELECT TO_CHAR(SYSTIMESTAMP,'SSSSS.FF') INTO finish_time FROM sys.DUAL;\n  elapsed_time := TO_NUMBER(finish_time, '99999.999999') \n                - TO_NUMBER(start_time, '99999.999999');\n  DBMS_OUTPUT.PUT_LINE ('Elapsed time: ' || TO_CHAR(elapsed_time,'0.999999'));\nEND;\n/\n</code></pre> <pre>\nResults:\n---------\nElapsed time:  0.000055\n</pre> <pre><code>-- simple CASE expression (this is not a statement but an expression!)\nset serveroutput on\nDECLARE\n  grade CHAR(1) := 'B';\n  appraisal VARCHAR2(20);\nBEGIN\n  appraisal :=\n    CASE grade\n      WHEN 'A' THEN 'Excellent'\n      WHEN 'B' THEN 'Very Good'\n      WHEN 'C' THEN 'Good'\n      WHEN 'D' THEN 'Fair'\n      WHEN 'F' THEN 'Poor'\n      ELSE 'No such grade'\n    END;\n    DBMS_OUTPUT.PUT_LINE ('Grade ' || grade || ' is ' || appraisal);  -- Very Good\nEND;\n/\n</code></pre> <pre>\nResults:\n---------\nGrade B is Very Good\n</pre> <pre><code>-- This form of CASE tests equality so grade = NULL will not be TRUE !!!\n-- use the other form, see in the next example below\nset serveroutput on\nDECLARE\n  grade CHAR(1); -- NULL by default\n  appraisal VARCHAR2(20);\nBEGIN\n  appraisal :=\n  CASE grade\n    WHEN NULL THEN 'No grade assigned'  -- grade = NULL\n    WHEN 'A' THEN 'Excellent'\n    WHEN 'B' THEN 'Very Good'\n    WHEN 'C' THEN 'Good'\n    WHEN 'D' THEN 'Fair'\n    WHEN 'F' THEN 'Poor'\n    ELSE 'No such grade'\n  END;\n  DBMS_OUTPUT.PUT_LINE ('Grade ' || grade || ' is: ' || appraisal);  -- No such grade\nEND;\n/\n</code></pre> <pre>\nResults:\n---------\nGrade  is: No such grade\n</pre> <pre><code>-- logical expressions after WHEN\n-- First TRUE condition will be returned\nset serveroutput on\nDECLARE\n  grade CHAR(1); -- NULL by default\n  appraisal VARCHAR2(20);\nBEGIN\n  appraisal :=\n    CASE\n      WHEN grade IS NULL THEN 'No grade assigned'\n      WHEN grade = 'A' THEN 'Excellent'\n      WHEN grade = 'B' THEN 'Very Good'\n      WHEN grade = 'C' THEN 'Good'\n      WHEN grade = 'D' THEN 'Fair'\n      WHEN grade = 'F' THEN 'Poor'\n      ELSE 'No such grade'\n    END;\n    DBMS_OUTPUT.PUT_LINE ('Grade ' || grade || ' is: ' || appraisal);  -- No grade assigned\nEND;\n/\n</code></pre>"},{"location":"pl_sql/01_PL_SQL_basics/#logic-tables","title":"Logic Tables","text":"<p>Build a simple Boolean condition with a comparison operator.</p> <p></p> <p>Any arithmetic expression containing a null value evaluates to NULL.</p>"},{"location":"pl_sql/01_PL_SQL_basics/#retrieving-data-in-plsql","title":"Retrieving Data in PL/SQL","text":"<p>Retrieve the order date and the ship date for the specified order.</p> <pre><code>DECLARE\n  v_orderdate ord.orderdate%TYPE;\n  v_shipdate ord.shipdate%TYPE;\nBEGIN\n  SELECT orderdate, shipdate\n  INTO v_orderdate, v_shipdate\n  FROM ord\n  WHERE id = 620;\n  ...\nEND;\n</code></pre>"},{"location":"pl_sql/01_PL_SQL_basics/#updating-data","title":"Updating Data","text":"<p>Increase the salary of all employees in the emp table who are Analysts.</p> <pre><code>DECLARE\n  v_sal_increase emp.sal%TYPE := 2000;\nBEGIN\n  UPDATE emp\n  SET sal = sal + v_sal_increase\n  WHERE job = 'ANALYST';\nEND;\n</code></pre>"},{"location":"pl_sql/01_PL_SQL_basics/#control-statements","title":"Control statements","text":""},{"location":"pl_sql/01_PL_SQL_basics/#if-then","title":"IF THEN","text":"<pre><code>IF condition THEN\n  statements\nEND IF;\n</code></pre>"},{"location":"pl_sql/01_PL_SQL_basics/#if-then-else","title":"IF THEN ELSE","text":"<pre><code>IF condition THEN\n  statements\nELSE\n  else_statements\nEND IF;\n</code></pre>"},{"location":"pl_sql/01_PL_SQL_basics/#if-then-elsif","title":"IF THEN ELSIF","text":"<pre><code>IF condition_1 THEN\n  statements_1\nELSIF condition_2 THEN\n  statements_2\n[ ELSIF condition_3 THEN\n    statements_3\n]...\n[ ELSE\n    else_statements\n]\nEND IF;\n</code></pre>"},{"location":"pl_sql/01_PL_SQL_basics/#simple-case-statement","title":"Simple CASE statement","text":"<p>CASE_NOT_FOUND exception if none of them is true</p> <pre><code>CASE selector \nWHEN selector_value_1 THEN statements_1\nWHEN selector_value_2 THEN statements_2\n...\nWHEN selector_value_n THEN statements_n\n[ ELSE   else_statements ]\nEND CASE;\n</code></pre>"},{"location":"pl_sql/01_PL_SQL_basics/#searched-case-statement","title":"Searched CASE statement","text":"<p>CASE_NOT_FOUND exception if none of them is true</p> <pre><code>CASE\nWHEN condition_1 THEN statements_1\nWHEN condition_2 THEN statements_2\n...\nWHEN condition_n THEN statements_n\n[ ELSE   else_statements ]\nEND CASE;\n</code></pre>"},{"location":"pl_sql/01_PL_SQL_basics/#basic-loop","title":"Basic LOOP","text":"<pre><code>[ label ] LOOP\n  statements\nEND LOOP [ label ];\n</code></pre>"},{"location":"pl_sql/01_PL_SQL_basics/#exit-from-loop-starting-a-new-iteration","title":"Exit from loop / starting a new iteration","text":"<pre><code>EXIT\nEXIT WHEN \nCONTINUE\nCONTINUE WHEN\n</code></pre>"},{"location":"pl_sql/01_PL_SQL_basics/#while-loop","title":"WHILE LOOP","text":"<pre><code>[ label ] WHILE condition LOOP\n  statements\nEND LOOP [ label ];\n</code></pre>"},{"location":"pl_sql/01_PL_SQL_basics/#for-loop","title":"FOR LOOP","text":"<pre><code>[ label ] FOR index IN [ REVERSE ] lower_bound..upper_bound LOOP\n  statements\nEND LOOP [ label ];\n</code></pre> <pre><code>BEGIN\n FOR i IN REVERSE 1..3 loop\n  dbms_output.put_line(to_char(i));\n END loop;\nEND;\n/\n</code></pre> <pre><code>-- NULL statement\nNULL;\n\n-- GOTO statement \nGOTO label\n\n-- RETURN statement (return from a subprogram or from an anonymous block)\n\nBEGIN\n FOR i IN 1..3 loop\n  dbms_output.put_line(i);\n  IF i=2 THEN RETURN; END IF;\n END loop;\nEND;\n/\n</code></pre> <pre><code>-- index of FOR loop is local within the loop\nset serveroutput on\n&lt;&lt;main&gt;&gt;  -- Label block.\nDECLARE\n  i NUMBER := 5;\nBEGIN\n  FOR i IN 1..3 LOOP\n    DBMS_OUTPUT.PUT_LINE ('local: ' || TO_CHAR(i) || ', global: ' || TO_CHAR(main.i));\n  END LOOP;\nEND main;\n/\n</code></pre> <pre>\nResults:\n---------\nlocal: 1, global: 5\nlocal: 2, global: 5\nlocal: 3, global: 5\n</pre> <pre><code>-- Loop indexes in nested loops\n/*\n- Nest loops to multiple levels.\n- Use labels to distinguish between blocks and loops.\n- Exit the outer loop with the EXIT statement referencing the label. */\nset serveroutput on\nBEGIN\n  &lt;&lt;outer_loop&gt;&gt;\n  FOR i IN 1..3 LOOP\n    &lt;&lt;inner_loop&gt;&gt;\n    FOR i IN 1..3 LOOP\n      IF outer_loop.i = 2 THEN\n        DBMS_OUTPUT.PUT_LINE('outer: ' || TO_CHAR(outer_loop.i) || ' inner: ' || TO_CHAR(inner_loop.i));\n      END IF;\n    END LOOP inner_loop;\n  END LOOP outer_loop;\nEND;\n/\n</code></pre> <pre>\nResults:\n---------\nouter: 2 inner: 1\nouter: 2 inner: 2\nouter: 2 inner: 3\n</pre> <pre><code>/*************** scope and visibility *************/\n&lt;&lt;label1&gt;&gt;\nDECLARE\n  a  NUMBER;\nBEGIN\n  a:=2;\n  &lt;&lt;label2&gt;&gt;\n  DECLARE\n    a number;\n  BEGIN\n    a:=4;\n    dbms_output.put_line(label1.a);\n    dbms_output.put_line(label2.a);\n    dbms_output.put_line(a);\n  END;\n  dbms_output.put_line(a);\nEND;\n/\n</code></pre> <pre>\nResults:\n---------\n2\n4\n4\n2\n</pre> <pre><code>/************** outer (bind) variables, it works only in SQL*PLUS environment, not in SqlDeveloper *************/\n/* program gets a pointer, so it can modify the variable*/\nVariable v number;\nBEGIN\n :v := mod(121,3);\nEND;\n/\nprint v;\n</code></pre>"},{"location":"pl_sql/01_PL_SQL_basics/#using-bind-variables","title":"Using Bind Variables","text":"<p>To reference a bind variable in PL/SQL, you must prefix its name with a colon (:).</p> <pre><code>VARIABLE g_salary NUMBER\nDECLARE\n  v_sal emp.sal%TYPE;\nBEGIN\n  SELECT sal\n  INTO v_sal\n  FROM emp\n  WHERE empno = 7369;\n  :g_salary := v_sal;\nEND;\n</code></pre> <pre><code>/************** printing on the screen *************/\nset serveroutput on\nBEGIN\n  DBMS_OUTPUT.PUT_LINE('Hello World!');\nEND;\n/\n</code></pre>"},{"location":"pl_sql/01_PL_SQL_basics/#use-set-serveroutput-on","title":"Use SET SERVEROUTPUT ON","text":"<p>A PL/SQL program actually doesn't print on the screen.</p> <p>It prints into a buffer on the server side.</p> <p>You can use GET_LINE to read from the buffer.</p> <pre><code>SET SERVEROUTPUT ON\nDECLARE\n  v_status  INTEGER := 0;\n  v_line    VARCHAR2(100); \n  v_buff    VARCHAR2(1000);\nBEGIN \n  -- We print 3 lines into the buffer.\n  DBMS_OUTPUT.PUT_LINE('1-bubu'); DBMS_OUTPUT.PUT_LINE('2-bibi'); DBMS_OUTPUT.PUT_LINE('3-baba');\n  -- We empty the buffer.\n  WHILE v_status = 0 LOOP\n    DBMS_OUTPUT.GET_LINE (v_line, v_status);\n    v_buff := v_buff || v_line;\n  END LOOP;\n  -- We print the concatenated string into the buffer.\n  DBMS_OUTPUT.PUT_LINE(v_buff);\nEND;\n/\n</code></pre> <pre>\nResults:\n---------\n1-bubu2-bibi3-baba\n</pre> <p>Runtime environment reads the buffer only after the program terminated. </p> <p>Without 'set serveroutput on' result remains in buffer.</p> <pre><code>set serveroutput off     -- notice OFF !!!\nBEGIN \n  DBMS_OUTPUT.PUT_LINE('first program');      \n  DBMS_OUTPUT.PUT_LINE('second program');     \nEND;\n/\n</code></pre> <pre><code>SET SERVEROUTPUT ON\nDECLARE\n  v_status  INTEGER := 0;\n  v_line    VARCHAR2(100); \nBEGIN \n  WHILE v_status = 0 LOOP\n    DBMS_OUTPUT.GET_LINE (v_line, v_status);       -- reads buffer\n  END LOOP;\n  DBMS_OUTPUT.PUT_LINE('second program');          -- writes into buffer\nEND;\n/\n</code></pre> <pre><code>/****************** Input from the user ****************/\n/* substitution happens before SQL statement is sent to Oracle Server */\n\nACCEPT v1 NUMBER FORMAT '99' PROMPT 'Give the department number:'\nACCEPT v2 DATE FORMAT 'yyyy.mm.dd' DEFAULT 1982.01.01 PROMPT 'Date (format: 2013.01.30)'\nset serveroutput on\nDECLARE \n  v_sum NUMBER;\nBEGIN\n  SELECT sum(sal) INTO v_sum FROM emp WHERE deptno = &amp;v1 AND hiredate &lt; to_date('&amp;v2', 'yyyy.mm.dd');\n  dbms_output.put_line(v_sum);\nEND;\n/\n</code></pre> <pre><code>/****************** records ****************/\nDECLARE\n  TYPE rektip IS RECORD(m1 INTEGER, m2 VARCHAR2(10));\n  rec rektip;\nBEGIN\n  rec.m1 := 1; rec.m2 := 'Bubu';\n  DBMS_OUTPUT. PUT_LINE(rec.m2);\nEND;\n</code></pre> <pre><code>/****************** records, arrays ****************/\nset serveroutput on\nDECLARE\n  TYPE rek_type IS RECORD(f1 INTEGER DEFAULT 10, f2 dept%ROWTYPE);  -- nested record (ROWTYPE)\n  rec rek_type;\n  TYPE tab_type IS TABLE OF INTEGER INDEX BY BINARY_INTEGER;   -- associative (index by) array\n  TYPE rek_type2 IS RECORD(f1 INTEGER, f2 tab_type);           -- nested array within a field\n  rec2 rek_type2;\n  rec_oszt dept%ROWTYPE;                                       -- a record too\nBEGIN\n rec_oszt.dname := 'SALES';\n dbms_output.put_line(rec.f1);                             -- default value of the field\n\n SELECT * INTO rec.f2 FROM dept WHERE deptno = 10;         -- rec (nested record)\n dbms_output.put_line(rec.f2.loc);\n\n rec2.f2(1) := 100; rec2.f2(2) := 200; rec2.f2(3) := 300;  -- rec2 (array within a field)\n FOR i IN rec2.f2.FIRST .. rec2.f2.LAST LOOP\n   dbms_output.put_line(rec2.f2(i));\n END LOOP;\nEND;\n/\n</code></pre> <pre>\nResults:\n---------\n10\nNEW YORK\n100\n200\n300\n</pre>"},{"location":"pl_sql/01_PL_SQL_basics/#plsql-records","title":"PL/SQL Records","text":"<ul> <li>Must contain one or more components of any scalar, RECORD, or PL/SQL TABLE datatype, called fields</li> <li>Are similar in structure to records in a 3GL</li> <li>Are not the same as rows in a database table</li> <li>Treat a collection of fields as a logical unit</li> <li>Are convenient for fetching a row of data from a table for processing</li> </ul>"},{"location":"pl_sql/01_PL_SQL_basics/#using-plsql-table-methods","title":"Using PL/SQL Table Methods","text":"<p>The following methods make PL/SQL tables easier to use:</p> <ul> <li>EXISTS</li> <li>COUNT</li> <li>FIRST and LAST</li> <li>PRIOR</li> <li>NEXT</li> <li>EXTEND</li> <li>TRIM</li> <li>DELETE</li> </ul>"},{"location":"pl_sql/01_PL_SQL_basics/#plsql-tables","title":"PL/SQL Tables","text":"<ul> <li> <p>Are composed of two components:</p> <ul> <li>Primary key of datatype BINARY_INTEGER</li> <li>Column of scalar or record datatype</li> </ul> </li> <li> <p>Increase dynamically because they are unconstrained</p> </li> </ul>"},{"location":"pl_sql/01_PL_SQL_basics/#the-rowtype-attribute","title":"The %ROWTYPE Attribute","text":"<ul> <li>Declare a variable according to a collection of columns in a database table or view.</li> <li>Prefix %ROWTYPE with the database table.</li> <li>Fields in the record take their names and datatypes from the columns of the table or view.</li> </ul>"},{"location":"pl_sql/02_Cursors_and_collections/","title":"Cursors and Collections","text":""},{"location":"pl_sql/02_Cursors_and_collections/#cursor","title":"Cursor","text":"<p>Every SQL statement executed by the Oracle Server has an individual cursor associated with it:</p> <ul> <li>Implicit cursors: Declared for all DML and PL/SQL SELECT statements</li> <li>Explicit cursors: Declared and named by the programmer</li> </ul> <p>Controlling Explicit Cursors:</p> <ul> <li>DECLARE: Create a named SQL area</li> <li>OPEN: Identify the active set</li> <li>FETCH: Load the current row into variables</li> <li>EMPTY?: Test for existing rows, return to FETCH if rows found</li> <li>CLOSE: Release the active set</li> </ul> <pre><code>-- examples for cursors (implicit and explicit cursor)\n\nset serveroutput on\nDECLARE \n  CURSOR curs1 IS SELECT deptno, ename FROM nikovits.emp WHERE deptno = 10;\n  rec curs1%ROWTYPE;\nBEGIN\n  OPEN curs1;\n  LOOP\n    FETCH curs1 INTO rec;\n    EXIT WHEN curs1%NOTFOUND;\n    dbms_output.put_line(to_char(rec.deptno)||' - '||rec.ename);\n  END LOOP;\n  CLOSE curs1;\nEND;\n/\n</code></pre> <pre>\nResults:\n-----------\n10 - MILLER\n10 - CLARK\n10 - KING\n</pre> <p>Controlling Explicit Cursors:</p> <ul> <li>Open the cursor.</li> <li>Fetch a row from the cursor.</li> <li>Continue until empty.</li> <li>Close the cursor.</li> </ul> <p>Opening the Cursor:</p> <ul> <li>Open the cursor to execute the query and identify the active set.</li> <li>If the query returns no rows, no exception is raised.</li> <li>Use cursor attributes to test the outcome after a fetch.</li> </ul> <p>Fetching Data from the Cursor:</p> <ul> <li>Retrieve the current row values into output variables.</li> <li>Include the same number of variables.</li> <li>Match each variable to correspond to the columns positionally.</li> <li>Test to see if the cursor contains rows.</li> </ul> <p>Declaring the Cursor:</p> <ul> <li>Do not include the INTO clause in the cursor declaration.</li> <li>If processing rows in a specific sequence is required, use the ORDER BY clause in the query.</li> </ul> <p>Closing the Cursor:</p> <ul> <li>Close the cursor after completing the processing of the rows.</li> <li>Reopen the cursor, if required.</li> <li>Do not attempt to fetch data from a cursor once it has been closed.</li> </ul> <p>Explicit Cursor Attributes:</p> <ul> <li>Obtain status information about a cursor.</li> <li>%ISOPEN (Boolean): Evaluates to TRUE if the cursor is open</li> <li>%NOTFOUND (Boolean): Evaluates to TRUE if the most recent fetch does not return a row</li> <li>%FOUND (Boolean): Evaluates to TRUE if the most recent fetch returns a row; complement of %NOTFOUND</li> <li>%ROWCOUNT (Number): Evaluates to the total number of rows returned so far</li> </ul> <pre><code>-- Implicit cursor (for a DELETE statement)\nset serveroutput on\nDECLARE\n  v_rows_deleted VARCHAR2(30);\n  v_job emp.job%TYPE := 'SALESMAN';\nBEGIN\n  DELETE FROM emp WHERE job = v_job;\n  v_rows_deleted := (SQL%ROWCOUNT ||' row(s) deleted.');\n  DBMS_OUTPUT.PUT_LINE (v_rows_deleted);\n  ROLLBACK;  -- rollback the transaction, we don't really want to delete\nEND;\n/\n</code></pre> <pre>\nResults:\n-----------\n5 row(s) deleted.\n</pre> <p>Cursors and Records:</p> <ul> <li>Process the rows of the active set conveniently by fetching values into a PL/SQL RECORD.</li> </ul> <p>Cursor FOR Loop:</p> <ul> <li>The cursor FOR loop is a shortcut to process explicit cursors.</li> <li>Implicit open, fetch, and close occur.</li> <li>The record is implicitly declared.</li> </ul> <p>Cursor Parameters:</p> <ul> <li>Pass parameter values to a cursor when the cursor is opened and the query is executed.</li> <li>Open an explicit cursor several times with a different active set each time.</li> </ul> <pre><code>-- Explicit cursors, 3 forms of cursor usage and cursors with parameter\nset serveroutput on\nDECLARE \n  CURSOR curs1(p_deptno NUMBER DEFAULT 10) IS SELECT ename, sal FROM emp WHERE deptno = p_deptno;\n  CURSOR curs2(p_deptno NUMBER) IS SELECT ename, sal from emp where deptno = p_deptno;\n  rec curs1%ROWTYPE;\nBEGIN\n  OPEN curs1();            -- default parameter\n  LOOP\n    FETCH curs1 INTO rec;\n    EXIT WHEN curs1%NOTFOUND;\n    dbms_output.put_line('curs1: '||rec.ename||' - '||to_char(rec.sal));\n  END LOOP;\n  CLOSE curs1;\n\n  FOR rec IN curs2(20) LOOP   -- parameter\n    dbms_output.put_line('curs2: '||rec.ename||' - '||to_char(rec.sal));\n  END LOOP;\n\n  FOR rec IN (SELECT ename, sal FROM emp WHERE deptno=30) LOOP\n    dbms_output.put_line('curs3: '||rec.ename||' - '||to_char(rec.sal));\n  END LOOP;\nEND;\n/\n</code></pre> <pre>\nResults:\n-----------\ncurs1: CLARK - 2450\ncurs1: KING - 5000\ncurs1: MILLER - 1300\ncurs2: SMITH - 800\ncurs2: JONES - 2975\ncurs2: SCOTT - 3000\ncurs2: ADAMS - 1100\ncurs2: FORD - 3000\ncurs3: ALLEN - 1600\ncurs3: WARD - 1250\ncurs3: MARTIN - 1250\ncurs3: BLAKE - 4250\ncurs3: TURNER - 1500\ncurs3: JAMES - 950\n</pre> <pre><code>-- Using a CURSOR for a WITH statement\nDECLARE \n  CURSOR curs1 IS \n  WITH\n  tmp1 AS (\n    SELECT deptno, round(AVG(sal)) dept_avg FROM emp\n    GROUP BY deptno),\n  tmp2 AS (\n    SELECT round(AVG(sal)) gen_avg FROM emp)\n  SELECT dname, dept_avg, gen_avg, dept_avg-gen_avg diff\n  FROM tmp1, tmp2, dept WHERE tmp1.deptno = dept.deptno;\n  rec curs1%ROWTYPE;\nBEGIN\n  OPEN curs1;\n  LOOP\n    FETCH curs1 INTO rec;\n    EXIT WHEN curs1%NOTFOUND;\n    dbms_output.put_line(rec.dname||' | '||rec.dept_avg||' | '||rec.diff);\n  END LOOP;\n  CLOSE curs1;\nEND;\n/\n</code></pre> <pre>\nResults:\n-----------\nACCOUNTING | 2917 | 751\nRESEARCH | 2175 | 9\nSALES | 1800 | -366\nMARKETING | 2133 | -33\n</pre> <p>Explicit Locking:</p> <ul> <li>Explicit locking lets you deny access for the duration of a transaction.</li> <li>Lock the rows before the update or delete.</li> </ul> <p>Cursor Updates and Deletes:</p> <ul> <li>Use cursors to update or delete the current row.</li> <li>Include the FOR UPDATE clause in the cursor query to lock the rows first.</li> <li>Use the WHERE CURRENT OF clause to reference the current row from an explicit cursor.</li> </ul> <pre><code>-- Update with a cursor  -&gt; WHERE CURRENT OF\n-- FOR UPDATE locks rows in the table\nDECLARE \n  CURSOR curs1 IS SELECT ename, sal FROM emp WHERE deptno = 10 FOR UPDATE;\n  rec curs1%ROWTYPE;\nBEGIN\n  OPEN curs1;\n  LOOP\n    FETCH curs1 INTO rec;\n    EXIT WHEN curs1%NOTFOUND;\n    UPDATE emp SET sal = sal + length(rec.ename) WHERE CURRENT OF curs1;\n    dbms_output.put_line(rec.ename||' - '||to_char(rec.sal));\n  END LOOP;\n  CLOSE curs1;\nEND;\n/\n</code></pre> <pre><code>SELECT ename, sal FROM emp WHERE deptno=10;  -- you can see the updated values\nROLLBACK;\nSELECT ename, sal FROM emp WHERE deptno=10;  -- old values are restored\n</code></pre> <pre><code>-- What happens when we update the table during cursor loop?\n-- answer: cursor doesn't see the new values\n-- result set will be fixed when opening the cursor\nset serveroutput on\nDECLARE\n v_date    date := SYSDATE + 1;\nBEGIN\n  FOR rec IN (SELECT * FROM dept for update) LOOP\n    dbms_output.put(to_char(sysdate, 'hh24:mi:ss')||' --&gt; ');\n    dbms_output.put_line(rec.deptno);\n    SELECT SYSDATE + 2/(24*60*60) INTO v_date FROM dual; -- 2 seconds\n    WHILE sysdate &lt; v_date LOOP  NULL;   END LOOP;   \n    update dept set deptno = deptno+1;\n  END LOOP;\nEND;\n/\n</code></pre> <pre><code>-- Cursor update for a join\n-- LOC column will be updated in each step of iteration\n-- Result set of the cursor:\n-- TURNER  SALES\n-- MARTIN  SALES\n-- WARD    SALES\n-- ALLEN   SALES\n\nDECLARE\n  CURSOR c1 IS  SELECT ename, dname  FROM emp, dept\n    WHERE emp.deptno = dept.deptno AND job = 'SALESMAN' FOR UPDATE OF loc;\nBEGIN\n  FOR rec IN c1 LOOP\n   -- UPDATE emp SET sal = sal + 1 WHERE CURRENT OF c1;\n    UPDATE dept SET loc = loc|| '1' WHERE CURRENT OF c1;\n  END LOOP;\nEND;\n/\n</code></pre> <pre><code>-- cursor variable\n-- can be strongly typed (with return type) or weakly typed (without return type)\nDECLARE \n  TYPE empcurtyp IS REF CURSOR RETURN emp%ROWTYPE;  -- strong\n  TYPE genericcurtyp IS REF CURSOR;                 -- weak\n  TYPE t_cur IS REF CURSOR;\n  v_cur t_cur;\n\n  PROCEDURE cursor_open(p_cur IN OUT t_cur) IS\n  BEGIN\n    OPEN p_cur FOR SELECT ename FROM emp WHERE sal &gt; 3000;\n  END;\n\n  FUNCTION read_cursor(p_cur IN t_cur) RETURN varchar2 IS\n    v emp.ename%TYPE;\n  BEGIN\n    FETCH p_cur INTO v;\n    RETURN v;\n  END;\nBEGIN\n  cursor_open(v_cur);\n  dbms_output.put_line(read_cursor(v_cur));\n  CLOSE v_cur;\nEND;\n/\n</code></pre> <pre>\nResults:\n-----------\nBLAKE\n</pre>"},{"location":"pl_sql/02_Cursors_and_collections/#collection","title":"Collection","text":"<ul> <li>A collection is an ordered group of elements having the same data type.</li> <li>Each element is identified by a unique subscript that represents its position in the collection.</li> <li>Associative array (or index-by table): Unbounded, String or Integer subscript, Either dense or sparse, Only in PL/SQL block, No Object Type Attribute</li> <li>Nested table: Unbounded, Integer subscript, Starts dense, can become sparse, Either in PL/SQL block or at schema level, Yes Object Type Attribute</li> <li>Variablesize array (Varray): Bounded, Integer subscript, Always dense, Either in PL/SQL block or at schema level, Yes Object Type Attribute</li> </ul> <p>PL/SQL has three collection types: </p> <ol> <li>associative array (INDEX BY ...; we call it also PL/SQL table)</li> <li>VARRAY (variable-size array), </li> <li>NESTED TABLE</li> </ol>"},{"location":"pl_sql/02_Cursors_and_collections/#collection-methods","title":"Collection methods","text":"<p>A collection method is a PL/SQL subprogram: either a function that returns information about a collection, or a procedure that operates on a collection.</p> Method Type Description DELETE Procedure Deletes elements from collection. TRIM Procedure Deletes elements from end of varray or nested table. EXTEND Procedure Adds elements to end of varray or nested table. EXISTS Function Returns TRUE if and only if specified element of varray or nested table exists. FIRST Function Returns first index in a collection. LAST Function Returns last index in a collection. COUNT Function Returns number of elements in a collection. LIMIT Function Returns maximum number of elements that a collection can have. PRIOR Function Returns the index that precedes specified index. NEXT Function Returns the index that succeeds specified index. <pre><code>/****************** record and associative array ****************/\n\nset serveroutput on\nDECLARE\n  TYPE rek_type IS RECORD(f1 INTEGER DEFAULT 10, f2 emp.ename%TYPE);     -- type declaration\n  rec rek_type;                                                          -- variable definition\n  TYPE tab_type IS TABLE OF VARCHAR2(30) INDEX BY BINARY_INTEGER;        -- associative array type\n  tab tab_type;                                                          -- variable of type assoc. array\n  rec_dept dept%ROWTYPE;                                                 -- record variable\n  TYPE tab_type2 IS TABLE OF rec_dept%ROWTYPE INDEX BY BINARY_INTEGER;   -- array of records\n  tab2 tab_type2;\nBEGIN\n  rec.f2 := 'KING';\n  dbms_output.put_line(rec.f1||' -- '||rec.f2);                          -- default value\n  tab(1) := 'Bubu'; tab(2) := 'Baba'; tab(3) := 'Bobo';\n  FOR i IN tab.FIRST .. tab.LAST LOOP\n    dbms_output.put_line(tab(i));\n  END LOOP;\n  SELECT * INTO rec_dept FROM dept WHERE deptno = 10;\n  tab2(1) := rec_dept;\n  dbms_output.put_line(tab2(1).deptno||' -- '||tab2(1).dname||' -- '||tab2(1).loc);\nEND;\n/\n</code></pre> <pre>\nResults:\n-----------\n10 -- KING\nBubu\nBaba\nBobo\n10 -- ACCOUNTING -- NEW YORK\n</pre> <p>Index-By Table:</p> <ul> <li>An index-by table (also called an associative array) is a set of key-value pairs. Each key is unique and is used to locate the corresponding value.</li> <li>The key can be either an integer or a string.</li> <li>An index-by table is created using the following syntax. Here, we are creating an index-by table named salary_list, the keys of which will be of the subscript_type and associated values will be of the element_type.</li> </ul> <p>Nested Tables:</p> <ul> <li>A nested table is like a one-dimensional array with an arbitrary number of elements. However, a nested table differs from an array in the following aspects\u2014</li> <li>An array has a declared number of elements, but a nested table does not. The size of a nested table can increase dynamically.</li> <li>An array is always dense, i.e., it always has consecutive subscripts. A nested array is dense initially, but it can become sparse when elements are deleted from it.</li> </ul>"},{"location":"pl_sql/03_Exceptions/","title":"Exceptions","text":""},{"location":"pl_sql/03_Exceptions/#exceptions","title":"Exceptions","text":"<p>Handling Exceptions:</p> <ul> <li>Trap the exception: Exception is raised and trapped within DECLARE, BEGIN, EXCEPTION, END block.</li> <li>Propagate the exception: Exception is raised, not trapped, and propagates to calling environment.</li> </ul> <p>Exception Types:</p> <ul> <li>Predefined Oracle Server: Implicitly raised</li> <li>Non-predefined Oracle Server: Implicitly raised</li> <li>User-defined: Explicitly raised</li> </ul> <p>Trapping Exceptions Guidelines:</p> <ul> <li>WHEN OTHERS is the last clause.</li> <li>EXCEPTION keyword starts exception-handling section.</li> <li>Several exception handlers are allowed.</li> <li>Only one handler is processed before leaving the block.</li> <li>Reference the standard name in the exception-handling routine.</li> <li>Sample predefined exceptions:<ul> <li>NO_DATA_FOUND</li> <li>TOO_MANY_ROWS</li> <li>INVALID_CURSOR</li> <li>ZERO_DIVIDE</li> <li>DUP_VAL_ON_INDEX</li> </ul> </li> </ul> <pre><code>set serveroutput on\nDECLARE\n  except1 EXCEPTION;\n  PRAGMA exception_init(except1, -20000);\nBEGIN\n  raise_application_error('-20001', 'except2');   -- comment this line\n  RAISE except1;                                  -- then comment this line too \n  DECLARE\n    V NUMBER := 1/0;                              -- finally change it to 1/1\n  BEGIN\n    V := 1/0;\n  EXCEPTION \n    WHEN OTHERS THEN dbms_output.put_line('inner block');\n  END;\nEXCEPTION \n  WHEN OTHERS THEN dbms_output.put_line(SQLCODE||' ~~~ '||sqlerrm);\nEND;\n/\n</code></pre> <pre>\nResults:\n----------\nfirst output:  -20001 ~~~ ORA-20001: except2\nsecond output: -20000 ~~~ ORA-20000:\nthird output:  -1476 ~~~ ORA-01476: division by zero\nfourth output: inner block\n</pre> <p>Trapping Non-Predefined Oracle Server Errors:</p> <ul> <li>Declare: Name the exception (Declarative section)</li> <li>Associate: Code the PRAGMA EXCEPTION_INIT</li> <li>Reference: Handle the raised exception (Exception-handling section)</li> </ul> <pre><code>e_emps_remaining EXCEPTION;\nPRAGMA EXCEPTION_INIT (e_emps_remaining, -2292)\n</code></pre> <p>Trapping User-Defined Exceptions:</p> <ul> <li>Declare: Name the exception (Declarative section)</li> <li>Raise: Explicitly raise the exception by using the RAISE statement (Executable section)</li> <li>Reference: Handle the raised exception (Exception-handling section)</li> </ul> <pre><code>e_invalid_product EXCEPTION;\nRAISE e_invalid_product;\n</code></pre> <p>Functions for Trapping Exceptions:</p> <ul> <li>SQLCODE: Returns the numeric value for the error code</li> <li>SQLERRM: Returns the message associated with the error number</li> </ul> <pre><code>/* Raising an error from a subprogram */\n\nDECLARE\n  v1 NUMBER :=0;\n  FUNCTION f1 RETURN NUMBER IS\n  except1 EXCEPTION;\n  BEGIN\n    raise except1;                                    -- comment this line\n    raise_application_error('-20000', 'exception1');  -- finally comment this too\n    RETURN 10;\n  EXCEPTION \n    WHEN except1 THEN RETURN 20;\n    WHEN OTHERS THEN RETURN 30;                       -- then comment this too\n  END f1;\nBEGIN\n  v1 := f1; dbms_output.put_line(v1);\nEXCEPTION \n  WHEN OTHERS THEN dbms_output.put_line(SQLCODE||' ~~~ '||sqlerrm);\nEND;\n/\n</code></pre> <pre>\nResults:\n------------\nfirst output:   20\nsecond output:  30\nthird output:   -20000 ~~~ ORA-20000: exception1\nfourth output:  10\n</pre> <p>Calling Environments:</p> <ul> <li>SQL*Plus: Displays error number and message to screen</li> <li>Sql Developer: Displays error number and message to screen</li> <li>Oracle Developer Forms: Accesses error number and message in a trigger by means of the ERROR_CODE and ERROR_TEXT packaged functions</li> <li>Precompiler application: Accesses exception number through the SQLCA data structure</li> <li>An enclosing PL/SQL block: Traps exception in exception-handling routine of enclosing block</li> </ul> <pre><code>raise_application_error (error_number, message[, {TRUE | FALSE}]);\n</code></pre> <p>RAISE_APPLICATION_ERROR Procedure:</p> <ul> <li>A procedure that lets you issue user-defined error messages from stored subprograms</li> <li>Called only from an executing stored subprogram</li> </ul>"},{"location":"pl_sql/03_Exceptions/#predefined-exceptions","title":"Predefined exceptions","text":"<pre><code>SELECT text FROM all_source WHERE type = 'PACKAGE'\nAND name = 'STANDARD' AND lower(text) LIKE '%exception_init%';\n</code></pre> <p>Put comments before some statements (or delete comments) to test other exceptions.</p> <pre><code>SET SERVEROUTPUT ON\nBEGIN                       -- 3 nested blocks\n DECLARE\n  v1 emp.sal%TYPE;\n  v2 emp.comm%TYPE;\n  v3 INTEGER := 0;\n BEGIN\n  v3 := 1/v3;                  -- comment this second\n  BEGIN\n   SELECT sal, comm INTO v1, v2 FROM emp WHERE ename LIKE 'S%';  -- then change it to  'X%'\n  EXCEPTION\n   WHEN too_many_rows THEN \n    BEGIN\n     v1 := 1; v2 := 2;\n    END;\n  END;\n  dbms_output.put_line(to_char(v1)||' -- '|| nvl(to_char(v2), 'null'));\n\n EXCEPTION\n  WHEN zero_divide THEN dbms_output.put_line('zero divide');      -- comment this first       \n  WHEN too_many_rows THEN dbms_output.put_line('too many rows');\n END;\n dbms_output.put_line('main program');\nEXCEPTION\n  WHEN OTHERS THEN dbms_output.put_line(SQLCODE || ' -- ' || sqlerrm);\nEND;\n/\n</code></pre> <pre>\nResults:\n-----------\nfirst output:   zero divide\n                main program\nsecond output:  -1476 -- ORA-01476: division by zero\nthird output:   1 -- 2        too many rows handled\n                main program\nfourth output:  100 -- ORA-01403: No Data found\n</pre> <pre><code>-- Printing error codes\n\nBEGIN\n dbms_output.put_line(sqlerrm(-6502));\nEND;\n/\n</code></pre> <pre><code>-- put comments before the first 5 lines one by one to test other exceptions\n\nset serveroutput on\nDECLARE \n  v_nev  VARCHAR2(20);\n  v_szam NUMBER := 0;\n  CURSOR emp_cur IS SELECT ename FROM emp;\n\n  error1 EXCEPTION;\n  pragma EXCEPTION_INIT(error1, -20001);\n  error2 EXCEPTION;\n  pragma EXCEPTION_INIT(error2, -20002);\n\n  PROCEDURE err_proc(v NUMBER) IS\n  BEGIN\n    IF MOD(v, 2) = 0 THEN\n      RAISE_APPLICATION_ERROR('-20001', 'error1');\n    ELSE\n      RAISE_APPLICATION_ERROR('-20002', 'error2');\n    END IF;\n  END;\n\nBEGIN\n  err_proc(1);                                        -- error2\n  err_proc(2);                                        -- error1\n  v_szam := 1/v_szam;                                 -- zero divide\n  SELECT ename INTO v_nev FROM emp WHERE empno &lt; 0;   -- no_data found\n  SELECT ename INTO v_nev FROM emp WHERE empno &gt; 0;   -- too_many_rows\n  OPEN emp_cur;\n  LOOP\n    FETCH emp_cur INTO v_nev;\n    EXIT WHEN emp_cur%notfound;\n    dbms_output.put(v_nev||' -&gt; ');\n    dbms_output.put_line(to_char(emp_cur%rowcount));\n  END LOOP;\n  CLOSE emp_cur;\nEXCEPTION\n  WHEN error1 THEN\n    dbms_output.put_line('error1 occured');\n  WHEN error2 THEN\n    dbms_output.put_line('error2 occured');\n  WHEN zero_divide THEN\n    dbms_output.put_line('zero divide error');\n  WHEN no_data_found THEN\n    dbms_output.put_line('No Data Found error');\n  WHEN too_many_rows THEN\n    dbms_output.put_line('Too many rows error');\n  WHEN OTHERS THEN\n    dbms_output.put_line('something else ...');\nEND;\n/\n</code></pre>"},{"location":"pl_sql/03_Exceptions/#functions-and-procedures","title":"Functions and procedures","text":""},{"location":"pl_sql/03_Exceptions/#procedural-parameter-modes","title":"Procedural Parameter Modes","text":""},{"location":"pl_sql/03_Exceptions/#in-parameters","title":"IN Parameters","text":"<p>7369 \u2194 v_id</p> <pre><code>CREATE OR REPLACE PROCEDURE raise_salary\n(v_id in emp.empno%TYPE)\nIS\nBEGIN\n  UPDATE emp\n  SET sal = sal * 1.10\n  WHERE empno = v_id;\nEND raise_salary;\n/\n</code></pre> <p>Procedure created.</p> <p>SQL&gt; EXECUTE raise_salary (7369)</p> <p>PL/SQL procedure successfully completed.</p>"},{"location":"pl_sql/03_Exceptions/#out-parameters","title":"OUT Parameters","text":"<p>Calling environment</p> <pre><code>654 \u2194 v_id \u2194 v_name \u2194 v_salary \u2194 v_comm\n</code></pre> <p>QUERY_EMP procedure</p> <pre><code>v_id, MARTIN v_name, 1250 v_salary, 1400 v_comm\n</code></pre> <pre><code>CREATE OR REPLACE PROCEDURE query_emp\n(v_id IN emp.empno%TYPE,\nv_name OUT emp.ename%TYPE,\nv_salary OUT emp.sal%TYPE,\nv_comm OUT emp.comm%TYPE)\nIS\nBEGIN\n  SELECT ename, sal, comm\n  INTO v_name, v_salary, v_comm\n  FROM emp\n  WHERE empno = v_id;\nEND query_emp;\n/\n</code></pre>"},{"location":"pl_sql/03_Exceptions/#in-out-parameters","title":"IN OUT Parameters","text":"<p>Calling environment</p> <pre><code>'(800)633-0575' \u2194 v_phone_no\n</code></pre> <p>FORMAT_PHONE procedure</p> <pre><code>'(800)633-0575' v_phone_no\n</code></pre> <pre><code>CREATE OR REPLACE PROCEDURE format_phone\n(v_phone_no IN OUT VARCHAR2)\nIS\nBEGIN\n   v_phone_no := '(' || SUBSTR(v_phone_no,1,3) || ')'\n                     || SUBSTR(v_phone_no,4,3) || '-'\n                     || SUBSTR(v_phone_no,7);\nEND format_phone;\n/\n</code></pre> <pre><code>-- Some simple examples for PL/SQL functions and procedures\n-- These are local (not stored) subprograms\nDECLARE\n  num number(6);\n\n  FUNCTION func_plus_1(num number) RETURN number IS\n    v NUMBER(6);\n  BEGIN\n    v := num + 1;\n    return(v);\n  END;\n\n  PROCEDURE proc_plus_1(num number) is\n    v NUMBER(6);\n  BEGIN\n    v := num + 1;\n    dbms_output.put_line(TO_CHAR(v));\n  END;\n\nBEGIN\n  num := func_plus_1(100);\n  proc_plus_1(num);\nEND;\n/\n</code></pre> <pre>\nResults: \n-------\n102\n</pre> <pre><code>-- These are stored (in the database) subprograms, we can call them later at any time.\n\nCREATE OR REPLACE FUNCTION func_plus_2(num number) RETURN number IS\n  v NUMBER(6);\nBEGIN\n  v := num + 2;\n  return(v);\nEND;\n/      \n-- We can call the function from within SQL\nSELECT func_plus_2(1000) FROM dual;\n\nCREATE OR REPLACE PROCEDURE proc_plus_2(num number) is\n  v NUMBER(6);\nBEGIN\n  v := num + 2;\n  dbms_output.put_line(TO_CHAR(v));\nEND;\n/\n\n-- We can call the procedure\nCALL proc_plus_2(2000);\n-- Or equivalently\nEXECUTE proc_plus_2(2000);\n</code></pre> <pre><code>-- subprogram without parameter\nset serveroutput on\nDECLARE\n  num number(6) := 1;\n  PROCEDURE pr1 is           -- don't use paranthesis!\n    v NUMBER(6);\n  BEGIN\n    v := num + 1;\n    dbms_output.put_line(TO_CHAR(v));\n  END;\nBEGIN\n  pr1();    -- you can use paranthesis, but pr1 is ok too\nEND;\n/\n</code></pre>"},{"location":"pl_sql/03_Exceptions/#examples-of-passing-parameters","title":"Examples of Passing Parameters","text":"<pre><code>begin\n  add_dept(('TRAINING', 'NEW YORK'));\n  add_dept(v_loc =&gt; 'DALLAS', v_name =&gt;'EDUCATION');\n  add_dept(v_loc =&gt; 'BOSTON');\nend;\n/\n</code></pre> <pre><code>/*******  overloading   ******/\nset serveroutput on\nDECLARE\n  PROCEDURE proc1(p IN NUMBER) IS\n  BEGIN\n    DBMS_OUTPUT.PUT_LINE('number param');\n  END;\n\n  PROCEDURE proc1(p IN VARCHAR2) IS\n  BEGIN\n    DBMS_OUTPUT.PUT_LINE('varchar2 param');\n  END;\nBEGIN\n  proc1(100);\n  proc1('100');\nEND;\n/\n</code></pre> <pre>\nResults:\n---------\nnumber param\nvarchar2 param\n</pre> <pre><code>/****************** forward declaration ****************/\nset serveroutput on\nDECLARE\n  PROCEDURE proc2(p IN NUMBER);\n\n  PROCEDURE proc1(p IN NUMBER) IS\n  BEGIN\n    IF p &lt; 10 THEN  DBMS_OUTPUT.PUT_LINE(p); proc2(p+1);  END IF;\n  END;\n\n  PROCEDURE proc2(p IN NUMBER) IS\n  BEGIN\n    IF p &lt; 10 THEN  DBMS_OUTPUT.PUT_LINE(p); proc1(p*2);  END IF;\n  END;\nBEGIN\n  proc1(0);\nEND;\n/\n</code></pre> <pre>\nResults:\n---------\n0; 1; 2; 3; 6; 7;\n</pre>"},{"location":"pl_sql/03_Exceptions/#executing-functions","title":"Executing Functions","text":"<ul> <li>Invoke a function as part of a PL/SQL expression.</li> <li>Create a host variable to hold the returned value.</li> <li>Execute the function. The host variable will be populated by the RETURN value.</li> </ul>"},{"location":"pl_sql/03_Exceptions/#executing-functions-in-sqlplus","title":"Executing Functions in SQL*Plus","text":"<pre><code>-- return value of a function as a default parameter of a procedure\nset serveroutput on\nDECLARE\n  cnt pls_integer := 0;\n\n  FUNCTION dflt RETURN pls_integer IS\n  BEGIN\n    cnt := cnt + 1;         -- changes global variable cnt\n    RETURN 42;\n  END dflt;\n\n  PROCEDURE p (i IN pls_integer := dflt() ) IS    -- side effect if parameter is not provided\n  BEGIN\n    DBMS_Output.Put_Line(i);\n  END p;\n\nBEGIN\n  FOR j IN 1..3 LOOP\n   p(j);            -- Actual parameter is provided, no function call\n  END loop;\n  DBMS_Output.Put_Line('cnt: '||cnt);\n  p();              -- Actual parameter is not provided, function call, side effect\n  DBMS_Output.Put_Line('cnt: '||cnt);\nEND;\n/\n</code></pre> <pre>\nResult:\n---------\n1\n2\n3\nCnt: 0\n42\nCnt: 1\n</pre>"},{"location":"pl_sql/03_Exceptions/#calling-functions-from-sql-expressions-restrictions","title":"Calling Functions from SQL Expressions: Restrictions","text":"<ul> <li>A user-defined function must be a stored function.</li> <li>A user-defined function must be a ROW function, not a GROUP function.</li> <li>A user-defined function only takes IN parameters, not OUT, or IN OUT.</li> <li>Datatypes must be CHAR, DATE, or NUMBER, not PL/SQL types such as BOOLEAN, RECORD, or TABLE.</li> <li>Return type must be an Oracle Server internal type.</li> <li>INSERT, UPDATE, or DELETE commands are not allowed.</li> <li>Calls to subprograms that break the above restriction are not allowed.</li> </ul>"},{"location":"pl_sql/03_Exceptions/#procedure-or-function","title":"Procedure or Function?","text":"Procedure Function Execute as a PL/SQL statement Invoke as part of an expression No RETURN datatype Must contain a RETURN datatype Can return one or more values Must return a value"},{"location":"pl_sql/04_Recurson/","title":"Recursion","text":""},{"location":"pl_sql/04_Recurson/#recursion-in-sql-and-datalog","title":"Recursion in SQL and Datalog","text":"<pre><code>-- Create an empty table then insert rows:\nCREATE TABLE Flight(airline VARCHAR2(10), orig VARCHAR2(15), dest VARCHAR2(15), cost NUMBER);\n\nINSERT INTO flight VALUES('Lufthansa', 'San Francisco', 'Denver', 1000);\nINSERT INTO flight VALUES('Lufthansa', 'San Francisco', 'Dallas', 10000);\nINSERT INTO flight VALUES('Lufthansa', 'Denver', 'Dallas', 500);\nINSERT INTO flight VALUES('Lufthansa', 'Denver', 'Chicago', 2000);\nINSERT INTO flight VALUES('Lufthansa', 'Dallas', 'Chicago', 600);\nINSERT INTO flight VALUES('Lufthansa', 'Dallas', 'New York', 2000);\nINSERT INTO flight VALUES('Lufthansa', 'Chicago', 'New York', 3000);\nINSERT INTO flight VALUES('Lufthansa', 'Chicago', 'Denver', 2000);\n\n-- The tuples are not the same as in TextBook. I inserted an extra tuple \n-- in order to have a cycle in the graph of Flight table. \n--&gt; orig = 'Chicago' and dest = 'Denver';\n</code></pre>"},{"location":"pl_sql/04_Recurson/#flight-table","title":"Flight Table:","text":"Airline Origin Destination Cost Lufthansa San Francisco Denver 1000 Lufthansa San Francisco Dallas 10000 Lufthansa Denver Dallas 500 Lufthansa Denver Chicago 2000 Lufthansa Dallas Chicago 600 Lufthansa Dallas New York 2000 Lufthansa Chicago New York 3000 Lufthansa Chicago Denver 2000"},{"location":"pl_sql/04_Recurson/#datalog-programs","title":"DATALOG programs","text":"<p>Datalog is a logical query language (Data Logic). See textbook (Ullman ch. 5.3, 5.4 and 10.2)</p> <p>Let's see relation Reaches(x,y) which answers the following query.</p> <p>For what pairs of cities (x, y) is it possible to get from city x to city y by taking one or more flights?</p>"},{"location":"pl_sql/04_Recurson/#a-recursive-datalog-program-for-the-reaches-table","title":"A recursive DATALOG program for the REACHES table:","text":"<p>Reaches(X,Y)  &lt;--  Flight(,X,Y,)</p> <p>Reaches(X,Y)  &lt;--  Reaches(X,Z) AND Reaches(Z,Y) AND X &lt;&gt; Y</p> <p>Most DBMS-s allow only linear recursion in recursive queries, which means: no rule has more than one subgoal that is mutually recursive with the head. </p> <p>---&gt; if there is a cycle involving R and S, they are mutually recursive</p> <p>In the previous datalog program the second rule violates this requirement.</p> <p>The datalog program below contains only linear recursion:</p> <p>Reaches(X,Y)  &lt;--  Flight(,X,Y,)</p> <p>Reaches(X,Y)  &lt;--  Flight(,X,Z,) AND Reaches(Z,Y) AND X &lt;&gt; Y</p> <pre><code>-- SQL query  (Flight is the first edge on the route)\n---------\nWITH  reaches(orig, dest) AS \n (\n  SELECT orig, dest FROM flight\n   UNION ALL\n  SELECT flight.orig, reaches.dest FROM flight, reaches\n  WHERE flight.dest = reaches.orig AND flight.orig &lt;&gt; reaches.dest\n  )\n  CYCLE orig, dest SET is_cycle TO 'Y' DEFAULT 'N' \nSELECT  distinct orig, dest, is_cycle FROM reaches order by 1,2,3;\n</code></pre> <pre>\nResults:\n---------\nChicago Dallas  N\nChicago Denver  N\nChicago New York N\nChicago New York Y\nDallas Chicago  N\n...\n</pre> <pre><code>-- Another SQL query  (Flight is the last edge on the route)\n-----------------\nWITH  reaches(orig, dest) AS \n (\n  SELECT orig, dest FROM flight\n   UNION ALL\n  SELECT reaches.orig, flight.dest FROM reaches, flight\n  WHERE reaches.dest = flight.orig  AND reaches.orig &lt;&gt; flight.dest\n  )\n  CYCLE orig, dest SET is_cycle TO 'Y' DEFAULT 'N' \nSELECT  distinct orig, dest, is_cycle FROM reaches order by 1,2,3;\n</code></pre> <pre>\nResults:\n---------\nChicago Dallas     N\nChicago Denver      N\nChicago New York    N\nDallas Chicago     N\nDallas Chicago     Y\nDallas Denver     N\nDallas New York    N\nDenver Chicago     N\n...\n</pre> <pre><code>-- SQL query with non-linear recursion      ---&gt; Error message below\n-----------------------------------\nWITH  reaches(orig, dest) AS \n (\n  SELECT orig, dest FROM flight\n   UNION ALL\n  SELECT r1.orig, r2.dest FROM reaches r1, reaches r2\n  WHERE r1.dest = r2.orig AND r1.orig &lt;&gt; r2.dest\n  )\n  CYCLE orig,dest SET is_cycle TO 'Y' DEFAULT 'N' \nSELECT  distinct orig, dest, is_cycle FROM reaches order by 1,2,3;\n</code></pre> <pre>\nError message:\n--------------\n32490. 00000 -  \"recursive query name referenced more than once in recursive branch of recursive WITH clause element\"\n*Cause:    The recursive component of the UNION ALL in a recursive WITH clause\n           element referenced the recursive query name more than once.  Only\n           one reference to the recursive query name is allowed in the\n           recursive branch of a recursive WITH clause element.\n</pre> <pre><code>-- SQL query which lists the edges on the route\n--------------------------------------------\nWITH  reaches(orig, dest, edges) AS \n (\n  SELECT orig, dest, orig||'.'||dest FROM flight\n   UNION ALL\n  SELECT reaches.orig, flight.dest, reaches.edges||'.'||flight.dest FROM reaches, flight\n  WHERE reaches.dest = flight.orig  AND reaches.orig &lt;&gt; flight.dest\n  )\n  CYCLE orig,dest SET is_cycle TO 'Y' DEFAULT 'N' \nSELECT  distinct orig, dest, edges, is_cycle FROM reaches order by 1,2,3;\n</code></pre> <pre>\nResults:\n---------\nChicago Dallas     Chicago.Denver.Dallas           N\nChicago Denver     Chicago.Denver                  N\nChicago New York    Chicago.Denver.Dallas.New York  N\nChicago New York    Chicago.New York                N\nDallas Chicago     Dallas.Chicago                  N\nDallas Chicago     Dallas.Chicago.Denver.Chicago   Y\n...\n</pre>"},{"location":"pl_sql/04_Recurson/#another-recursion-in-sql-start-with-connect-by","title":"Another recursion in SQL  (START WITH, CONNECT BY)","text":"<pre><code>SELECT ... FROM ... WHERE ...\nSTART WITH condition\nCONNECT BY condition\n</code></pre> <p>This is a special SQL query type by which we can query tree structures (graphs).</p> <p>We identify the root of the tree with START WITH condition.</p> <p>We identify the parent-child relationship with CONNECT BY condition.</p> <p>In CONNECT BY we have to use the PRIOR keyword to distinguish the column of a parent and a child node (row).</p> <ul> <li>START WITH -&gt; finds root node (or root nodes)</li> <li>CONNECT BY -&gt; relationship between parent and child rows (we should use PRIOR for parent rows)</li> </ul>"},{"location":"pl_sql/04_Recurson/#steps-of-evaluation-in-recursive-queries","title":"Steps of evaluation in recursive queries","text":"<ol> <li>START WITH selects root nodes (rows)</li> <li>CONNECT BY finds children of roots</li> <li>Finds ancestors with a depth first strategy</li> <li>WHERE filters rows. If condition is TRUE, record remains in result set.</li> <li>Returns rows in preorder traversal.</li> </ol> <p>If a SELECT uses CONNECT BY, take care with JOINS.</p> <p>We can use several conditions after CONNECT BY. eg.</p> <p>CONNECT BY PRIOR empno = mgr AND sal &gt; comm</p> <p>empno -&gt; parent node or record (see PRIOR), other columns -&gt; child node (record)</p>"},{"location":"pl_sql/04_Recurson/#prior-is-a-unary-operator","title":"PRIOR is a unary operator","text":"<p>We must use PRIOR in CONNECT BY clause at least once, otherwise we cannot express the parent-child relationship.</p>"},{"location":"pl_sql/04_Recurson/#level-pszeudo-column","title":"LEVEL pszeudo column","text":"<p>It returns 1 for root nodes, 2 for their children, etc.</p> <pre><code>-- Example:\n--------\nSELECT   LPAD(' ', 2*(LEVEL-1)) || ename, empno, mgr, job, LEVEL\nFROM nikovits.emp\nSTART WITH   job='PRESIDENT'\nCONNECT BY  PRIOR empno = mgr;\n</code></pre> <pre>\nResults:\n---------\nKING 7839 PRESIDENT 1\n  JONES 7566 7839 MANAGER 2\n    SCOTT 7788 7566 ANALYST 3\n      ADAMS 7876 7788 CLERK 4\n    FORD 7902 7566 ANALYST 3\n      SMITH 7369 7902 CLERK 4\n  BLAKE 7698 7839 MANAGER 2\n</pre>"},{"location":"pl_sql/04_Recurson/#ordering-siblings","title":"Ordering siblings","text":"<p>ORDER BY  -&gt; SIBLINGS [NULLS FIRST | NULLS LAST] </p> <pre><code>-- Example:\n--------\nSELECT   LPAD(' ', 2*(LEVEL-1)) || ename, empno, mgr, job, LEVEL\nFROM nikovits.emp\nSTART WITH   job='PRESIDENT'\nCONNECT BY  PRIOR empno = mgr\nORDER SIBLINGS BY ename;  --  [NULLS FIRST | LAST]\n</code></pre> <pre>\nResults:\n---------\nKING 7839 PRESIDENT 1\n  BLAKE 7698 7839 MANAGER 2\n    ALLEN 7499 7698 SALESMAN 3\n    JAMES 7900 7698 CLERK 3\n    MARTIN 7654 7698 SALESMAN 3\n    TURNER 7844 7698 SALESMAN 3\n    WARD 7521 7698 SALESMAN 3\n  CLARK 7782 7839 MANAGER 2\n    MILLER 7934 7782 CLERK 3\n</pre> <p>We can use aggregation and grouping in these queries.</p> <pre><code>-- Example:\n--------\n-- Give the sum money of the grandchildren of KAIN.\n\nSELECT   SUM(money) -- LPAD(' ', 2*(LEVEL-1)) || name, parent, money\nFROM nikovits.parentof\nWHERE LEVEL = 3\nSTART WITH  name='KAIN'\nCONNECT BY  PRIOR name = parent;\n</code></pre> <pre>\nResults:\n---------\n683000\n</pre> <pre><code>-- A new table: ParentOf(name, parent, money, city)\n------------------------------------------------\nCREATE TABLE ParentOf(name, parent, money, city)\nAS SELECT nev, decode(apja, 'NINCS', 'NO', apja), vagyon, varos FROM nikovits.vagyonok;\n-- grant select on parentof to public;\n\n-- Compare the following queries and notice the role of PRIOR operator.\n\n-- ABEL's all descendants\nSELECT  LPAD(' ', 2*(LEVEL-1)) || name, parent, money\nFROM nikovits.parentof\nWHERE name like '%%'     -- we could omit WHERE clause\nSTART WITH  name='ABEL'\nCONNECT BY  PRIOR name = parent;\n</code></pre> <pre>\nResults:\n---------\nABEL ADAM 280000\n  JANOS ABEL 190000\n    PAL JANOS 133000\n    PETER JANOS 143000\n      MARCSA PETER 177000\n    ROBERT JANOS 131000\n  JOZSEF ABEL 150000\n    BELA JOZSEF 157000\n      GIZI BELA 100000\n    BOTOND JOZSEF 190000\n</pre> <pre><code>-- ABEL's descendants whose all ancestors have a letter 'A' in his name\nSELECT  LPAD(' ', 2*(LEVEL-1)) || name, parent, money\nFROM nikovits.parentof\nWHERE name like '%%'\nSTART WITH  name='ABEL'\nCONNECT BY  PRIOR name = parent and prior name like '%A%';\n</code></pre> <pre>\nResults:\n---------\nABEL ADAM 280000\n  JANOS ABEL 190000\n    PAL JANOS 133000\n    PETER JANOS 143000\n    ROBERT JANOS 131000\n  JOZSEF ABEL 150000\n</pre> <pre><code>-- ABEL's descendants who and whose all ancestors have a letter 'A' in his name\n-- No PRIOR in second condition of CONNECT BY\nSELECT  LPAD(' ', 2*(LEVEL-1)) || name, parent, money\nFROM nikovits.parentof\nWHERE name like '%%'\nSTART WITH  name='ABEL'\nCONNECT BY  PRIOR name = parent and name like '%A%';\n</code></pre> <pre>\nResults:\n---------\nABEL ADAM 280000\n  JANOS ABEL 190000\n    PAL JANOS 133000\n</pre>"},{"location":"pl_sql/04_Recurson/#connect_by_root-operator","title":"CONNECT_BY_ROOT operator","text":"<p>At any level we can refer to a column of the root node with this operator.</p> <pre><code>-- Example:\n--------\n-- Give the names whose city is the same as ADAM's city.\n\nSELECT  LPAD(' ', 2*(LEVEL-1)) || name, parent, city, CONNECT_BY_ROOT city\nFROM nikovits.parentof\nWHERE city = CONNECT_BY_ROOT city\nSTART WITH  name='ADAM'\nCONNECT BY  PRIOR name = parent;\n</code></pre> <pre>\nResults:\n---------\nADAM NO Budapest Budapest\n  ABEL ADAM Budapest Budapest\n      PETER JANOS Budapest Budapest\n        MARCSA PETER Budapest Budapest\n    SAMU BARNA Budapest Budapest\n    BALAZS KAIN Budapest Budapest\n</pre>"},{"location":"pl_sql/04_Recurson/#sys_connect_by_path-function-sys_connect_by_pathcolumn-char","title":"SYS_CONNECT_BY_PATH function: SYS_CONNECT_BY_PATH(column, char)","text":"<p>SYS_CONNECT_BY_PATH concatenates the given column of the nodes from root to actual node.</p> <p>Second parameter is the delimeter character (or string).</p> <pre><code>-- Example:\n--------\nSELECT  name, SYS_CONNECT_BY_PATH(name,'.'), SYS_CONNECT_BY_PATH(city,'.')\nFROM nikovits.parentof\nSTART WITH  name='ADAM'\nCONNECT BY  PRIOR name = parent;\n</code></pre> <pre>\nResults:\n---------\nADAM .ADAM .Budapest\nABEL .ADAM.ABEL .Budapest.Budapest\nJANOS .ADAM.ABEL.JANOS .Budapest.Budapest.Eger\nPAL .ADAM.ABEL.JANOS.PAL .Budapest.Budapest.Eger.Szeged\nPETER .ADAM.ABEL.JANOS.PETER .Budapest.Budapest.Eger.Budapest\nMARCSA .ADAM.ABEL.JANOS.PETER.MARCSA .Budapest.Budapest.Eger.Budapest.Budapest\nROBERT .ADAM.ABEL.JANOS.ROBERT .Budapest.Budapest.Eger.Eger\nJOZSEF .ADAM.ABEL.JOZSEF .Budapest.Budapest.Szeged\n...\n</pre> <p>If the graph has a cycle we have to use NOCYCLE keyword.</p> <pre><code>-- Our earlier example about flights (The SQL statements below show how I created your table.)\n---------------------------------\nCREATE TABLE Flight(airline, orig, dest, cost)\nAS SELECT legitarsasag, honnan, hova, koltseg from nikovits.jaratok;\nGRANT select on flight to public;\n\n-- or CREATE an empty table then insert rows:\nCREATE TABLE Flight(airline VARCHAR2(10), orig VARCHAR2(15), dest VARCHAR2(15), cost NUMBER);\n\nINSERT INTO flight VALUES('Lufthansa', 'San Francisco', 'Denver', 1000);\nINSERT INTO flight VALUES('Lufthansa', 'San Francisco', 'Dallas', 10000);\nINSERT INTO flight VALUES('Lufthansa', 'Denver', 'Dallas', 500);\nINSERT INTO flight VALUES('Lufthansa', 'Denver', 'Chicago', 2000);\nINSERT INTO flight VALUES('Lufthansa', 'Dallas', 'Chicago', 600);\nINSERT INTO flight VALUES('Lufthansa', 'Dallas', 'New York', 2000);\nINSERT INTO flight VALUES('Lufthansa', 'Chicago', 'New York', 3000);\nINSERT INTO flight VALUES('Lufthansa', 'Chicago', 'Denver', 2000);\n\n-- There is a cycle in the graph of Flight table. \n-- If we delete the last row, there will be no cycle in the graph.\n\ndelete from flight where orig='Chicago' and dest='Denver';\n</code></pre> <pre><code>-- Example:\n--------\n-- Which cities can be reached from San Francisco?\n\nSELECT LPAD(' ', 4*level) ||orig, dest, level-1 turnovers\nFROM flight\nSTART WITH orig = 'San Francisco'\nCONNECT BY PRIOR dest = orig;\n</code></pre> <pre>\nResults:\n---------\nSan Francisco Dallas 0\n    Dallas Chicago 1\n        Chicago New York 2\n    Dallas New York 1\nSan Francisco Denver 0\n    Denver Chicago 1\n        Chicago New York 2\n    Denver Dallas 1\n        Dallas Chicago 2\n            Chicago New York 3\n        Dallas New York 2\n</pre> <pre><code>-- The previous SELECT doesn't work if there is a cycle in the graph.\n-- Use the following instead (-&gt; NOCYCLE):\n\nSELECT LPAD(' ', 4*level) ||orig, dest, level-1 turnovers\nFROM flight\nSTART WITH orig = 'San Francisco'\nCONNECT BY NOCYCLE PRIOR dest = orig;\n</code></pre> <pre>\nResults:\n--------- \nSan Francisco Dallas 0\n    Dallas Chicago 1\n        Chicago New York 2\n    Dallas New York 1\nSan Francisco Denver 0\n    Denver Chicago 1\n        Chicago New York 2\n    Denver Dallas 1\n        Dallas Chicago 2\n            Chicago New York 3\n        Dallas New York 2\n</pre>"},{"location":"pl_sql/04_Recurson/#other-pszeudo-columns","title":"Other pszeudo columns","text":"<ul> <li>CONNECT_BY_ISCYCLE: returns 1 if actual row has a child that is an ancestor of it too. (So, it would mean a cycle.)</li> <li>CONNECT_BY_ISLEAF:  returns 1 if actual row has no child. (or has only child that was an ancestor)</li> </ul> <pre><code>-- Example:\n--------\n-- List the routes from San Francisco.\n\nSELECT CONNECT_BY_ROOT orig AS first, dest AS final_dest, LEVEL, \n       SYS_CONNECT_BY_PATH(orig, '-&gt;')||'-&gt;'||dest \"route\",        -- we concatenate the final dest at the end\n       CONNECT_BY_ISCYCLE, CONNECT_BY_ISLEAF\nFROM flight                                                       \nSTART WITH orig='San Francisco'\nCONNECT BY NOCYCLE PRIOR dest = orig\nORDER BY LEVEL;\n</code></pre> <pre>\nResults:\n---------\nSan Francisco Dallas 1 -&gt;San Francisco-&gt;Dallas 0 0\nSan Francisco Denver 1 -&gt;San Francisco-&gt;Denver 0 0\nSan Francisco New York 2 -&gt;San Francisco-&gt;Dallas-&gt;New York 0 1\nSan Francisco Chicago 2 -&gt;San Francisco-&gt;Dallas-&gt;Chicago 0 0\nSan Francisco Chicago 2 -&gt;San Francisco-&gt;Denver-&gt;Chicago 0 0\nSan Francisco Dallas 2 -&gt;San Francisco-&gt;Denver-&gt;Dallas 0 0\nSan Francisco New York 3 -&gt;San Francisco-&gt;Denver-&gt;Chicago-&gt;New York 0 1\n</pre> <p>Let's see our earlier query based on a Datalog query</p> <p>Reaches(X,Y)  &lt;--  Flight(X,Y)</p> <p>Reaches(X,Y)  &lt;--  Flight(X,Z) AND Reaches(Z,Y) AND X &lt;&gt; Y</p> <pre><code>-- SQL query\n---------\n\nWITH  reaches(orig, dest) AS \n (\n  SELECT orig, dest FROM flight\n   UNION ALL\n  SELECT flight.orig, reaches.dest FROM flight, reaches\n  WHERE flight.dest = reaches.orig AND flight.orig &lt;&gt; reaches.dest\n  )\n  CYCLE orig SET is_cycle TO 'Y' DEFAULT 'N' \nSELECT  distinct orig, dest FROM reaches order by orig, dest;\n</code></pre> <pre>\nResults:\n---------\nChicago New York\nDallas Chicago\nDallas New York\nDenver Chicago\nDenver Dallas\nDenver New York\nSan Francisco Chicago\nSan Francisco Dallas\nSan Francisco Denver\nSan Francisco New York\n</pre> <pre><code>-- Create the Reaches table from Flight table with a CONNECT BY query\n------------------------------------------------------------------\n\nSELECT distinct CONNECT_BY_ROOT orig AS orig, dest AS dest\nFROM flight\nWHERE CONNECT_BY_ROOT orig &lt;&gt; dest\nSTART WITH 1=1                         -- we start recursion from each node\nCONNECT BY NOCYCLE PRIOR dest = orig\nORDER BY orig, dest;\n\n-- With recursive statement 'WITH' we can compute (produce) new values, but with\n-- 'CONNECT BY' we can get only existing values from our table.\n-- The query below couldn't be produced by a 'CONNECT BY' recursive query, e.g.\n</code></pre> <pre>\nResults:\n---------\nChicago New York\nDallas Chicago\nDallas New York\nDenver Chicago\nDenver Dallas\nDenver New York\nSan Francisco Chicago\nSan Francisco Dallas\nSan Francisco Denver\nSan Francisco New York\n</pre>"},{"location":"pl_sql/04_Recurson/#produce-a-relation-factorialn-val-where-val-n","title":"Produce a relation Factorial(n, val) where val = n!","text":"<p>Factor(X, Y) &lt;-- X=0 AND Y=1</p> <p>Factor(X, Y) &lt;-- Factor(Z, V) AND X=Z+1 AND Y=X*V AND X &lt; 40    </p> <p>(--&gt; X &lt; 40: not to produce an infinite relation, see \"safety\" of a DATALOG rule)</p> <pre><code>WITH  factorial(n, val) AS \n (\n  SELECT 0, 1 FROM dual\n   UNION ALL\n  SELECT n+1, (n+1)*val FROM factorial\n  WHERE n &lt; 40                          \n  )\n  CYCLE n SET is_cycle TO 'Y' DEFAULT 'N'   -- we can omit this line, there is no cycle\nSELECT  n, val FROM factorial order by 1;\n</code></pre> <pre>\nResults:\n---------\n0 1\n1 1\n2 2\n3 6\n4 24\n5 120\n6 720\n7 5040\n8 40320\n9 362880\n10 3628800\n11 39916800\n...\n</pre>"},{"location":"pl_sql_optimization/none/","title":"No contents","text":""},{"location":"sql/01_Introduction/","title":"Introduction","text":""},{"location":"sql/01_Introduction/#introduction","title":"Introduction","text":"<ul> <li>Dr. E. F. Codd proposed the relational model fordatabase systems in 1970.</li> <li>It is the basis for the relational databasemanagement system (RDBMS).</li> <li>The relational model consists of the following:<ul> <li>Collection of objects or relations</li> <li>Set of operators to act on the relations</li> <li>Data integrity for accuracy and consistency</li> </ul> </li> </ul> <p>A relational database is a collection of relations or two dimensional tables.</p> <p></p>"},{"location":"sql/01_Introduction/#data-models","title":"Data models","text":""},{"location":"sql/01_Introduction/#entity-relationship-model","title":"Entity Relationship Model","text":"<p>Create an entity relationship diagram frombusiness specifications or narratives:</p> <p></p> <p>Scenario:</p> <ul> <li>\u201c. . . Assign one or more employees to adepartment . . .\u201d</li> <li>\u201c. . . Some nikovits.departments do not yet have assignedemployees . . .\u201d</li> </ul>"},{"location":"sql/01_Introduction/#entity-relationship-modeling-conventions","title":"Entity Relationship Modeling Conventions","text":""},{"location":"sql/01_Introduction/#relating-multiple-tables","title":"Relating Multiple Tables","text":"<ul> <li>Each row of data in a table is uniquely identified bya primary key (PK).</li> <li>You can logically relate data from multiple tablesusing foreign keys (FK).</li> </ul>"},{"location":"sql/01_Introduction/#relational-database-terminology","title":"Relational Database Terminology","text":""},{"location":"sql/01_Introduction/#relational-database-properties","title":"Relational Database Properties:","text":"<ul> <li>Can be accessed and modified by executingstructured query language (SQL) statements</li> <li>Contains a collection of tables with no physicalpointers</li> <li>Uses a set of operators</li> </ul>"},{"location":"sql/02_Basic_sql_statements/","title":"Basic SQL Statements","text":""},{"location":"sql/02_Basic_sql_statements/#communicating-with-an-rdbms-using-sql","title":"Communicating with an RDBMS Using SQL","text":""},{"location":"sql/02_Basic_sql_statements/#sql-statements","title":"SQL Statements","text":""},{"location":"sql/02_Basic_sql_statements/#order-of-statements","title":"Order of Statements","text":""},{"location":"sql/02_Basic_sql_statements/#tables-used-in-the-course","title":"Tables Used in the Course","text":""},{"location":"sql/02_Basic_sql_statements/#capabilities-of-sql-select-statements","title":"Capabilities of SQL SELECT Statements","text":""},{"location":"sql/02_Basic_sql_statements/#basic-select-statement","title":"Basic SELECT Statement","text":"<pre><code>SELECT * | {[DISTINCT] column|expression [alias], ...}\nFROM table;\n</code></pre> <ul> <li>SELECT identifies the columns to be displayed</li> <li>FROM identifies the table containing those columns</li> </ul>"},{"location":"sql/02_Basic_sql_statements/#selecting-all-columns","title":"Selecting All Columns","text":"<pre><code>SELECT * FROM nikovits.departments;\n</code></pre> DEPARTMENT_ID DEPARTMENT_NAME MANAGER_ID LOCATION_ID 10 Administration 200 1700 20 Marketing 201 1800 30 Purchasing 114 1700 40 Human Resources 203 2400 50 Shipping 121 1500 60 IT 103 1400 70 Public Relations 204 2700 80 Sales 145 2500 90 Executive 100 1700 100 Finance 108 1700 110 Accounting 205 1700 120 Treasury NULL 1700 130 Corporate Tax NULL 1700"},{"location":"sql/02_Basic_sql_statements/#selecting-specific-columns","title":"Selecting Specific Columns","text":"<pre><code>SELECT department_id, location_id\nFROM nikovits.departments;\n</code></pre> DEPARTMENT_ID LOCATION_ID 10 1700 20 1800 30 1700 40 2400 50 1500 60 1400 70 2700 80 2500 90 1700 100 1700 110 1700 120 1700 130 1700 140 1700 150 1700 160 1700"},{"location":"sql/02_Basic_sql_statements/#writing-sql-statements","title":"Writing SQL Statements","text":"<ul> <li>SQL statements are not case-sensitive.</li> <li>SQL statements can be on one or more lines.</li> <li>Keywords cannot be abbreviated or splitacross lines.</li> <li>Clauses are usually placed on separate lines.</li> <li>Indents are used to enhance readability.</li> <li>In SQL*Plus, SQL statements can optionally beterminated by a semicolon (;). Semicolons arerequired if you execute multiple SQLstatements.</li> </ul>"},{"location":"sql/02_Basic_sql_statements/#arithmetic-expressions","title":"Arithmetic Expressions","text":"Operator Description + Add - Subtract * Multiply / Divide"},{"location":"sql/02_Basic_sql_statements/#using-arithmetic-operators","title":"Using Arithmetic Operators","text":"<pre><code>SELECT last_name, salary, salary + 300\nFROM nikovits.employees;\n</code></pre> LAST_NAME SALARY SALARY+300 King 24000 24300 Kochhar 17000 17300 De Haan 17000 17300 Hunold 9000 9300 Ernst 6000 6300 Austin 4800 5100 Pataballa 4800 5100 Lorentz 4200 4500 Greenberg 12000 12300 Faviet 9000 9300 Chen 8200 8500 Sciarra 7700 8000 Urman 7800 8100"},{"location":"sql/02_Basic_sql_statements/#operator-precedence","title":"Operator Precedence","text":"<pre><code>SELECT last_name, salary, 12*salary+100\nFROM nikovits.employees;\n</code></pre> LAST_NAME SALARY 12*SALARY+100 King 24000 288100 Kochhar 17000 204100 De Haan 17000 204100 Hunold 9000 108100 Ernst 6000 72100 Austin 4800 57700 Pataballa 4800 57700 Lorentz 4200 50500 Greenberg 12000 144100 Faviet 9000 108100 Chen 8200 98500 Sciarra 7700 92500 <pre><code>SELECT last_name, salary, 12*(salary+100)\nFROM nikovits.employees;\n</code></pre> LAST_NAME SALARY 12*(SALARY+100) King 24000 289200 Kochhar 17000 205200 De Haan 17000 205200 Hunold 9000 109200 Ernst 6000 73200 Austin 4800 58800 Pataballa 4800 58800 Lorentz 4200 51600 Greenberg 12000 145200 Faviet 9000 109200 Chen 8200 99600 Sciarra 7700 93600 Urman 7800 94800"},{"location":"sql/02_Basic_sql_statements/#defining-a-null-value","title":"Defining a Null Value","text":"<ul> <li>A null is a value that is unavailable, unassigned,unknown, or inapplicable.</li> <li>A null is not the same as a zero or a blank space.</li> </ul> <pre><code>SELECT last_name, job_id, salary, commission_pct\nFROM nikovits.employees;\n</code></pre> LAST_NAME JOB_ID SALARY COMMISSION_PCT King AD_PRES 24000 NULL Kochhar AD_VP 17000 NULL De Haan AD_VP 17000 NULL Hunold IT_PROG 9000 NULL Ernst IT_PROG 6000 NULL Austin IT_PROG 4800 NULL Pataballa IT_PROG 4800 NULL Lorentz IT_PROG 4200 NULL Greenberg FI_MGR 12000 NULL Faviet FI_ACCOUNT 9000 NULL Chen FI_ACCOUNT 8200 NULL Sciarra FI_ACCOUNT 7700 NULL Urman FI_ACCOUNT 7800 NULL"},{"location":"sql/02_Basic_sql_statements/#null-values-in-arithmetic-expressions","title":"Null Values in Arithmetic Expressions","text":"<p>Arithmetic expressions containing a null value evaluate to null.</p> <pre><code>SELECT last_name, 12*salary*commission_pct\nFROM nikovits.employees;\n</code></pre> LAST_NAME 12SALARYCOMMISSION_PCT King NULL Kochhar NULL De Haan NULL Hunold NULL Ernst NULL Austin NULL Pataballa NULL Lorentz NULL Greenberg NULL Faviet NULL Chen NULL Sciarra NULL Urman NULL"},{"location":"sql/02_Basic_sql_statements/#defining-a-column-alias","title":"Defining a Column Alias","text":"<ul> <li>Renames a column heading</li> <li>Is useful with calculations</li> <li>Immediately follows the column name (There canalso be the optional AS keyword between thecolumn name and alias.)</li> <li>Requires double quotation marks if it containsspaces or special characters or if it is case-sensitive</li> </ul>"},{"location":"sql/02_Basic_sql_statements/#using-column-aliases","title":"Using Column Aliases","text":"<pre><code>SELECT last_name AS name, commission_pct comm\nFROM nikovits.employees;\n</code></pre> NAME COMM King NULL Kochhar NULL De Haan NULL Hunold NULL Ernst NULL Austin NULL Pataballa NULL Lorentz NULL Greenberg NULL Faviet NULL Chen NULL Sciarra NULL Urman NULL <pre><code>SELECT last_name \"Name\" , salary*12 \"Annual Salary\"\nFROM nikovits.employees;\n</code></pre> Name Annual Salary King 288000 Kochhar 204000 De Haan 204000 Hunold 108000 Ernst 72000 Austin 57600 Pataballa 57600 Lorentz 50400 Greenberg 144000 Faviet 108000 Chen 98400 Sciarra 92400 Urman 93600"},{"location":"sql/02_Basic_sql_statements/#concatenation-operator","title":"Concatenation Operator","text":"<ul> <li>Links columns or character strings to other columns</li> <li>Is represented by two vertical bars (||)</li> <li>Creates a resultant column that is a characterexpression</li> </ul> <pre><code>SELECT last_name||job_id AS \"Employees\"\nFROM nikovits.employees;\n</code></pre> Employees KingAD_PRES KochharAD_VP De HaanAD_VP HunoldIT_PROG ErnstIT_PROG AustinIT_PROG PataballaIT_PROG LorentzIT_PROG GreenbergFI_MGR FavietFI_ACCOUNT ChenFI_ACCOUNT SciarraFI_ACCOUNT UrmanFI_ACCOUNT"},{"location":"sql/02_Basic_sql_statements/#literal-character-strings","title":"Literal Character Strings","text":"<ul> <li>A literal is a character, a number, or a date that is included in the SELECT statement.</li> <li>Date and character literal values must beenclosed by single quotation marks.</li> <li>Each character string is output once for eachrow returned.</li> </ul> <pre><code>SELECT last_name ||' is a '||job_id\nAS \"Employee Details\"\nFROM nikovits.employees;\n</code></pre>"},{"location":"sql/02_Basic_sql_statements/#alternative-quoteq-operator","title":"Alternative Quote(q) Operator","text":"<ul> <li>Specify your own quotation mark delimiter</li> <li>Choose any delimiter (or {}, [], &lt;&gt; pairs)</li> <li>Increase readability and usability</li> </ul> <pre><code>SELECT department_name ||\n        q'[, it's assigned Manager Id: ]'\n        || manager_id\n        AS \"Department and Manager\"\nFROM nikovits.departments;\n</code></pre>"},{"location":"sql/02_Basic_sql_statements/#duplicate-rows","title":"Duplicate Rows","text":"<pre><code>SELECT department_id\nFROM nikovits.employees;\n</code></pre> DEPARTMENT_ID 90 90 90 60 60 60 60 60 100 100 100 100 100 100 30 30 <pre><code>SELECT DISTINCT department_id\nFROM nikovits.employees;\n</code></pre> DEPARTMENT_ID 100 30 NULL 90 20 70 110 50 80 40 60 10"},{"location":"sql/02_Basic_sql_statements/#sql-statements-versus-sqlplus-commands","title":"SQL Statements Versus SQL*Plus Commands","text":"SQL SQL*Plus A language An environment ANSI standard Oracle-proprietary Keyword cannot be abbreviated Keywords can be abbreviated Statements manipulate data and table definitions in the database Commands do not allow manipulation of values in the database Runs in database Runs on a client machine"},{"location":"sql/02_Basic_sql_statements/#displaying-table-structure","title":"Displaying Table Structure","text":"<pre><code>DESCRIBE nikovits.employees\n</code></pre>"},{"location":"sql/02_Basic_sql_statements/#limiting-the-rows-that-are-selected","title":"Limiting the Rows That Are Selected","text":"<p>Restrict the rows that are returned by using the WHERE clause.</p> <pre><code>SELECT * | {[DISTINCT] column|expression [alias], ...}\nFROM table\n[WHERE condition(s)];\n</code></pre> <p>The WHERE clause follows the FROM clause.</p> <pre><code>SELECT employee_id, last_name, job_id, department_id\nFROM nikovits.employees\nWHERE department_id = 90 ;\n</code></pre> EMPLOYEE_ID LAST_NAME JOB_ID DEPARTMENT_ID 100 King AD_PRES 90 101 Kochhar AD_VP 90 102 De Haan AD_VP 90"},{"location":"sql/02_Basic_sql_statements/#character-strings-and-dates","title":"Character Strings and Dates","text":"<ul> <li>Character strings and date values are enclosed bysingle quotation marks.</li> <li>Character values are case-sensitive, and date valuesare format-sensitive.</li> <li>The default date format is DD-MON-YY.</li> </ul> <p>You can change the default date format with:</p> <pre><code>ALTER SESSION SET nls_date_format='yyyy.mm.dd';\n</code></pre> <pre><code>SELECT last_name, job_id, department_id\nFROM nikovits.employees\nWHERE last_name = 'Whalen' ;\n</code></pre> LAST_NAME JOB_ID DEPARTMENT_ID Whalen AD_ASST 10"},{"location":"sql/02_Basic_sql_statements/#comparison-conditions","title":"Comparison Conditions","text":"Operator Meaning = Equal to &gt; Greater than &gt;= Greater than or equal to &lt; Less than &lt;= Less than or equal to &lt;&gt; Not equal to BETWEEN ... AND ... Between two values (inclusive) IN (set) Match any of a list of values LIKE Match a character pattern IS NULL Is a null value <pre><code>SELECT last_name, salary\nFROM nikovits.employees\nWHERE salary &lt;= 3000 ;\n</code></pre> LAST_NAME SALARY Baida 2900 Tobias 2800 Himuro 2600 Colmenares 2500 Mikkilineni 2700 Landry 2400 Markle 2200 Atkinson 2800 Marlow 2500 Olson 2100 Rogers 2900 Gee 2400 Philtanker 2200"},{"location":"sql/02_Basic_sql_statements/#use-the-between-condition-to-display-rows-based-on-arange-of-values","title":"Use the BETWEEN condition to display rows based on arange of values:","text":"<pre><code>SELECT last_name, salary\nFROM nikovits.employees\nWHERE salary BETWEEN 2500 AND 3500 ;\n</code></pre> LAST_NAME SALARY Khoo 3100 Baida 2900 Tobias 2800 Himuro 2600 Colmenares 2500 Nayer 3200 Mikkilineni 2700 Bissot 3300 Atkinson 2800 Marlow 2500 Mallin 3300 Rogers 2900"},{"location":"sql/02_Basic_sql_statements/#use-the-in-membership-condition-to-test-for-values-in-a-list","title":"Use the IN membership condition to test for values in a list:","text":"<pre><code>SELECT employee_id, last_name, salary, manager_id\nFROM nikovits.employees\nWHERE manager_id IN (100, 101, 201) ;\n</code></pre> EMPLOYEE_ID LAST_NAME SALARY MANAGER_ID 101 Kochhar 17000 100 102 De Haan 17000 100 108 Greenberg 12000 101 114 Raphaely 11000 100 120 Weiss 8000 100 121 Fripp 8200 100 122 Kaufling 7900 100 123 Vollman 6500 100 124 Mourgos 5800 100 145 Russell 14000 100 146 Partners 13500 100"},{"location":"sql/02_Basic_sql_statements/#using-the-like-condition","title":"Using the LIKE Condition","text":"<ul> <li>Use the LIKE condition to perform wildcardsearches of valid search string values.</li> <li>Search conditions can contain either literalcharacters or numbers:<ul> <li>% denotes zero or many characters.</li> <li>_ denotes one character.</li> </ul> </li> </ul> <pre><code>SELECT first_name\nFROM nikovits.employees\nWHERE first_name LIKE 'S%' ;\n</code></pre> FIRST_NAME Steven Shelli Sigal Shanta Steven Stephen Sarath"},{"location":"sql/02_Basic_sql_statements/#using-the-like-condition_1","title":"Using the LIKE Condition","text":"<p>You can use the ESCAPE identifier to search forthe actual % and _ symbols.</p> <pre><code>SELECT employee_id, last_name, job_id\nFROM employees\nWHERE job_id LIKE '%SA\\_%' ESCAPE '\\';\n</code></pre> <pre><code>SELECT last_name\nFROM nikovits.employees\nWHERE last_name LIKE '_o%' ;\n</code></pre> LAST_NAME Kochhar Lorentz Popp Tobias Colmenares Vollman Mourgos Rogers"},{"location":"sql/02_Basic_sql_statements/#using-the-null-conditions","title":"Using the NULL Conditions","text":"<pre><code>SELECT last_name, manager_id\nFROM nikovits.employees\nWHERE manager_id IS NULL ;\n</code></pre> LAST_NAME MANAGER_ID King NULL"},{"location":"sql/02_Basic_sql_statements/#logical-conditions","title":"Logical Conditions","text":"Operator Meaning AND Returns TRUE if both component conditions are true OR Returns TRUE if either component condition is true NOT Returns TRUE if the following condition is false"},{"location":"sql/02_Basic_sql_statements/#3-valued-logic","title":"3-valued logic","text":""},{"location":"sql/02_Basic_sql_statements/#and-operator","title":"AND Operator","text":"AND TRUE FALSE NULL TRUE TRUE FALSE NULL FALSE FALSE FALSE FALSE NULL NULL FALSE NULL"},{"location":"sql/02_Basic_sql_statements/#or-operator","title":"OR Operator","text":"OR TRUE FALSE NULL TRUE TRUE TRUE TRUE FALSE TRUE FALSE NULL NULL TRUE NULL NULL"},{"location":"sql/02_Basic_sql_statements/#not-operator","title":"NOT Operator","text":"NOT Result TRUE FALSE FALSE TRUE NULL NULL"},{"location":"sql/02_Basic_sql_statements/#using-the-and-operator","title":"Using the AND Operator","text":"<pre><code>SELECT employee_id, last_name, job_id, salary\nFROM nikovits.employees\nWHERE salary &gt;=10000\nAND job_id LIKE '%MAN%' ;\n</code></pre> EMPLOYEE_ID LAST_NAME JOB_ID SALARY 114 Raphaely PU_MAN 11000 145 Russell SA_MAN 14000 146 Partners SA_MAN 13500 147 Errazuriz SA_MAN 12000 148 Cambrault SA_MAN 11000 149 Zlotkey SA_MAN 10500 201 Hartstein MK_MAN 13000"},{"location":"sql/02_Basic_sql_statements/#using-the-or-operator","title":"Using the OR Operator","text":"<pre><code>SELECT employee_id, last_name, job_id, salary\nFROM nikovits.employees\nWHERE salary &gt;= 10000\nOR job_id LIKE '%MAN%' ;\n</code></pre> EMPLOYEE_ID LAST_NAME JOB_ID SALARY 100 King AD_PRES 24000 101 Kochhar AD_VP 17000 102 De Haan AD_VP 17000 108 Greenberg FI_MGR 12000 114 Raphaely PU_MAN 11000 120 Weiss ST_MAN 8000 121 Fripp ST_MAN 8200 122 Kaufling ST_MAN 7900 123 Vollman ST_MAN 6500 124 Mourgos ST_MAN 5800 145 Russell SA_MAN 14000"},{"location":"sql/02_Basic_sql_statements/#using-the-not-operator","title":"Using the NOT Operator","text":"<pre><code>SELECT last_name, job_id\nFROM nikovits.employees\nWHERE job_id\nNOT IN ('IT_PROG', 'ST_CLERK', 'SA_REP') ;\n</code></pre> LAST_NAME JOB_ID King AD_PRES Kochhar AD_VP De Haan AD_VP Greenberg FI_MGR Faviet FI_ACCOUNT Chen FI_ACCOUNT Sciarra FI_ACCOUNT Urman FI_ACCOUNT Popp FI_ACCOUNT Raphaely PU_MAN Khoo PU_CLERK Baida PU_CLERK Tobias PU_CLERK Himuro PU_CLERK"},{"location":"sql/02_Basic_sql_statements/#rules-of-precedence","title":"Rules of Precedence","text":"<p>Operators in SQL expressions are evaluated according to the following precedence (highest to lowest):</p> Priority Operator/Condition 1 Arithmetic operators (+, -, *, /) 2 Concatenation operator (||) 3 Comparison conditions (=, &gt;, &lt;, &gt;=, &lt;=, &lt;&gt;) 4 IS [NOT] NULL, LIKE, [NOT] IN 5 [NOT] BETWEEN 6 Not equal to (&lt;&gt;) 7 NOT logical condition 8 AND logical condition 9 OR logical condition <p>You can use parentheses <code>()</code> to override the default precedence rules and explicitly control the order of evaluation.</p> <pre><code>SELECT last_name, job_id, salary\nFROM nikovits.employees\nWHERE job_id = 'SA_REP'\nOR job_id = 'AD_PRES'\nAND salary &gt; 15000;\n</code></pre> LAST_NAME JOB_ID SALARY King AD_PRES 24000 Tucker SA_REP 10000 Bernstein SA_REP 9500 Hall SA_REP 9000 Olsen SA_REP 8000 Cambrault SA_REP 7500 Tuvault SA_REP 7000 King SA_REP 10000 Sully SA_REP 9500 McEwen SA_REP 9000 Smith SA_REP 8000 Doran SA_REP 7500 <pre><code>SELECT last_name, job_id, salary\nFROM nikovits.employees\nWHERE (job_id = 'SA_REP'\nOR job_id = 'AD_PRES')\nAND salary &gt; 15000;\n</code></pre> LAST_NAME JOB_ID SALARY King AD_PRES 24000"},{"location":"sql/02_Basic_sql_statements/#using-the-order-by-clause","title":"Using the ORDER BY Clause","text":"<ul> <li>Sort retrieved rows with the ORDER BY clause:<ul> <li>ASC: ascending order, default</li> <li>DESC: descending order</li> </ul> </li> </ul> <pre><code>SELECT last_name, job_id, department_id, hire_date\nFROM nikovits.employees\nORDER BY hire_date ;\n</code></pre> LAST_NAME JOB_ID DEPARTMENT_ID HIRE_DATE King AD_PRES 90 17/06/87 Whalen AD_ASST 10 17/09/87 Kochhar AD_VP 90 21/09/89 Hunold IT_PROG 60 03/01/90 Ernst IT_PROG 60 21/05/91 De Haan AD_VP 90 13/01/93 Mavris HR_REP 40 07/06/94 Baer PR_REP 70 07/06/94 Higgins AC_MGR 110 07/06/94 Gietz AC_ACCOUNT 110 07/06/94 Faviet FI_ACCOUNT 100 16/08/94 Greenberg FI_MGR 100 17/08/94"},{"location":"sql/02_Basic_sql_statements/#descending-order","title":"Descending order","text":"<pre><code>SELECT last_name, job_id, department_id, hire_date\nFROM nikovits.employees\nORDER BY hire_date DESC ;\n</code></pre> LAST_NAME JOB_ID DEPARTMENT_ID HIRE_DATE Kumar SA_REP 80 21/04/00 Banda SA_REP 80 21/04/00 Ande SA_REP 80 24/03/00 Markle ST_CLERK 50 08/03/00 Lee SA_REP 80 23/02/00 Philtanker ST_CLERK 50 06/02/00 Geoni SH_CLERK 50 03/02/00 Zlotkey SA_MAN 80 29/01/00 Marvins SA_REP 80 24/01/00 Grant SH_CLERK 50 13/01/00 Johnson SA_REP 80 04/01/00 Perkins SH_CLERK 50 19/12/99 Gee ST_CLERK 50 12/12/99"},{"location":"sql/02_Basic_sql_statements/#alias","title":"Alias","text":"<pre><code>SELECT employee_id, last_name, salary*12 annsal\nFROM nikovits.employees\nORDER BY annsal ;\n</code></pre> EMPLOYEE_ID LAST_NAME ANNSAL 132 Olson 25200 128 Markle 26400 136 Philtanker 26400 135 Gee 28800 127 Landry 28800 119 Colmenares 30000 131 Marlow 30000 140 Patel 30000 144 Vargas 30000 182 Sullivan 30000 191 Perkins 30000 143 Matos 31200"},{"location":"sql/02_Basic_sql_statements/#multiple-columns","title":"Multiple columns","text":"<pre><code>SELECT last_name, department_id, salary\nFROM nikovits.employees\nORDER BY department_id, salary DESC;\n</code></pre> LAST_NAME DEPARTMENT_ID SALARY Whalen 10 4400 Hartstein 20 13000 Fay 20 6000 Raphaely 30 11000 Khoo 30 3100 Baida 30 2900 Tobias 30 2800 Himuro 30 2600 Colmenares 30 2500 Mavris 40 6500"},{"location":"sql/02_Basic_sql_statements/#substitution-variables","title":"Substitution Variables","text":""},{"location":"sql/02_Basic_sql_statements/#usesqlplus-substitution-variables-to","title":"UseSQL*Plus substitution variables to:","text":"<ul> <li>Temporarily store values with single-ampersand (&amp;) and double-ampersand(&amp;&amp;) substitution</li> <li>Use substitution variables to supplement the following:<ul> <li>WHERE conditions</li> <li>ORDER BY clauses</li> <li>Column expressions</li> <li>Table names</li> <li>Entire SELECT statements</li> </ul> </li> </ul>"},{"location":"sql/02_Basic_sql_statements/#using-the-substitution-variable","title":"Using the &amp; Substitution Variable","text":"<p>Use a variable prefixed with an ampersand (&amp;) to prompt the user for a value:</p> <pre><code>SELECT employee_id, last_name, salary, department_id\nFROM nikovits.employees\nWHERE employee_id = &amp;employee_num ;\n</code></pre>"},{"location":"sql/02_Basic_sql_statements/#character-and-date-values-with-substitution-variables","title":"Character and Date Values with Substitution Variables","text":"<p>Use single quotation marks for date and character values:</p> <pre><code>SELECT last_name, department_id, salary*12\nFROM nikovits.employees\nWHERE job_id = '&amp;job_title' ;\n</code></pre>"},{"location":"sql/02_Basic_sql_statements/#specifying-column-names-expressions-and-text","title":"Specifying Column Names, Expressions, and Text","text":"<pre><code>SELECT employee_id, last_name, job_id,&amp;column_name\nFROM nikovits.employees\nWHERE &amp;condition\nORDER BY &amp;order_column ;\n</code></pre>"},{"location":"sql/02_Basic_sql_statements/#using-the-substitution-variable_1","title":"Using the &amp;&amp; Substitution Variable","text":"<p>Use the double ampersand (&amp;&amp;) if you want to reuse the variable value without prompting the user eachtime:</p> <pre><code>SELECT employee_id, last_name, job_id, &amp;&amp;column_name\nFROM nikovits.employees\nORDER BY &amp;column_name ;\n</code></pre> <ul> <li>Use the SQLPlus DEFINE* command to create and assign a value to a variable.</li> <li>Use the SQLPlus UNDEFINE* command to remove a variable.</li> </ul> <pre><code>DEFINE employee_num = 200\nSELECT employee_id, last_name, salary, department_id\nFROM nikovits.employees\nWHERE employee_id = &amp;employee_num ;\nUNDEFINE employee_num\n</code></pre>"},{"location":"sql/03_Set_operator/","title":"Set Operators","text":""},{"location":"sql/03_Set_operator/#set-operators","title":"Set operators","text":""},{"location":"sql/03_Set_operator/#tables-used","title":"Tables Used","text":"<ul> <li>EMPLOYEES: Provides details regarding all current employees</li> <li>JOB_HISTORY: Records the details of the start date and end date of the former job, and the job identification number and department when an employee switches jobs</li> </ul> <p>When an employee switches jobs, the details of the start date and end date of the former job, the job identification number, and the department are recorded in the JOB_HISTORY table.</p>"},{"location":"sql/03_Set_operator/#union-operator","title":"UNION Operator","text":"<p>Display the current and previous job details of all employees. Display each employee only once.</p> <pre><code>SELECT employee_id, job_id\nFROM nikovits.employees\nUNION\nSELECT employee_id, job_id\nFROM nikovits.job_history;\n</code></pre> EMPLOYEE_ID JOB_ID 100 AD_PRES 101 AC_ACCOUNT 101 AC_MGR 101 AD_VP 102 AD_VP 102 IT_PROG 103 IT_PROG 104 IT_PROG 105 IT_PROG 106 IT_PROG 107 IT_PROG 108 FI_MGR 109 FI_ACCOUNT 110 FI_ACCOUNT 111 FI_ACCOUNT 112 FI_ACCOUNT 113 FI_ACCOUNT 114 PU_MAN"},{"location":"sql/03_Set_operator/#union-all-operator","title":"UNION ALL Operator","text":"<p>Display the current and previous departments of all employees.</p> <pre><code>SELECT employee_id, job_id, department_id\nFROM nikovits.employees\nUNION ALL\nSELECT employee_id, job_id, department_id\nFROM nikovits.job_history\nORDER BY employee_id;\n</code></pre> EMPLOYEE_ID JOB_ID DEPARTMENT_ID 100 AD_PRES 90 101 AD_VP 90 101 AC_ACCOUNT 110 101 AC_MGR 110 102 IT_PROG 60 102 AD_VP 90 103 IT_PROG 60 104 IT_PROG 60 105 IT_PROG 60 106 IT_PROG 60 107 IT_PROG 60 108 FI_MGR 100"},{"location":"sql/03_Set_operator/#intersect-operator","title":"INTERSECT Operator","text":"<p>Display the employee IDs and job IDs of those employees who currently have a job title that is the same as their job title when they were initially hired (that is, they changed jobs but have now gone back to doing their original job).</p> <pre><code>SELECT employee_id, job_id\nFROM nikovits.employees\nINTERSECT\nSELECT employee_id, job_id\nFROM nikovits.job_history;\n</code></pre> EMPLOYEE_ID JOB_ID 176 SA_REP 200 AD_ASST"},{"location":"sql/03_Set_operator/#minus-operator","title":"MINUS Operator","text":"<p>Display the employee IDs of those employees who have not changed their jobs even once.</p> <pre><code>SELECT employee_id,job_id\nFROM nikovits.employees\nMINUS\nSELECT employee_id,job_id\nFROM nikovits.job_history;\n</code></pre> EMPLOYEE_ID JOB_ID 100 AD_PRES 101 AD_VP 102 AD_VP 103 IT_PROG 104 IT_PROG 105 IT_PROG 106 IT_PROG 107 IT_PROG 108 FI_MGR 109 FI_ACCOUNT 110 FI_ACCOUNT 111 FI_ACCOUNT 112 FI_ACCOUNT"},{"location":"sql/03_Set_operator/#set-operator-guidelines","title":"Set Operator Guidelines","text":"<p>The expressions in the SELECT lists must match in number and data type. - Parentheses can be used to alter the sequence of execution. - The ORDER BY clause:     - Can appear only at the very end of the statement     - Will accept the column name, aliases from the first SELECT statement, or the positional notation.</p>"},{"location":"sql/03_Set_operator/#key-behaviors-of-set-operators-in-oracle-server","title":"Key Behaviors of Set Operators in Oracle Server","text":"<p>Set operators (such as <code>UNION</code>, <code>UNION ALL</code>, <code>INTERSECT</code>, <code>MINUS</code>) combine the results of two or more queries.</p>"},{"location":"sql/03_Set_operator/#important-rules","title":"Important Rules","text":"<p>Duplicate rows are automatically eliminated, except in <code>UNION ALL</code>.</p> <ul> <li><code>UNION</code>, <code>INTERSECT</code>, and <code>MINUS</code> perform distinct processing (remove duplicates).</li> <li><code>UNION ALL</code> retains all duplicates.</li> </ul> <p>Column names from the first query appear in the result.</p> <ul> <li>The final result set uses the column names (and aliases) from the first SELECT statement.</li> <li>Subsequent queries must have compatible columns, but their names/aliases are ignored in the output.</li> </ul> <p>The output is sorted in ascending order by default, except in <code>UNION ALL</code>.</p> <ul> <li><code>UNION</code>, <code>INTERSECT</code>, and <code>MINUS</code> implicitly sort the entire result set in ascending order by all columns (to eliminate duplicates).</li> <li><code>UNION ALL</code> does not sort the results\u2014it returns rows in the order they are retrieved.</li> </ul>"},{"location":"sql/03_Set_operator/#common-set-operators","title":"Common Set Operators","text":"Operator Description Removes Duplicates? Sorts Result? UNION ALL Returns all rows from both queries No No UNION Returns unique rows from both queries Yes Yes INTERSECT Returns rows common to both queries Yes Yes MINUS Returns rows from first query not in second Yes Yes"},{"location":"sql/03_Set_operator/#matching-the-select-statements","title":"Matching the SELECT Statements","text":"<p>Using the UNION operator, display the department ID, location, and hire date for all employees.</p> <pre><code>SELECT department_id, TO_NUMBER(null)\nlocation, hire_date\nFROM nikovits.employees\nUNION\nSELECT department_id, location_id, TO_DATE(null)\nFROM nikovits.departments;\n</code></pre> DEPARTMENT_ID LOCATION HIRE_DATE 10 1700 NULL 10 NULL 17/09/87 20 1800 NULL 20 NULL 17/02/96 20 NULL 17/08/97 30 1700 NULL 30 NULL 07/12/94 30 NULL 18/05/95 30 NULL 24/07/97 30 NULL 24/12/97 30 NULL 15/11/98 30 NULL 10/08/99 40 2400 NULL <p>Using the UNION operator, display the employee ID, job ID, and salary of all employees.</p> <pre><code>SELECT employee_id, job_id,salary\nFROM nikovits.employees\nUNION\nSELECT employee_id, job_id,0\nFROM nikovits.job_history;\n</code></pre> EMPLOYEE_ID JOB_ID SALARY 100 AD_PRES 24000 101 AC_ACCOUNT 0 101 AC_MGR 0 101 AD_VP 17000 102 AD_VP 17000 102 IT_PROG 0 103 IT_PROG 9000 104 IT_PROG 6000 105 IT_PROG 4800 106 IT_PROG 4800 107 IT_PROG 4200 108 FI_MGR 12000 109 FI_ACCOUNT 9000"},{"location":"sql/03_Set_operator/#controlling-the-order-of-rows","title":"Controlling the Order of Rows","text":"<p>Produce an English sentence using two UNION operators.</p> <p>(Run as a script, not as a single statement.)</p> <pre><code>COLUMN a_dummy NOPRINT\nSELECT 'sing' AS \"My dream\", 3 a_dummy\nFROM dual\nUNION\nSELECT 'I''d like to teach', 1 a_dummy\nFROM dual\nUNION\nSELECT 'the world to', 2 a_dummy\nFROM dual\nORDER BY a_dummy;\n</code></pre> My dream A_DUMMY Id like to teach 1 the world to 2 sing 3"},{"location":"sql/04_Data_types/","title":"Data Types","text":""},{"location":"sql/04_Data_types/#data-types","title":"Data types","text":""},{"location":"sql/04_Data_types/#numbers","title":"Numbers","text":"<ul> <li>number(x,y) -- x -&gt; precision (number of stored digits), y -&gt; scale (number of decimals, it can be negative)</li> <li>number(x) -- x -&gt; precision (number of stored digits), scale defaults to 0.</li> <li>int = integer = number(38)</li> <li>numeric(x,y) = number(x,y) (synonyms)</li> <li>positive and natural -- only in PL/SQL (procedural extension of SQL)</li> </ul>"},{"location":"sql/04_Data_types/#strings","title":"STRINGS","text":"<ul> <li>varchar2(17) --Variable length string. Maximal length in paranthesis.</li> <li>varchar(n) = varchar2(n) (synonyms)<ul> <li>Insert: if length of string overrides max. length-&gt; error</li> </ul> </li> <li>char(15) --Fixed length string. Stored in fixed length, rigth padded with spaces.<ul> <li>Insert: if length of string over rides max. length-&gt; error</li> <li>Insert: if length of string is fewer-&gt; rigth padded with spaces.</li> </ul> </li> <li>Data type of Character literals e.g. 'ABC' (default) --&gt; char(3).</li> <li>Take care in case of char(n) data type comparison!!! e.g. 'str' = 'str' (!!!)<ul> <li>e.g. SELECT * FROM emp WHERE 'str' = 'str'; -&gt; TRUE for all rows</li> </ul> </li> <li>In case of varchar comparison, it is different (normal).<ul> <li>e.g. SELECT * FROM emp WHERE CAST('str' AS VARCHAR(4)) = 'str'; -&gt; FALSE for all rows</li> </ul> </li> </ul>"},{"location":"sql/04_Data_types/#date-and-time","title":"DATE and TIME","text":"<ul> <li>DATE data type -- stores date and time with seconds precision</li> <li>ANSI Date literal: DATE '1998-12-25\u2019<ul> <li>The ANSI date literal contains no time portion, and must be specified in the format 'YYYY-MM-DD\u2019.</li> <li>Alternatively, you can specify an Oracle date value with TO_DATE built-in function.</li> </ul> </li> <li>We can change the date format and language:<ul> <li>ALTER SESSION SET NLS_DATE_FORMAT='YYYY-MM-DD (fmDay) HH24:MI:SS\u2019;</li> <li>ALTER SESSION SET NLS_DATE_LANGUAGE='hungarian'; -- can be english, american, french, german</li> <li>SELECT sysdate FROM dual;SELECT to_char(sysdate, 'day') FROM dual;</li> </ul> </li> </ul>"},{"location":"sql/04_Data_types/#datearithmethic","title":"Datearithmethic","text":"<ul> <li>d+1 -- d plus one day</li> <li>d-2 -- d minus 2 days</li> <li>sysdate+7 -- now plus 7 days</li> <li>d+1/24 -- d plus 1 hour</li> <li>d2-d1 -- time elapsed between d1 and d2 in days</li> <li>(d2-d1)2460*60 -- time elapsed between d1 and d2 in seconds</li> <li>months_between(d2,d1)</li> <li>We can get positive and negative result too.<ul> <li>d2 &gt; d1 =&gt; (+)</li> <li>d2 &lt; d1 =&gt; (-)</li> </ul> </li> </ul>"},{"location":"sql/04_Data_types/#timestamp-datatype","title":"TIMESTAMP datatype","text":"<ul> <li>Stores fractional seconds as well</li> <li>SELECT SYSTIMESTAMP FROM DUAL; --with Time Zone see NLS_TIMESTAMP_TZ_FORMAT setting<ul> <li>--20-APR-08 11.53.17,384707000 +02:00</li> </ul> </li> <li>SELECT CURRENT_TIMESTAMP FROM DUAL;<ul> <li>--20-APR-08 11.53.55,229284000 EUROPE/PRAGUE</li> </ul> </li> <li>SELECT LOCALTIMESTAMP FROM DUAL; --without Time Zone<ul> <li>--20-APR-08 11.54.13,646841000</li> </ul> </li> <li>SELECT TO_CHAR(SYSTIMESTAMP,'YYYY.MM.DD.HH24:MI:SS.FF TZH:TZM') FROM dual; --using explicit Format Mask<ul> <li>--2020.04.08.11:57:50.274611 +02:00</li> </ul> </li> <li>SELECT TO_CHAR(SYSTIMESTAMP,'SSSSS.FF') FROM dual; --seconds past midnight</li> </ul>"},{"location":"sql/04_Data_types/#conversion","title":"CONVERSION","text":"<ul> <li>to_date('2030-OCT-28') -- conversion based on NLS_DATE_FORMAT</li> <li>to_date('2030-12','YYYY-MM') -- giving format elements =&gt; 2030-12-01 0:00.00</li> <li>The elements we don't give in will be default. Default date: actual year, actual month, first day, midnight</li> <li>to_date(2462803,'J') -- Julian date 2462803rd day midnight</li> <li>to_char(d) -- output according to NLS_DATE_FORMAT</li> <li>to_char(d, 'HH24:MI:SS') -- output according to format elements given</li> <li>to_char(127.14) -- number -&gt; string</li> <li>to_number('135.00167') -- string -&gt; number</li> <li>to_number('abc') -- ORA-01722: invalid number</li> </ul>"},{"location":"sql/04_Data_types/#oracle-sql-has-no-boolean-type","title":"Oracle SQL has no boolean type","text":""},{"location":"sql/04_Data_types/#plsql-has-literals-true-false-null","title":"(PL/SQL has. Literals: TRUE, FALSE, NULL)","text":"<ul> <li>NULL value can be in any datatype column.</li> <li>Two nulls are never equal, however it is not true that they are not equal (x &lt;&gt; y).</li> <li>We can test whether x is null:<ul> <li>x IS NULL (wrong -&gt; x = NULL)</li> <li>x IS NOT NULL</li> </ul> </li> <li>e.g. SELECT * FROM emp WHERE comm IS NOT NULL;</li> </ul>"},{"location":"sql/05_Sql_functions/","title":"SQL Functions","text":""},{"location":"sql/05_Sql_functions/#sql-functions","title":"SQL Functions","text":""},{"location":"sql/05_Sql_functions/#types-of-sql-functions","title":"Types of SQL Functions","text":""},{"location":"sql/05_Sql_functions/#single-row-functions","title":"Single-Row Functions","text":"<ul> <li>Manipulate data items</li> <li>Accept arguments and return one value</li> <li>Act on each row that is returned</li> <li>Return one result per row</li> <li>May modify the data type</li> <li>Can be nested</li> <li>Accept arguments that can be a column or an expression</li> </ul>"},{"location":"sql/06_Character_functions/","title":"Character Functions","text":""},{"location":"sql/06_Character_functions/#character-functions","title":"Character Functions","text":""},{"location":"sql/06_Character_functions/#case-manipulation-functions-in-sql","title":"Case-Manipulation Functions in SQL","text":"<p>These functions convert the case for character strings.</p>"},{"location":"sql/06_Character_functions/#common-case-manipulation-functions","title":"Common Case-Manipulation Functions","text":"Function Result Description LOWER('SQL Course') sql course Converts all characters to lowercase UPPER('SQL Course') SQL COURSE Converts all characters to uppercase INITCAP('SQL Course') Sql Course Converts the first letter of each word to uppercase and the rest to lowercase"},{"location":"sql/06_Character_functions/#using-case-manipulation-functions","title":"Using Case-Manipulation Functions","text":"<p>Display the employee number, name, and department number for employee Higgins:</p> <pre><code>SELECT employee_id, last_name, department_id\nFROM nikovits.employees\nWHERE last_name = 'higgins';\n</code></pre> EMPLOYEE_ID LAST_NAME DEPARTMENT_ID <pre><code>SELECT employee_id, last_name, department_id\nFROM nikovits.employees\nWHERE LOWER(last_name) = 'higgins';\n</code></pre> EMPLOYEE_ID LAST_NAME DEPARTMENT_ID 205 Higgins 110"},{"location":"sql/06_Character_functions/#character-manipulation-functions-in-sql","title":"Character-Manipulation Functions in SQL","text":"<p>These functions manipulate character strings.</p>"},{"location":"sql/06_Character_functions/#common-character-manipulation-functions","title":"Common Character-Manipulation Functions","text":"Function Result Description CONCAT('Hello', 'World') HelloWorld Concatenates two strings (alternative: use <code>||</code> operator) SUBSTR('HelloWorld', 1, 5) Hello Returns a substring starting at position 1 with length 5 LENGTH('HelloWorld') 10 Returns the length of the string INSTR('HelloWorld', 'W') 6 Returns the position of the first occurrence of 'W' (1-based index) LPAD(salary, 10, '*') ****24000 Left-pads the value to a total length of 10 using '*' (example: salary=24000) RPAD(salary, 10, '*') 24000* Right-pads the value to a total length of 10 using '*' REPLACE('JACK and JUE', 'J', 'BL') BLACK and BLUE Replaces all occurrences of 'J' with 'BL' TRIM('H' FROM 'HelloWorld') elloWorld Removes all leading occurrences of 'H' from the string"},{"location":"sql/06_Character_functions/#using-the-character-manipulation-functions","title":"Using the Character-Manipulation Functions","text":""},{"location":"sql/07_Number_functions/","title":"Number Functions","text":""},{"location":"sql/07_Number_functions/#number-functions-in-sql","title":"Number Functions in SQL","text":"<p>Number functions perform operations on numeric values.</p>"},{"location":"sql/07_Number_functions/#key-number-functions-oracle-sql","title":"Key Number Functions (Oracle SQL)","text":"<ul> <li>ROUND: Rounds value to specified decimal places</li> <li>TRUNC: Truncates value to specified decimal places (no rounding)</li> <li>MOD: Returns remainder of division</li> </ul>"},{"location":"sql/07_Number_functions/#examples","title":"Examples","text":"Function Result Description ROUND(45.926, 2) 45.93 Rounds to 2 decimal places (standard rounding: 0.006 \u2192 up) TRUNC(45.926, 2) 45.92 Truncates to 2 decimal places (cuts off excess without rounding) MOD(1600, 300) 100 Returns remainder of 1600 \u00f7 300 (1600 - 5\u00d7300 = 100)"},{"location":"sql/07_Number_functions/#dual-table","title":"DUAL Table","text":"<p>DUAL is a dummy table that you can use to view results from functions and calculations.</p>"},{"location":"sql/07_Number_functions/#using-the-round-function","title":"Using the ROUND Function","text":""},{"location":"sql/07_Number_functions/#using-the-trunc-function","title":"Using the TRUNC Function","text":""},{"location":"sql/07_Number_functions/#using-the-mod-function","title":"Using the MOD Function","text":"<p>For all nikovits.employees with job title of Sales Representative, calculate the remainder of the salary after it is divided by 5,000.</p> <pre><code>SELECT last_name, salary, MOD(salary, 5000)\nFROM nikovits.employees\nWHERE job_id = 'SA_REP';\n</code></pre> LAST_NAME SALARY MOD(SALARY,5000) Tucker 10000 0 Bernstein 9500 4500 Hall 9000 4000 Olsen 8000 3000 Cambrault 7500 2500 Tuvault 7000 2000 King 10000 0"},{"location":"sql/08_Date_functions/","title":"Date Functions","text":""},{"location":"sql/08_Date_functions/#working-with-dates","title":"Working with Dates","text":"<ul> <li>The Oracle database stores dates in an internal numeric format: century, year, month, day, hours, minutes, and seconds.</li> <li>The default date display format is DD-MON-YY. (DD-MON-RR)<ul> <li>Enables you to store 21st-century dates in the 20th century by specifying only the last two digits of the year</li> <li>Enables you to store 20th-century dates in the 21st century in the same way</li> </ul> </li> </ul> <pre><code>SELECT last_name, hire_date\nFROM nikovits.employees\nWHERE hire_date &lt; '01-FEB-88';\n</code></pre> LAST_NAME HIRE_DATE King 17/06/87 Whalen 17/09/87"},{"location":"sql/08_Date_functions/#sysdate-is-a-function-that-returns","title":"SYSDATE is a function that returns:","text":"<ul> <li>Date</li> <li>Time</li> </ul>"},{"location":"sql/08_Date_functions/#arithmetic-with-dates","title":"Arithmetic with Dates","text":"<ul> <li>Add or subtract a number to or from a date for a resultant date value.</li> <li>Subtract two dates to find the number of days between those dates.</li> <li>Add hours to a date by dividing the number of hours by 24.</li> </ul> <pre><code>SELECT last_name, (SYSDATE-hire_date)/7 AS WEEKS\nFROM nikovits.employees\nWHERE department_id = 90;\n</code></pre> LAST_NAME WEEKS King 1995.593908730158730 Kochhar 1877.451051587301587 De Haan 1704.593908730158730"},{"location":"sql/08_Date_functions/#date-functions","title":"Date Functions","text":"Function Description MONTHS_BETWEEN Number of months between two dates ADD_MONTHS Add calendar months to date NEXT_DAY Next day of the date specified LAST_DAY Last day of the month ROUND Round date TRUNC Truncate date"},{"location":"sql/08_Date_functions/#using-date-functions","title":"Using Date Functions","text":"Function Result Explanation MONTHS_BETWEEN('01-SEP-95', '11-JAN-94') 19.6774194 Calculates the number of months between the two dates (later date first). Includes fractional months based on days. ADD_MONTHS('11-JAN-94', 6) '11-JUL-94' Adds 6 calendar months to the specified date. NEXT_DAY('01-SEP-95', 'FRIDAY') '08-SEP-95' Returns the date of the next Friday after 01-SEP-1995. LAST_DAY('01-FEB-95') '28-FEB-95' Returns the last day of the month for February 1995 (non-leap year). <p>Assume <code>SYSDATE = '25-JUL-2003'</code>.</p> Function Result Explanation ROUND(SYSDATE, 'MONTH') 01-AUG-2003 Rounds to the nearest month. Since July 25 is past the 15th, rounds up to August 1. ROUND(SYSDATE, 'YEAR') 01-JAN-2004 Rounds to the nearest year. July 25 is past July 1, so rounds up to next year. TRUNC(SYSDATE, 'MONTH') 01-JUL-2003 Truncates to the first day of the current month (always sets day to 1). TRUNC(SYSDATE, 'YEAR') 01-JAN-2003 Truncates to the first day of the current year (January 1)."},{"location":"sql/09_Conversion_functions/","title":"Conversion Functions","text":""},{"location":"sql/09_Conversion_functions/#conversion-functions","title":"Conversion Functions","text":""},{"location":"sql/09_Conversion_functions/#implicit-data-type-conversion","title":"Implicit Data Type Conversion","text":"<p>For assignments (e.g., in <code>INSERT</code>, <code>UPDATE</code>, or variable assignments), the Oracle server can automatically perform implicit data type conversions for certain compatible types.</p> From To Notes VARCHAR2 or CHAR NUMBER String must represent a valid number (e.g., '123.45' \u2192 123.45) VARCHAR2 or CHAR DATE String must be in the default date format or a recognizable format (depends on NLS_DATE_FORMAT) NUMBER VARCHAR2 Number is converted to its string representation DATE VARCHAR2 Date is converted to string using the current NLS_DATE_FORMAT <p>For expression evaluation (e.g., in <code>WHERE</code> clause conditions, <code>SELECT</code> list expressions, or function arguments), the Oracle Server can automatically perform implicit data type conversions for certain compatible types.</p> From To Notes VARCHAR2 or CHAR NUMBER String must represent a valid number; otherwise, runtime error (ORA-01722) VARCHAR2 or CHAR DATE String must match the session's NLS_DATE_FORMAT or be recognizable"},{"location":"sql/09_Conversion_functions/#explicit-data-type-conversion","title":"Explicit Data Type Conversion","text":""},{"location":"sql/09_Conversion_functions/#using-the-to_char-function-with-dates","title":"Using the TO_CHAR Function with Dates","text":""},{"location":"sql/09_Conversion_functions/#to_chardate-format_model","title":"TO_CHAR(date, 'format_model')","text":"<p>The format model:</p> <ul> <li>Must be enclosed by single quotation marks</li> <li>Is case-sensitive</li> <li>Can include any valid date format element</li> <li>Has an fm element to remove padded blanks or suppress leading zeros</li> <li>Is separated from the date value by a comma TO_CHAR(date, 'format_model')</li> </ul>"},{"location":"sql/09_Conversion_functions/#elements-of-the-date-format-model","title":"Elements of the Date Format Model","text":"Element Result Example (for December 24, 2025 - Wednesday) YYYY Full year in numbers 2025 YEAR Year spelled out (in English) TWENTY TWENTY-FIVE MM Two-digit value for month 12 MONTH Full name of the month DECEMBER MON Three-letter abbreviation of the month DEC DY Three-letter abbreviation of the day of the week WED DAY Full name of the day of the week WEDNESDAY DD Numeric day of the month 24"},{"location":"sql/09_Conversion_functions/#time-elements","title":"Time Elements","text":"<p>Time elements format the time portion of the date.</p> Format Element Example Result Description HH24:MI:SS AM 15:45:32 PM 24-hour format with hours, minutes, seconds, and AM/PM indicator"},{"location":"sql/09_Conversion_functions/#literal-text","title":"Literal Text","text":"<p>Add character strings by enclosing them in double quotation marks.</p> Format Example Result Notes DD \"of\" MONTH 12 of OCTOBER \"of\" is output literally"},{"location":"sql/09_Conversion_functions/#number-suffixes","title":"Number Suffixes","text":"<p>Number suffixes spell out numbers (ordinal form).</p> Format Element Result Description ddspth fourteenth Spells the day with ordinal suffix (e.g., 1st, 2nd, 3rd, 14th)"},{"location":"sql/09_Conversion_functions/#using-the-to_char-function-with-dates_1","title":"Using the TO_CHAR Function with Dates","text":"<pre><code>SELECT last_name,\n    TO_CHAR(hire_date, 'fmDD Month YYYY')\n    AS HIREDATE\nFROM nikovits.employees;\n</code></pre> LAST_NAME HIREDATE King 17 June 1987 Kochhar 21 September 1989 De Haan 13 January 1993 Hunold 3 January 1990 Ernst 21 May 1991 Austin 25 June 1997 Pataballa 5 February 1998 Lorentz 7 February 1999"},{"location":"sql/09_Conversion_functions/#using-the-to_char-function-with-numbers","title":"Using the TO_CHAR Function with Numbers","text":"<pre><code>TO_CHAR(number, 'format_model')\n</code></pre> <p>These are some of the format elements that you can use with the TO_CHAR function to display a number value as a character:</p> Element Result/Description 9 Represents a digit (leading zeros suppressed) 0 Forces a zero to be displayed $ Places a floating dollar sign L Uses the floating local currency symbol . Prints a decimal point , Prints a comma as thousands indicator <pre><code>SELECT TO_CHAR(salary, '$99,999.00') SALARY\nFROM nikovits.employees\nWHERE last_name = 'Ernst';\n</code></pre> SALARY $6,000.00"},{"location":"sql/09_Conversion_functions/#using-to_number-and-to_date-functions","title":"Using TO_NUMBER and TO_DATE Functions","text":"<p>Convert a character string to a number format using the TO_NUMBER function:</p> <pre><code>TO_NUMBER(char[, 'format_model'])\n</code></pre> <p>Convert a character string to a date format using the TO_DATE function:</p> <pre><code>TO_DATE(char[, 'format_model'])\n</code></pre> <ul> <li>These functions have an FX modifier.</li> <li>This modifier specifies the exact matching for the character argument and the format model of a TO_DATE function.</li> </ul>"},{"location":"sql/10_Other_functions/","title":"Other Functions","text":""},{"location":"sql/10_Other_functions/#nesting-functions","title":"Nesting Functions","text":"<ul> <li>Single-row functions can be nested to any level.  </li> <li>Nested functions are evaluated from the deepest level to the least deep level (inside-out).</li> </ul> <pre><code>SELECT last_name,\n    UPPER(CONCAT(SUBSTR (LAST_NAME, 1, 8), '_US'))\nFROM nikovits.employees\nWHERE department_id = 60;\n</code></pre> LAST_NAME UPPER(CONCAT(SUBSTR(LAST_NAME,1,8),'_US')) Hunold HUNOLD_US Ernst ERNST_US Austin AUSTIN_US Pataballa PATABALL_US Lorentz LORENTZ_US"},{"location":"sql/10_Other_functions/#general-functions","title":"General Functions","text":"<p>The following functions work with any data type and pertain to using nulls:</p> <pre><code>- NVL (expr1, expr2)\n- NVL2 (expr1, expr2, expr3)\n- NULLIF (expr1, expr2)\n- COALESCE (expr1, expr2, ..., exprn)\n</code></pre>"},{"location":"sql/10_Other_functions/#nvl-function","title":"NVL Function","text":"<p>Converts a null value to an actual value:</p> <ul> <li>Data types that can be used are date, character, and number.</li> <li> <p>Data types must match:</p> </li> <li> <p>NVL(commission_pct, 0)</p> </li> <li>NVL(hire_date, '01-JAN-97')</li> <li>NVL(job_id, 'No Job Yet')</li> </ul>"},{"location":"sql/10_Other_functions/#using-the-nvl-function","title":"Using the NVL Function","text":""},{"location":"sql/10_Other_functions/#using-the-nvl2-function","title":"Using the NVL2 Function","text":""},{"location":"sql/10_Other_functions/#using-the-nullif-function","title":"Using the NULLIF Function","text":""},{"location":"sql/10_Other_functions/#using-the-coalesce-function","title":"Using the COALESCE Function","text":"<ul> <li>The advantage of the COALESCE function over the NVL function is that the COALESCE function can take multiple alternate values.</li> <li>If the first expression is not null, the COALESCE function returns that expression; otherwise, it does a COALESCE of the remaining expressions.</li> </ul> <pre><code>SELECT last_name,\n    COALESCE(manager_id,commission_pct, -1) comm\nFROM nikovits.employees\nORDER BY commission_pct;\n</code></pre> LAST_NAME COMM Lee 147 Johnson 149 Marvins 147 Banda 147 Kumar 148 Ande 147 Greene 147 Grant 149 Tuvault 145 Bates 148"},{"location":"sql/11_Conditional_expressions/","title":"Conditional Expressions","text":""},{"location":"sql/11_Conditional_expressions/#conditional-expressions","title":"Conditional Expressions","text":"<ul> <li>Provide the use of IF-THEN-ELSE logic within a SQL statement</li> <li>Use two methods:<ul> <li>CASE expression</li> <li>DECODE function</li> </ul> </li> </ul>"},{"location":"sql/11_Conditional_expressions/#case-expression","title":"CASE Expression","text":"<p>Facilitates conditional inquiries by doing the work of an IF-THEN-ELSE statement:</p> <pre><code>CASE expr WHEN comparison_expr1 THEN return_expr1\n     [WHEN comparison_expr2 THEN return_expr2\n      WHEN comparison_exprn THEN return_exprn\n      ELSE else_expr]\nEND\n</code></pre>"},{"location":"sql/11_Conditional_expressions/#if-then-else-statement","title":"IF THEN ELSE statement:","text":"<pre><code>SELECT last_name, job_id, salary,\n    CASE job_id WHEN 'IT_PROG' THEN 1.10*salary\n                WHEN 'ST_CLERK' THEN 1.15*salary\n                WHEN 'SA_REP' THEN 1.20*salary\n    ELSE salary END \"REVISED_SALARY\"\nFROM nikovits.employees;\n</code></pre> LAST_NAME JOB_ID SALARY REVISED_SALARY King AD_PRES 24000 24000 Kochhar AD_VP 17000 17000 De Haan AD_VP 17000 17000 Hunold IT_PROG 9000 9900 Ernst IT_PROG 6000 6600 Austin IT_PROG 4800 5280 Pataballa IT_PROG 4800 5280"},{"location":"sql/11_Conditional_expressions/#decode-function-in-oracle-sql","title":"DECODE Function in Oracle SQL","text":"<p>Facilitates conditional inquiries by doing the work of a CASE expression or an IF-THEN-ELSE statement:</p> <pre><code>DECODE(col|expression, search1, result1\n       [, search2, result2, ...]\n       [, default])\n</code></pre> <pre><code>SELECT last_name, job_id, salary,\n    DECODE(job_id, 'IT_PROG', 1.10*salary,\n            'ST_CLERK', 1.15*salary,\n            'SA_REP', 1.20*salary,\n            salary)\n    REVISED_SALARY\nFROM nikovits.employees;\n</code></pre> LAST_NAME JOB_ID SALARY REVISED_SALARY King AD_PRES 24000 24000 Kochhar AD_VP 17000 17000 De Haan AD_VP 17000 17000 Hunold IT_PROG 9000 9900 Ernst IT_PROG 6000 6600 Austin IT_PROG 4800 5280 Pataballa IT_PROG 4800 5280"},{"location":"sql/11_Conditional_expressions/#display-the-applicable-tax-rate-for-each-employee-in-department-80","title":"Display the applicable tax rate for each employee in department 80:","text":"<pre><code>SELECT last_name, salary,\n        DECODE (TRUNC(salary/2000, 0),\n                            0, 0.00,\n                            1, 0.09,\n                            2, 0.20,\n                            3, 0.30,\n                            4, 0.40,\n                            5, 0.42,\n                            6, 0.44,\n                            0.45) TAX_RATE\nFROM nikovits.employees\nWHERE department_id = 80;\n</code></pre> LAST_NAME SALARY TAX_RATE Russell 14000 .45 Partners 13500 .44 Errazuriz 12000 .44 Cambrault 11000 .42 Zlotkey 10500 .42 Tucker 10000 .42 Bernstein 9500 .4 Hall 9000 .4 Olsen 8000 .4"},{"location":"sql/12_Group_functions/","title":"Group Functions","text":""},{"location":"sql/12_Group_functions/#what-are-group-functions","title":"What Are Group Functions?","text":"<p>Group functions operate on sets of rows to give one result per group.</p> <p></p>"},{"location":"sql/12_Group_functions/#types-of-group-functions","title":"Types of Group Functions","text":"<ul> <li>AVG</li> <li>COUNT</li> <li>MAX</li> <li>MIN</li> <li>STDDEV</li> <li>SUM</li> <li>VARIANCE</li> </ul>"},{"location":"sql/12_Group_functions/#group-functions-syntax","title":"Group Functions: Syntax","text":"<pre><code>SELECT     [column,] group_function(column), ...\nFROM       table\n[WHERE     condition]\n[GROUP BY  column]\n[ORDER BY  column];\n</code></pre>"},{"location":"sql/12_Group_functions/#using-the-avg-and-sum-functions","title":"Using the AVG and SUM Functions","text":"<pre><code>SELECT AVG(salary), MAX(salary),\n        MIN(salary), SUM(salary)\n        FROM nikovits.employees\nWHERE job_id LIKE '%REP%';\n</code></pre> AVG(SALARY) MAX(SALARY) MIN(SALARY) SUM(SALARY) 8272.727272727272727 11500 6000 273000"},{"location":"sql/12_Group_functions/#using-the-min-and-max-functions","title":"Using the MIN and MAX Functions","text":"<pre><code>SELECT MIN(hire_date), MAX(hire_date)\nFROM nikovits.employees;\n</code></pre> MIN(HIRE_DATE) MAX(HIRE_DATE) 17/06/87 21/04/00"},{"location":"sql/12_Group_functions/#using-the-count-function","title":"Using the COUNT Function","text":""},{"location":"sql/12_Group_functions/#count-returns-the-number-of-rows-in-a-table","title":"COUNT(*) returns the number of rows in a table:","text":"<pre><code>SELECT COUNT(*)\nFROM nikovits.employees\nWHERE department_id = 50;\n</code></pre> COUNT(*) 45"},{"location":"sql/12_Group_functions/#countexpr-returns-the-number-of-rows-with-non-null-values-for-expr","title":"COUNT(expr) returns the number of rows with non-null values for expr:","text":"<pre><code>SELECT COUNT(commission_pct)\nFROM nikovits.employees\nWHERE department_id = 80\n</code></pre> COUNT(COMMISSION_PCT) 34"},{"location":"sql/12_Group_functions/#using-the-distinct-keyword","title":"Using the DISTINCT Keyword","text":"<ul> <li>COUNT(DISTINCT expr) returns the number of distinct non-null values of the expr.</li> <li>To display the number of distinct department values in the nikovits.employees table:</li> </ul> <pre><code>SELECT COUNT(DISTINCT department_id)\nFROM nikovits.employees;\n</code></pre> COUNT(DISTINCT DEPARTMENT_ID) 11"},{"location":"sql/12_Group_functions/#group-functions-and-null-values","title":"Group Functions and Null Values","text":""},{"location":"sql/12_Group_functions/#group-functions-ignore-null-values-in-the-column","title":"Group functions ignore null values in the column:","text":"<pre><code>SELECT AVG(commission_pct)\nFROM nikovits.employees;\n</code></pre> AVG(COMMISSION_PCT) .2228571428571428571"},{"location":"sql/12_Group_functions/#the-nvl-function-forces-group-functions-to-include-null-values","title":"The NVL function forces group functions to include null values:","text":"<pre><code>SELECT AVG(NVL(commission_pct, 0))\nFROM nikovits.employees;\n</code></pre> AVG(NVL(COMMISSION_PCT,0)) .0728971962616822429906542"},{"location":"sql/13_Group_by/","title":"Group By","text":""},{"location":"sql/13_Group_by/#creating-groups-of-data","title":"Creating Groups of Data","text":""},{"location":"sql/13_Group_by/#creating-groups-of-data-group-by-clause-syntax","title":"Creating Groups of Data: GROUP BY Clause Syntax","text":"<pre><code>SELECT     column, group_function(column)\nFROM       table\n[WHERE     condition]\n[GROUP BY  group_by_expression]\n[ORDER BY  column];\n</code></pre> <p>You can divide rows in a table into smaller groups by using the GROUP BY clause.</p>"},{"location":"sql/13_Group_by/#using-the-group-by-clause","title":"Using the GROUP BY Clause","text":"<p>All columns in the SELECT list that are not in group functions must be in the GROUP BY clause.</p> <pre><code>SELECT department_id, AVG(salary)\nFROM nikovits.employees\nGROUP BY department_id;\n</code></pre> DEPARTMENT_ID AVG(SALARY) 100 8600 30 4150 NULL 7000 90 19333.33333333333333 20 9500 70 10000 110 10150 50 3475.555555555555555 80 8955.882352941176470 40 6500 60 5760 10 4400"},{"location":"sql/13_Group_by/#using-the-group-by-clause_1","title":"Using the GROUP BY Clause","text":"<p>The GROUP BY column does not have to be in the SELECT list.</p> <pre><code>SELECT AVG(salary)\nFROM nikovits.employees\nGROUP BY department_id;\n</code></pre> AVG(SALARY) 8600 4150 7000 19333.33333333333333 9500 10000 10150 3475.555555555555555 8955.882352941176470 6500 5760 4400"},{"location":"sql/13_Group_by/#grouping-by-more-than-one-column","title":"Grouping by More Than One Column","text":""},{"location":"sql/13_Group_by/#using-the-group-by-clause-on-multiple-columns","title":"Using the GROUP BY Clause on Multiple Columns","text":"<pre><code>SELECT department_id dept_id, job_id, SUM(salary)\nFROM nikovits.employees\nGROUP BY department_id, job_id ;\n</code></pre> DEPT_ID JOB_ID SUM(SALARY) 110 AC_ACCOUNT 8300 90 AD_VP 34000 50 ST_CLERK 55700 80 SA_REP 243500 50 ST_MAN 36400 80 SA_MAN 61000 110 AC_MGR 12000 90 AD_PRES 24000 60 IT_PROG 28800 100 FI_MGR 12000 30 PU_CLERK 13900 50 SH_CLERK 64300 20 MK_MAN 13000 100 FI_ACCOUNT 39600 NULL SA_REP 7000 70 PR_REP 10000 30 PU_MAN 11000 10 AD_ASST 4400 20 MK_REP 6000 40 HR_REP 6500"},{"location":"sql/13_Group_by/#illegal-queries-using-group-functions","title":"Illegal Queries Using Group Functions","text":"<p>Any column or expression in the SELECT list that is not an aggregate function must be in the GROUP BY clause:</p> <pre><code>SELECT   department_id, COUNT(last_name)\nFROM     employees;\n</code></pre> <p></p> <p>Column missing in the GROUP BY clause</p>"},{"location":"sql/13_Group_by/#illegal-queries-using-group-functions_1","title":"Illegal Queries Using Group Functions","text":"<ul> <li>You cannot use the WHERE clause to restrict groups.</li> <li>You use the HAVING clause to restrict groups.</li> <li>You cannot use group functions in the WHERE clause.</li> </ul> <pre><code>SELECT   department_id, AVG(salary)\nFROM     employees\nWHERE    AVG(salary) &gt; 8000\nGROUP BY department_id;\n</code></pre> <p>Cannot use the WHERE clause to restrict groups</p>"},{"location":"sql/13_Group_by/#restricting-group-functions","title":"Restricting Group Functions","text":""},{"location":"sql/13_Group_by/#restricting-group-results-with-the-having-clause","title":"Restricting Group Results with the HAVING Clause","text":"<ul> <li>When you use the HAVING clause, the Oracle server restricts groups as follows:</li> <li>Rows are grouped.</li> <li>The group function is applied.</li> <li>Groups matching the HAVING clause are displayed.</li> </ul> <pre><code>SELECT     column, group_function\nFROM       table\n[WHERE     condition]\n[GROUP BY  group_by_expression]\n[HAVING    group_condition]\n[ORDER BY  column];\n</code></pre>"},{"location":"sql/13_Group_by/#using-the-having-clause","title":"Using the HAVING Clause","text":"<pre><code>SELECT department_id, MAX(salary)\nFROM nikovits.employees\nGROUP BY department_id\nHAVING MAX(salary)&gt;10000 ;\n</code></pre> DEPARTMENT_ID MAX(SALARY) 100 12000 30 11000 90 24000 20 13000 110 12000 80 14000 <pre><code>SELECT job_id, SUM(salary) PAYROLL\nFROM nikovits.employees\nWHERE job_id NOT LIKE '%REP%'\nGROUP BY job_id\nHAVING SUM(salary) &gt; 13000\nORDER BY SUM(salary);\n</code></pre> JOB_ID PAYROLL PU_CLERK 13900 AD_PRES 24000 IT_PROG 28800 AD_VP 34000 ST_MAN 36400 FI_ACCOUNT 39600 ST_CLERK 55700 SA_MAN 61000 SH_CLERK 64300"},{"location":"sql/13_Group_by/#nesting-group-functions","title":"Nesting Group Functions","text":"<ul> <li>Display the maximum average salary:</li> <li>Group functions can be nested to a depth of two.</li> <li>The example displays the maximum average salary.</li> </ul> <pre><code>SELECT MAX(AVG(salary))\nFROM nikovits.employees\nGROUP BY department_id;\n</code></pre> MAX(AVG(SALARY)) 19333.33333333333333"},{"location":"sql/14_Joins/","title":"Joins","text":""},{"location":"sql/14_Joins/#obtaining-data-from-multiple-tables","title":"Obtaining Data from Multiple Tables","text":""},{"location":"sql/14_Joins/#types-of-joins","title":"Types of Joins","text":"<ul> <li>Joins that are compliant with the SQL:1999 standard include the following:     \u2013 Cross joins     \u2013 Natural joins     \u2013 USING clause     \u2013 Full (or two-sided) outer joins     \u2013 Arbitrary join conditions for outer joins</li> </ul>"},{"location":"sql/14_Joins/#joining-tables-using-sql1999-syntax","title":"Joining Tables Using SQL:1999 Syntax","text":"<p>Use a join to query data from more than one table:</p> <pre><code>SELECT table1.column, table2.column\nFROM   table1\n[NATURAL JOIN table2] |\n[JOIN table2 USING (column_name)] |\n[JOIN table2\n ON (table1.column_name = table2.column_name)] |\n[LEFT|RIGHT|FULL OUTER JOIN table2\n ON (table1.column_name = table2.column_name)] |\n[CROSS JOIN table2];\n</code></pre>"},{"location":"sql/14_Joins/#creating-natural-joins","title":"Creating Natural Joins","text":"<ul> <li>The NATURAL JOIN clause is based on all columns in the two tables that have the same name.</li> <li>It selects rows from the two tables that have equal values in all matched columns.</li> <li>If the columns having the same names have different data types, an error is returned.</li> </ul>"},{"location":"sql/14_Joins/#retrieving-records-with-natural-joins","title":"Retrieving Records with Natural Joins","text":"<pre><code>SELECT department_id, department_name,\nlocation_id, city\nFROM nikovits.departments\nNATURAL JOIN nikovits.locations ;\n</code></pre> DEPARTMENT_ID DEPARTMENT_NAME LOCATION_ID CITY 10 Administration 1700 Seattle 20 Marketing 1800 Toronto 30 Purchasing 1700 Seattle 40 Human Resources 2400 London 50 Shipping 1500 South San Francisco 60 IT 1400 Southlake 70 Public Relations 2700 Munich 80 Sales 2500 Oxford 90 Executive 1700 Seattle 100 Finance 1700 Seattle 110 Accounting 1700 Seattle 120 Treasury 1700 Seattle"},{"location":"sql/14_Joins/#creating-joins-with-the-using-clause","title":"Creating Joins with the USING Clause","text":"<ul> <li>If several columns have the same names but the data types do not match, the NATURAL JOIN clause can be modified with the USING clause to specify the columns that should be used for an equijoin.</li> <li>Use the USING clause to match only one column when more than one column matches.</li> <li>Do not use a table name or alias in the referenced columns.</li> <li>The NATURAL JOIN and USING clauses are mutually exclusive.</li> </ul>"},{"location":"sql/14_Joins/#joining-column-names","title":"Joining Column Names","text":"<pre><code>SELECT nikovits.employees.employee_id, nikovits.employees.last_name,\nnikovits.departments.location_id, department_id\nFROM nikovits.employees JOIN nikovits.departments\nUSING (department_id) ;\n</code></pre> EMPLOYEE_ID LAST_NAME LOCATION_ID DEPARTMENT_ID 100 King 1700 90 101 Kochhar 1700 90 102 De Haan 1700 90 103 Hunold 1400 60 104 Ernst 1400 60 105 Austin 1400 60 106 Pataballa 1400 60 107 Lorentz 1400 60 108 Greenberg 1700 100 109 Faviet 1700 100 110 Chen 1700 100"},{"location":"sql/14_Joins/#qualifying-ambiguous","title":"Qualifying Ambiguous","text":""},{"location":"sql/14_Joins/#column-names","title":"Column Names","text":"<ul> <li>Use table prefixes to qualify column names that are in multiple tables.</li> <li>Use table prefixes to improve performance.</li> <li>Use column aliases to distinguish columns that have identical names but reside in different tables.</li> <li>Do not use aliases on columns that are identified in the USING clause and listed elsewhere in the SQL statement.</li> </ul>"},{"location":"sql/14_Joins/#using-table-aliases","title":"Using Table Aliases","text":"<ul> <li>Use table aliases to simplify queries.</li> <li>Use table aliases to improve performance.</li> </ul> <pre><code>SELECT e.employee_id, e.last_name,\n       d.location_id, department_id\nFROM   employees e JOIN departments d\nUSING  (department_id) ;\n</code></pre>"},{"location":"sql/14_Joins/#creating-joins-with-the-on-clause","title":"Creating Joins with the ON Clause","text":"<ul> <li>The join condition for the natural join is basically an equijoin of all columns with the same name.</li> <li>Use the ON clause to specify arbitrary conditions or specify columns to join.</li> <li>The join condition is separated from other search conditions.</li> <li>The ON clause makes code easy to understand.</li> </ul> <pre><code>SELECT e.employee_id, e.last_name, e.department_id,\nd.department_id, d.location_id\nFROM nikovits.employees e JOIN nikovits.departments d\nON (e.department_id = d.department_id);\n</code></pre> EMPLOYEE_ID LAST_NAME DEPARTMENT_ID DEPARTMENT_ID LOCATION_ID 100 King 90 90 1700 101 Kochhar 90 90 1700 102 De Haan 90 90 1700 103 Hunold 60 60 1400 104 Ernst 60 60 1400 105 Austin 60 60 1400 106 Pataballa 60 60 1400 107 Lorentz 60 60 1400 108 Greenberg 100 100 1700 109 Faviet 100 100 1700 110 Chen 100 100 1700 111 Sciarra 100 100 1700 112 Urman 100 100 1700 113 Popp 100 100 1700 114 Raphaely 30 30 1700"},{"location":"sql/14_Joins/#self-joins-using-the-on-clause","title":"Self-Joins Using the ON Clause","text":"<pre><code>SELECT e.last_name emp, m.last_name mgr\nFROM nikovits.employees e JOIN nikovits.employees m\nON (e.manager_id = m.employee_id);\n</code></pre> EMP MGR Kochhar King De Haan King Raphaely King Weiss King Fripp King Kaufling King Vollman King Mourgos King Russell King Partners King Errazuriz King Cambrault King Zlotkey King"},{"location":"sql/14_Joins/#applying-additional-conditions-to-a-join","title":"Applying Additional Conditions to a Join","text":"<pre><code>SELECT e.employee_id, e.last_name, e.department_id,\n       d.department_id, d.location_id\nFROM   employees e JOIN departments d\nON     (e.department_id = d.department_id)\nAND    e.manager_id = 149;\n</code></pre> EMPLOYEE_ID LAST_NAME DEPARTMENT_ID DEPARTMENT_ID LOCATION_ID 174 Abel 80 80 2500 178 Taylor 80 80 2500 <p>Alternatively, you can use a WHERE clause to apply additional conditions:</p> <pre><code>SELECT e.employee_id, e.last_name, e.department_id,\n       d.department_id, d.location_id\nFROM   employees e JOIN departments d\nON     (e.department_id = d.department_id)\nWHERE  e.manager_id = 149;\n</code></pre>"},{"location":"sql/14_Joins/#creating-three-way-joins-with-the-on-clause","title":"Creating Three-Way Joins with the ON Clause","text":"<pre><code>SELECT employee_id, city, department_name\nFROM nikovits.employees e\nJOIN nikovits.departments d\nON d.department_id = e.department_id\nJOIN nikovits.locations l\nON d.location_id = l.location_id;\n</code></pre> EMPLOYEE_ID CITY DEPARTMENT_NAME 100 Seattle Executive 101 Seattle Executive 102 Seattle Executive 103 Southlake IT 104 Southlake IT 105 Southlake IT 106 Southlake IT 107 Southlake IT 108 Seattle Finance 109 Seattle Finance 110 Seattle Finance 111 Seattle Finance 112 Seattle Finance 113 Seattle Finance"},{"location":"sql/14_Joins/#non-equijoin","title":"Non-Equijoin","text":"<pre><code>SELECT e.last_name, e.salary, j.grade_level\nFROM nikovits.employees e JOIN nikovits.job_grades j\nON e.salary\nBETWEEN j.lowest_sal AND j.highest_sal;\n</code></pre> LAST_NAME SALARY GRADE_LEVEL Olson 2100 A Markle 2200 A Philtanker 2200 A Landry 2400 A Gee 2400 A Colmenares 2500 A Marlow 2500 A Patel 2500 A Vargas 2500 A Sullivan 2500 A Perkins 2500 A Himuro 2600 A"},{"location":"sql/14_Joins/#outer-joins","title":"Outer Joins","text":""},{"location":"sql/14_Joins/#inner-versus-outer-joins","title":"INNER Versus OUTER Joins","text":"<ul> <li>In SQL:1999, the join of two tables returning only matched rows is called an inner join.</li> <li>A join between two tables that returns the results of the inner join as well as the unmatched rows from the left (or right) tables is called a left (or right) outer join.</li> <li>A join between two tables that returns the results of an inner join as well as the results of a left and right join is a full outer join.</li> </ul>"},{"location":"sql/14_Joins/#left-outer-join","title":"LEFT OUTER JOIN","text":"<pre><code>SELECT e.last_name, e.department_id, d.department_name\nFROM nikovits.employees e LEFT OUTER JOIN nikovits.departments d\nON (e.department_id = d.department_id) ;\n</code></pre> LAST_NAME DEPARTMENT_ID DEPARTMENT_NAME Whalen 10 Administration Hartstein 20 Marketing Fay 20 Marketing Raphaely 30 Purchasing Khoo 30 Purchasing Baida 30 Purchasing Tobias 30 Purchasing Himuro 30 Purchasing Colmenares 30 Purchasing Mavris 40 Human Resources Weiss 50 Shipping Fripp 50 Shipping Kaufling 50 Shipping"},{"location":"sql/14_Joins/#right-outer-join","title":"RIGHT OUTER JOIN","text":"<pre><code>SELECT e.last_name, e.department_id, d.department_name\nFROM nikovits.employees e RIGHT OUTER JOIN nikovits.departments d\nON (e.department_id = d.department_id) ;\n</code></pre> LAST_NAME DEPARTMENT_ID DEPARTMENT_NAME King 90 Executive Kochhar 90 Executive De Haan 90 Executive Hunold 60 IT Ernst 60 IT Austin 60 IT Pataballa 60 IT Lorentz 60 IT Greenberg 100 Finance Faviet 100 Finance"},{"location":"sql/14_Joins/#full-outer-join","title":"FULL OUTER JOIN","text":"<pre><code>SELECT e.last_name, d.department_id, d.department_name\nFROM nikovits.employees e FULL OUTER JOIN nikovits.departments d\nON (e.department_id = d.department_id) ;\n</code></pre> LAST_NAME DEPARTMENT_ID DEPARTMENT_NAME King 90 Executive Kochhar 90 Executive De Haan 90 Executive Hunold 60 IT Ernst 60 IT Austin 60 IT Pataballa 60 IT Lorentz 60 IT Greenberg 100 Finance Faviet 100 Finance Chen 100 Finance Sciarra 100 Finance"},{"location":"sql/14_Joins/#cartesian-products","title":"Cartesian Products","text":"<ul> <li> <p>A Cartesian product is formed when:</p> </li> <li> <p>A join condition is omitted</p> </li> <li>A join condition is invalid</li> <li> <p>All rows in the first table are joined to all rows in the second table</p> </li> <li> <p>To avoid a Cartesian product, always include a valid join condition.</p> </li> </ul>"},{"location":"sql/14_Joins/#generating-a-cartesian-product","title":"Generating a Cartesian Product","text":""},{"location":"sql/14_Joins/#creating-cross-joins","title":"Creating Cross Joins","text":"<ul> <li>The CROSS JOIN clause produces the crossproduct of two tables.</li> <li>This is also called a Cartesian product between the two tables.</li> </ul> <pre><code>SELECT last_name, department_name\nFROM nikovits.employees\nCROSS JOIN nikovits.departments ;\n</code></pre> LAST_NAME DEPARTMENT_NAME King Administration Kochhar Administration De Haan Administration Hunold Administration Ernst Administration Austin Administration Pataballa Administration Lorentz Administration Greenberg Administration Faviet Administration Chen Administration Sciarra Administration"},{"location":"sql/14_Joins/#joins-summary","title":"Joins Summary","text":""},{"location":"sql/15_Subqueries/","title":"Subqueries","text":""},{"location":"sql/15_Subqueries/#using-a-subquery-to-solve-a-problem","title":"Using a Subquery to Solve a Problem","text":""},{"location":"sql/15_Subqueries/#subquery-syntax","title":"Subquery Syntax","text":"<pre><code>SELECT  select_list\nFROM    table\nWHERE   expr operator\n        (SELECT select_list\n         FROM   table);\n</code></pre> <ul> <li>The subquery (inner query) executes once before the main query (outer query).</li> <li>The result of the subquery is used by the main query.</li> </ul> <pre><code>SELECT last_name\nFROM nikovits.employees\nWHERE salary &gt;\n(SELECT salary\nFROM nikovits.employees\nWHERE last_name = 'Abel');\n</code></pre> LAST_NAME King Kochhar De Haan Greenberg Russell Partners Errazuriz Ozer Hartstein Higgins"},{"location":"sql/15_Subqueries/#guidelines-for-using-subqueries","title":"Guidelines for Using Subqueries","text":"<ul> <li>Enclose subqueries in parentheses.</li> <li>Place subqueries on the right side of the comparison condition.</li> <li>The ORDER BY clause in the subquery is not needed unless you are performing Top-N analysis.</li> <li>Use single-row operators with single-row subqueries, and use multiple-row operators with multiple-row subqueries.</li> </ul>"},{"location":"sql/15_Subqueries/#types-of-subqueries","title":"Types of Subqueries","text":""},{"location":"sql/15_Subqueries/#single-row-subqueries","title":"Single-Row Subqueries","text":"<ul> <li>Return only one row</li> <li>Use single-row comparison operators</li> </ul> Operator Meaning = Equal to &gt; Greater than &gt;= Greater than or equal to &lt; Less than &lt;= Less than or equal to &lt;&gt; Not equal to"},{"location":"sql/15_Subqueries/#executing-single-row-subqueries","title":"Executing Single-Row Subqueries","text":"<pre><code>SELECT last_name, job_id, salary\nFROM nikovits.employees\nWHERE job_id =\n(SELECT job_id\nFROM nikovits.employees\nWHERE employee_id = 141)\nAND salary &gt;\n(SELECT salary\nFROM nikovits.employees\nWHERE employee_id = 143);\n</code></pre> LAST_NAME JOB_ID SALARY Nayer ST_CLERK 3200 Mikkilineni ST_CLERK 2700 Bissot ST_CLERK 3300 Atkinson ST_CLERK 2800 Mallin ST_CLERK 3300 Rogers ST_CLERK 2900 Ladwig ST_CLERK 3600 Stiles ST_CLERK 3200 Seo ST_CLERK 2700"},{"location":"sql/15_Subqueries/#using-group-functions-in-a-subquery","title":"Using Group Functions in a Subquery","text":"<pre><code>SELECT last_name, job_id, salary\nFROM nikovits.employees\nWHERE salary =\n(SELECT MIN(salary)\nFROM nikovits.employees);\n</code></pre> LAST_NAME JOB_ID SALARY Olson ST_CLERK 2100"},{"location":"sql/15_Subqueries/#the-having-clause-with-subqueries","title":"The HAVING Clause with Subqueries","text":"<ul> <li>The Oracle server executes subqueries first.</li> <li>The Oracle server returns results into the HAVING clause of the main query.</li> </ul> <pre><code>SELECT   department_id, MIN(salary)\nFROM     employees\nGROUP BY department_id\nHAVING   MIN(salary) &gt; \n         (SELECT MIN(salary)\n          FROM   employees\n          WHERE  department_id = 50);\n</code></pre>"},{"location":"sql/15_Subqueries/#what-is-wrong-with-this-statement","title":"What Is Wrong with This Statement?","text":"<pre><code>SELECT employee_id, last_name\nFROM   employees\nWHERE  salary =\n       (SELECT   MIN(salary)\n        FROM     employees\n        GROUP BY department_id);\n</code></pre> <p>Single-row operator with multiple-row subquery</p>"},{"location":"sql/15_Subqueries/#will-this-statement-return-rows","title":"Will This Statement Return Rows?","text":"<pre><code>SELECT last_name, job_id\nFROM   employees\nWHERE  job_id =\n       (SELECT job_id\n        FROM   employees\n        WHERE  last_name = 'Haas');\n</code></pre> <p>Subquery returns no values.</p>"},{"location":"sql/15_Subqueries/#multiple-row-subqueries","title":"Multiple-Row Subqueries","text":"<ul> <li>Return more than one row</li> <li>Use multiple-row comparison operators</li> </ul> Operator Meaning IN Equal to any member in the list ANY Compare value to each value returned by the subquery ALL Compare value to every value returned by the subquery"},{"location":"sql/15_Subqueries/#using-the-any-operator-in-multiple-row-subqueries","title":"Using the ANY Operator in Multiple-Row Subqueries","text":"<pre><code>SELECT employee_id, last_name, job_id, salary\nFROM nikovits.employees\nWHERE salary &lt; ANY\n(SELECT salary\nFROM nikovits.employees\nWHERE job_id = 'IT_PROG')\nAND job_id &lt;&gt; 'IT_PROG';\n</code></pre> EMPLOYEE_ID LAST_NAME JOB_ID SALARY 132 Olson ST_CLERK 2100 136 Philtanker ST_CLERK 2200 128 Markle ST_CLERK 2200 135 Gee ST_CLERK 2400 127 Landry ST_CLERK 2400 191 Perkins SH_CLERK 2500 182 Sullivan SH_CLERK 2500 144 Vargas ST_CLERK 2500 140 Patel ST_CLERK 2500"},{"location":"sql/15_Subqueries/#using-the-all-operator-in-multiple-row-subqueries","title":"Using the ALL Operator in Multiple-Row Subqueries","text":"<pre><code>SELECT employee_id, last_name, job_id, salary\nFROM nikovits.employees\nWHERE salary &lt; ALL\n(SELECT salary\nFROM nikovits.employees\nWHERE job_id = 'IT_PROG')\nAND job_id &lt;&gt; 'IT_PROG';\n</code></pre> EMPLOYEE_ID LAST_NAME JOB_ID SALARY 185 Bull SH_CLERK 4100 192 Bell SH_CLERK 4000 193 Everett SH_CLERK 3900 188 Chung SH_CLERK 3800 137 Ladwig ST_CLERK 3600 189 Dilly SH_CLERK 3600 141 Rajs ST_CLERK 3500 186 Dellinger SH_CLERK 3400 133 Mallin ST_CLERK 3300 129 Bissot ST_CLERK 3300 180 Taylor SH_CLERK 3200 138 Stiles ST_CLERK 3200"},{"location":"sql/15_Subqueries/#null-values-in-a-subquery","title":"Null Values in a Subquery","text":"<pre><code>SELECT  emp.last_name\nFROM    employees emp\nWHERE   emp.employee_id NOT IN\n        (SELECT mgr.manager_id\n         FROM   employees mgr);\n</code></pre> <p>no rows selected</p> <p>x NOT IN (A, B, NULL) \u2192 Unknown</p>"},{"location":"sql/15_Subqueries/#multiple-column-subqueries","title":"Multiple-Column Subqueries","text":"<pre><code>Main query\nWHERE (MANAGER_ID, DEPARTMENT_ID) IN\n          \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n          \u2502     Subquery        \u2502\n          \u2502 100     90          \u2502\n          \u2502 102     60          \u2502\n          \u2502 124     50          \u2502\n          \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Each row of the main query is compared to values from a multiple-row and multiple-column subquery.</p>"},{"location":"sql/15_Subqueries/#pairwise-comparison-subquery","title":"Pairwise Comparison Subquery","text":"<p>Display the details of the employees who are managed by the same manager and work in the same department as the employees with <code>EMPLOYEE_ID</code> 199 or 174.</p> <pre><code>SELECT employee_id, manager_id, department_id\nFROM employees\nWHERE (manager_id, department_id) IN\n    (SELECT manager_id, department_id\n     FROM employees\n     WHERE employee_id IN (199, 174))\nAND employee_id NOT IN (199, 174);\n</code></pre>"},{"location":"sql/15_Subqueries/#nonpairwise-comparison-subquery","title":"Nonpairwise Comparison Subquery","text":"<p>Display the details of the employees who are managed by the same manager as the employees with <code>EMPLOYEE_ID</code> 174 or 199 and work in the same department as the employees with <code>EMPLOYEE_ID</code> 174 or 199.</p> <pre><code>SELECT employee_id, manager_id, department_id\nFROM employees\nWHERE manager_id IN\n    (SELECT manager_id\n     FROM employees\n     WHERE employee_id IN (174, 199))\nAND department_id IN\n    (SELECT department_id\n     FROM employees\n     WHERE employee_id IN (174, 199))\nAND employee_id NOT IN (174, 199);\n</code></pre>"},{"location":"sql/15_Subqueries/#scalar-subquery-expressions","title":"Scalar Subquery Expressions","text":"<ul> <li>A scalar subquery expression is a subquery that returns exactly one column value from one row.</li> <li>Scalar subqueries can be used in:<ul> <li>Condition and expression parts of <code>DECODE</code> and <code>CASE</code></li> <li>All clauses of a <code>SELECT</code> statement except <code>GROUP BY</code></li> </ul> </li> </ul>"},{"location":"sql/15_Subqueries/#scalar-subqueries-examples","title":"Scalar Subqueries Examples","text":"<p>Scalar Subqueries in CASE Expressions</p> <pre><code>SELECT employee_id, last_name,\n       (CASE \n            WHEN department_id = \n                    (SELECT department_id\n                      FROM departments\n                      WHERE location_id = 1800)\n            THEN 'Canada' ELSE 'USA'\n        END) location\nFROM employees;\n</code></pre> <p>Scalar subqueries in ORDER BY clause</p> <pre><code>SELECT employee_id, last_name\nFROM employees e\nORDER BY (SELECT department_name\n          FROM departments d\n          WHERE e.department_id = d.department_id);\n</code></pre>"},{"location":"sql/15_Subqueries/#correlated-subqueries","title":"Correlated Subqueries","text":"<ul> <li>Correlated subqueries are used for row-by-row processing.</li> <li>Each subquery is executed once for every row of the outer query.</li> <li>The inner query references columns from the outer query (making it \"correlated\").</li> </ul> <pre>\nGET\ncandidate row from outer query\n\u2193\nEXECUTE\ninner query using candidate row value\n\u2193\nUSE\nvalues from inner query to qualify or disqualify candidate row\n</pre> <p>The subquery references a column from a table in the parent (outer) query.</p> <pre><code>SELECT column1, column2, ...\nFROM table1 outer\nWHERE column1 operator\n    (SELECT column1, column2\n     FROM table2\n     WHERE expr1 = outer.expr2);\n</code></pre> <p>Find all employees who earn more than the average salary in their department.</p> <pre><code>SELECT last_name, salary, department_id\nFROM employees outer\nWHERE salary &gt; \n    (SELECT AVG(salary)\n     FROM employees\n     WHERE department_id = outer.department_id);\n</code></pre> <p>Each time a row from the outer query is processed, the inner query is evaluated.</p>"},{"location":"sql/15_Subqueries/#correlated-subquery-example","title":"Correlated Subquery Example","text":"<p>Display details of those employees who have changed jobs at least twice.</p> <pre><code>SELECT e.employee_id, e.last_name, e.job_id\nFROM employees e\nWHERE 2 &lt;= (\n    SELECT COUNT(*)\n    FROM job_history\n    WHERE employee_id = e.employee_id\n);\n</code></pre> EMPLOYEE_ID LAST_NAME JOB_ID 101 Kochar AD_VP 176 Taylor SA_REP 200 Whalen AD_ASST"},{"location":"sql/15_Subqueries/#using-the-exists-operator","title":"Using the EXISTS Operator","text":"<ul> <li>The EXISTS operator tests for the existence of rows in the result set of the subquery.</li> <li>It returns TRUE if the subquery returns at least one row, FALSE otherwise.</li> <li>NOT EXISTS does the opposite.</li> </ul> <p>If a subquery row value is found:</p> <ul> <li>The search does not continue in the inner query (short-circuits after first match).</li> <li>The condition is flagged TRUE.</li> </ul> <p>If a subquery row value is not found:</p> <ul> <li>The condition is flagged FALSE.</li> <li>The search continues in the inner query until all rows are checked or a match is found.</li> </ul>"},{"location":"sql/15_Subqueries/#find-employees-who-have-at-least-one-person-reporting-to-them","title":"Find Employees Who Have at Least One Person Reporting to Them","text":"<pre><code>SELECT employee_id, last_name, job_id, department_id\nFROM employees outer\nWHERE EXISTS (\n    SELECT 'X'\n    FROM employees\n    WHERE manager_id = outer.employee_id\n);\n</code></pre> EMPLOYEE_ID LAST_NAME JOB_ID DEPARTMENT_ID 100 King AD_PRES 90 101 Kochhar AD_VP 90 102 De Haan AD_VP 90 103 Hunold IT_PROG 60 108 Greenberg FI_MGR 100 114 Raphaely PU_MAN 30 120 Weiss ST_MAN 50 121 Fripp ST_MAN 50 122 Kaufling ST_MAN 50"},{"location":"sql/15_Subqueries/#find-all-departments-that-do-not-have-any-employees","title":"Find All Departments That Do Not Have Any Employees","text":"<pre><code>SELECT department_id, department_name\nFROM departments d\nWHERE NOT EXISTS (\n    SELECT 'X'\n    FROM employees\n    WHERE department_id = d.department_id\n);\n</code></pre> DEPARTMENT_ID DEPARTMENT_NAME 120 Treasury 130 Corporate Tax 140 Control And Credit 150 Shareholder Services 160 Benefits 170 Manufacturing"},{"location":"sql/16_With/","title":"With","text":""},{"location":"sql/16_With/#the-with-clause","title":"The WITH Clause","text":"<ul> <li>Using the WITH clause, you can use the same query block in a <code>SELECT</code> statement when it occurs more than once within a complex query.</li> <li>The WITH clause retrieves the results of a query block and stores it in the user's temporary tablespace.</li> <li>The WITH clause improves performance by avoiding repeated execution of the same subquery.</li> </ul>"},{"location":"sql/16_With/#with-clause-example","title":"WITH Clause Example","text":"<p>Using the <code>WITH</code> clause, write a query to display the department name and total salaries for those departments whose total salary is greater than the average salary across departments.</p> <pre><code>WITH \ndept_costs AS (\n    SELECT d.department_name, SUM(e.salary) AS dept_total\n    FROM employees e\n    JOIN departments d ON e.department_id = d.department_id\n    GROUP BY d.department_name\n),\navg_cost AS (\n    SELECT SUM(dept_total)/COUNT(*) AS dept_avg\n    FROM dept_costs\n)\nSELECT *\nFROM dept_costs\nWHERE dept_total &gt; \n    (SELECT dept_avg\n     FROM avg_cost)\nORDER BY department_name;\n</code></pre>"},{"location":"sql/17_DML_DDL/","title":"DML and DDL","text":""},{"location":"sql/17_DML_DDL/#data-manipulation-language-dml-in-sql","title":"Data Manipulation Language (DML) in SQL","text":"<ul> <li> <p>A DML statement is executed when you:</p> <ul> <li>Add new rows to a table</li> <li>Modify existing rows in a table</li> <li>Remove existing rows from a table</li> </ul> </li> <li> <p>A transaction consists of a collection of DML statements that form a logical unit of work.</p> </li> </ul>"},{"location":"sql/17_DML_DDL/#adding-a-new-row-to-a-table","title":"Adding a New Row to a Table","text":""},{"location":"sql/17_DML_DDL/#insert-statement-syntax","title":"INSERT Statement Syntax","text":"<ul> <li>Add new rows to a table by using the INSERT statement.</li> </ul> <pre><code>INSERT INTO table [(column [, column...])]\nVALUES (value [, value...]);\n</code></pre> <p>With this syntax, only one row is inserted at a time.</p>"},{"location":"sql/17_DML_DDL/#inserting-new-rows","title":"Inserting New Rows","text":"<ul> <li>Insert a new row containing values for each column.</li> <li>List values in the default order of the columns in the table.</li> <li>Optionally, list the columns explicitly in the <code>INSERT</code> clause.</li> <li>Enclose character and date values in single quotation marks.</li> </ul> <pre><code>INSERT INTO departments (department_id, department_name, manager_id, location_id)\nVALUES (70, 'Public Relations', 100, 1700);\n</code></pre>"},{"location":"sql/17_DML_DDL/#inserting-rows-with-null-values","title":"Inserting Rows with NULL Values","text":""},{"location":"sql/17_DML_DDL/#implicit-method","title":"Implicit Method","text":"<ul> <li>Omit the column from the column list.</li> <li>The omitted column(s) will receive NULL (or default value if defined).</li> </ul> <pre><code>INSERT INTO departments (department_id, department_name)\nVALUES (30, 'Purchasing');\n</code></pre>"},{"location":"sql/17_DML_DDL/#explicit-method","title":"Explicit Method","text":"<ul> <li>Specify the NULL keyword in the VALUES clause.</li> </ul> <pre><code>INSERT INTO departments\nVALUES (100, 'Finance', NULL, NULL);\n</code></pre>"},{"location":"sql/17_DML_DDL/#copying-rows-from-another-table","title":"Copying Rows from Another Table","text":"<ul> <li>Write your INSERT statement with a subquery.</li> <li>Do not use the <code>VALUES</code> clause.</li> <li>Match the number of columns in the <code>INSERT</code> clause to those in the subquery.</li> </ul> <pre><code>INSERT INTO target_table [(column1, column2, ...)]\nSELECT column1, column2, ...\nFROM source_table\n[WHERE condition];\n</code></pre>"},{"location":"sql/17_DML_DDL/#changing-data-in-a-table","title":"Changing Data in a Table","text":""},{"location":"sql/17_DML_DDL/#update-statement-syntax-in-oracle-sql","title":"UPDATE Statement Syntax in Oracle SQL","text":"<ul> <li>Modify existing rows with the UPDATE statement.</li> </ul> <pre><code>UPDATE table\nSET column = value [, column = value, ...]\n[WHERE condition];\n</code></pre> <ul> <li> <p>Update more than one row at a time (if required).</p> </li> <li> <p>Specific row or rows are modified if you specify the WHERE clause.</p> </li> </ul> <pre><code>UPDATE employees\nSET department_id = 70\nWHERE employee_id = 113;\n</code></pre> <ul> <li>All rows in the table are modified if you omit the WHERE clause.</li> </ul> <pre><code>UPDATE copy_emp\nSET department_id = 110;\n</code></pre>"},{"location":"sql/17_DML_DDL/#updating-two-columns-with-a-subquery","title":"Updating Two Columns with a Subquery","text":"<p>Update employee 114's job and salary to match that of employee 205.</p> <pre><code>UPDATE employees\nSET job_id = (SELECT job_id\n              FROM employees\n              WHERE employee_id = 205),\n    salary = (SELECT salary\n              FROM employees\n              WHERE employee_id = 205)\nWHERE employee_id = 114;\n</code></pre>"},{"location":"sql/17_DML_DDL/#removing-a-row-from-a-table","title":"Removing a Row from a Table","text":""},{"location":"sql/17_DML_DDL/#delete-statement-in-oracle-sql","title":"DELETE Statement in Oracle SQL","text":"<ul> <li>You can remove existing rows from a table by using the DELETE statement.</li> </ul> <pre><code>DELETE [FROM] table\n[WHERE condition];\n</code></pre> <ul> <li>Specific rows are deleted if you specify the WHERE clause.</li> </ul> <pre><code>DELETE FROM departments\nWHERE department_name = 'Finance';\n</code></pre> <ul> <li>All rows in the table are deleted if you omit the WHERE clause.</li> </ul> <pre><code>DELETE FROM copy_emp;\n</code></pre>"},{"location":"sql/17_DML_DDL/#deleting-rows-based-on-another-table","title":"Deleting Rows Based on Another Table","text":"<ul> <li>Use subqueries in <code>DELETE</code> statements to remove rows from a table based on values from another table.</li> </ul> <pre><code>DELETE FROM employees\nWHERE department_id = \n    (SELECT department_id\n     FROM departments\n     WHERE department_name LIKE '%Public%');\n</code></pre>"},{"location":"sql/17_DML_DDL/#truncate-statement-in-oracle-sql","title":"TRUNCATE Statement in Oracle SQL","text":"<ul> <li>Removes all rows from a table, leaving the table empty and the table structure intact.</li> <li>Is a data definition language (DDL) statement rather than a DML statement.</li> <li>Cannot easily be undone (implicit commit \u2014 no ROLLBACK possible).</li> </ul> <pre><code>TRUNCATE TABLE table_name;\n</code></pre> <p>Example:</p> <pre><code>TRUNCATE TABLE copy_emp;\n</code></pre>"},{"location":"sql/17_DML_DDL/#using-a-subquery-in-an-insert-statement","title":"Using a Subquery in an INSERT Statement","text":"<pre><code>INSERT INTO \n    (SELECT employee_id, last_name, email, hire_date, job_id, salary, department_id\n     FROM employees\n     WHERE department_id = 50)\nVALUES (99999, 'Taylor', 'DTAYLOR', \n       TO_DATE('07-Jun-99', 'DD-MON-RR'), \n       'ST_CLERK', 5000, 50);\n</code></pre> <p>Verify the results:</p> <p></p>"},{"location":"sql/17_DML_DDL/#database-transactions","title":"Database Transactions","text":"<ul> <li>A database transaction consists of one of the following:<ul> <li>DML statements that constitute one consistent change to the data</li> <li>One DDL statement</li> <li>One data control language (DCL) statement</li> </ul> </li> </ul>"},{"location":"sql/17_DML_DDL/#database-transactions_1","title":"Database Transactions","text":"<ul> <li>Begins when the first DML SQL statement is executed.</li> <li>A transaction ends with one of the following events:<ul> <li>A COMMIT or ROLLBACK statement is issued.</li> <li>A DDL or DCL statement executes (automatic commit).</li> <li>The user exits SQL*Developer (or tool) normally (implicit commit in many tools).</li> <li>The system crashes (changes lost \u2014 rollback on restart).</li> </ul> </li> </ul>"},{"location":"sql/17_DML_DDL/#advantages-of-commit-and-rollback-statements","title":"Advantages of COMMIT and ROLLBACK Statements","text":"<p>With COMMIT and ROLLBACK statements, you can:</p> <pre><code>- **Ensure data consistency**  \nAll changes in a transaction succeed together or are undone completely (atomicity).\n\n- **Preview data changes before making changes permanent**  \nExecute DML statements, query the results, and decide whether to commit or rollback.\n\n- **Group logically related operations**  \nTreat multiple DML statements as a single logical unit of work.\n</code></pre>"},{"location":"sql/17_DML_DDL/#controlling-transactions","title":"Controlling Transactions","text":""},{"location":"sql/17_DML_DDL/#rolling-back-changes-to-a-marker","title":"Rolling Back Changes to a Marker","text":"<ul> <li>Create a marker in a current transaction by using the SAVEPOINT statement.</li> <li>Roll back to that marker by using the ROLLBACK TO SAVEPOINT statement.</li> </ul>"},{"location":"sql/17_DML_DDL/#implicit-transaction-processing","title":"Implicit Transaction Processing","text":"<ul> <li> <p>An automatic commit occurs under the following circumstances:</p> <ul> <li>DDL statement is issued</li> <li>DCL statement is issued</li> <li>Normal exit from SQL Developer, without explicitly issuing COMMIT or ROLLBACK statements</li> </ul> </li> <li> <p>An automatic rollback occurs under an abnormal termination of SQL Developer or a system failure.</p> </li> </ul>"},{"location":"sql/17_DML_DDL/#state-of-the-data-before-commit-or-rollback","title":"State of the Data Before COMMIT or ROLLBACK","text":"<ul> <li>The previous state of the data can be recovered.</li> <li>The current user can review the results of the DML operations by using the SELECT statement.</li> <li>Other users cannot view the results of the DML statements by the current user.</li> <li>The affected rows are locked; other users cannot change the data in the affected rows.</li> </ul>"},{"location":"sql/17_DML_DDL/#state-of-the-data-after-commit","title":"State of the Data After COMMIT","text":"<p>After issuing a COMMIT:</p> <ul> <li>Data changes are made permanent in the database.</li> <li>The previous state of the data is permanently lost.</li> <li>All users can view the results.</li> <li>Locks on the affected rows are released; those rows are available for other users to manipulate.</li> <li>All savepoints are erased.</li> </ul>"},{"location":"sql/17_DML_DDL/#committing-data","title":"Committing Data","text":"<p>Step 1: Make the Changes</p> <pre><code>DELETE FROM employees\nWHERE employee_id = 99999;\n\nINSERT INTO departments\nVALUES (290, 'Corporate Tax', NULL, 1700);\n</code></pre> <p>Step 2: Commit the Changes</p> <pre><code>COMMIT;\n</code></pre>"},{"location":"sql/17_DML_DDL/#state-of-the-data-after-rollback","title":"State of the Data After ROLLBACK","text":"<ul> <li>Discard all pending changes by using the ROLLBACK statement:<ul> <li>Data changes are undone.</li> <li>Previous state of the data is restored.</li> <li>Locks on the affected rows are released.</li> </ul> </li> </ul> <pre><code>DELETE FROM copy_emp;\n-- 22 rows deleted.\n\nROLLBACK;\n-- Rollback complete.\n</code></pre>"},{"location":"sql/17_DML_DDL/#state-of-the-data-after-rollback_1","title":"State of the Data After ROLLBACK","text":"<pre><code>DELETE FROM test;               -- ups!, it's a mistake\n-- 25,000 rows deleted.\n\nROLLBACK;                       -- correct the mistake\n-- Rollback complete.\n\nDELETE FROM test WHERE id = 100;  -- it's ok\n-- 1 row deleted.\n\nSELECT * FROM test WHERE id = 100;\n-- No rows selected.  (row successfully removed)\n\nCOMMIT;                           -- make it permanent\n-- Commit complete.\n</code></pre>"},{"location":"sql/17_DML_DDL/#statement-level-rollback","title":"Statement-Level Rollback","text":"<ul> <li>If a single DML statement fails during execution, only that statement is rolled back.</li> <li>The Oracle server implements an implicit savepoint.</li> <li>All other changes (previous successful statements in the transaction) are retained.</li> <li>The user should terminate transactions explicitly by executing a COMMIT or ROLLBACK statement.</li> </ul>"},{"location":"sql/17_DML_DDL/#read-consistency","title":"Read Consistency","text":"<ul> <li>Read consistency guarantees a consistent view of the data at all times.</li> <li>Changes made by one user do not conflict with changes made by another user.</li> <li>Read consistency ensures that on the same data:<ul> <li>Readers do not wait for writers</li> <li>Writers do not wait for readers</li> </ul> </li> </ul>"},{"location":"sql/17_DML_DDL/#database-objects","title":"Database Objects","text":"Object Description Table Basic unit of storage; composed of rows and columns View Logically represents subsets of data from one or more tables Sequence Generates numeric values (e.g., for auto-incrementing IDs) Index Improves the performance of some queries Synonym Gives alternative names to objects"},{"location":"sql/17_DML_DDL/#naming-rules-for-database-objects","title":"Naming Rules for Database Objects","text":"<ul> <li>Must begin with a letter (A\u2013Z or a\u2013z).</li> <li>Must be 1\u201330 characters long (Oracle 12.2 and later: up to 128 bytes for most objects).</li> <li>Must contain only:<ul> <li>Alphanumeric characters (A\u2013Z, a\u2013z, 0\u20139)</li> <li>Underscore (<code>_</code>)</li> <li>Dollar sign (<code>$</code>)</li> <li>Pound sign (<code>#</code>)</li> </ul> </li> <li>Must not duplicate the name of another object owned by the same user.</li> <li>Must not be an Oracle server reserved word (e.g., SELECT, TABLE, FROM).</li> </ul>"},{"location":"sql/17_DML_DDL/#create-table-statement","title":"CREATE TABLE Statement","text":"<p>You must have:</p> <ul> <li>CREATE TABLE privilege</li> <li>A storage area (quota in a tablespace)</li> </ul> <pre><code>CREATE TABLE [schema.]table\n    (column datatype [DEFAULT expr] [, ...]);\n</code></pre> <p>What You Specify - Table name - Column name, column data type, and column size</p>"},{"location":"sql/17_DML_DDL/#referencing-another-users-tables","title":"Referencing Another User's Tables","text":"<ul> <li>Tables belonging to other users are not in the user's schema.</li> <li>You should use the owner's name as a prefix to those tables.</li> </ul> <p>This is called schema-qualified table reference.</p> <pre><code>SELECT * FROM schema_name.table_name;\n</code></pre>"},{"location":"sql/17_DML_DDL/#default-option","title":"DEFAULT Option","text":"<ul> <li>Specify a default value for a column during an INSERT.</li> <li>If no value is provided for the column in the INSERT, the default is used automatically.</li> </ul> <pre><code>column_name datatype DEFAULT expression\n</code></pre> <ul> <li>Literal values, expressions, or SQL functions are legal values.</li> <li>Another column's name or a pseudocolumn are illegal values.</li> <li>The default data type must match the column data type (Oracle performs implicit conversion if possible).</li> </ul> <pre><code>CREATE TABLE hire_dates\n    (id          NUMBER(8),\n     hire_date   DATE DEFAULT SYSDATE);\n</code></pre>"},{"location":"sql/17_DML_DDL/#creating-tables","title":"Creating Tables","text":"<p>Create the Table</p> <pre><code>CREATE TABLE dept\n    (deptno      NUMBER(2),\n     dname       VARCHAR2(14),\n     loc         VARCHAR2(13),\n     create_date DATE DEFAULT SYSDATE);\n</code></pre> <p>Confirm Table Creation</p> <pre><code>DESCRIBE dept; -- not SQL Statement\n</code></pre> <p></p>"},{"location":"sql/17_DML_DDL/#data-types","title":"Data Types","text":"<p>Oracle provides a variety of data types to store different kinds of information efficiently.</p> Data Type Description VARCHAR2(size) Variable-length character data (up to 4000 bytes; size in bytes or characters) CHAR(size) Fixed-length character data (padded with spaces; up to 2000 bytes) NUMBER(p, s) Variable-length numeric data (p = precision, s = scale) DATE Date and time values (century to seconds) LONG Variable-length character data (up to 2 GB) \u2014 deprecated CLOB Character large object (up to 4 GB) RAW and LONG RAW Raw binary data (deprecated) BLOB Binary large object (up to 4 GB) BFILE Binary data stored in an external file (up to 4 GB) ROWID A base-64 number system representing the unique address of a row in its table"},{"location":"sql/17_DML_DDL/#date-and-interval-types","title":"Date and Interval Types","text":"Data Type Description TIMESTAMP Date with fractional seconds INTERVAL YEAR TO MONTH Stored as an interval of years and months INTERVAL DAY TO SECOND Stored as an interval of days, hours, minutes, and seconds"},{"location":"sql/17_DML_DDL/#datetime-data-types","title":"Datetime Data Types","text":"<ul> <li>The TIMESTAMP data type is an extension of the DATE data type.</li> <li>It stores the year, month, and day of the DATE data type plus hour, minute, and second values as well as the fractional second value.</li> <li>You can optionally specify the time zone.</li> </ul> Data Type Description TIMESTAMP [(fractional_seconds_precision)] Stores date, time, and fractional seconds (precision 0\u20139, default 6) TIMESTAMP [(fractional_seconds_precision)] WITH TIME ZONE Includes time zone offset (e.g., +05:30) or time zone region name TIMESTAMP [(fractional_seconds_precision)] WITH LOCAL TIME ZONE Stores in database time zone, automatically converts to user\u2019s local time zone on retrieval"},{"location":"sql/17_DML_DDL/#interval-data-types","title":"Interval Data Types","text":"<p>Oracle provides interval data types to store periods of time.</p>"},{"location":"sql/17_DML_DDL/#interval-year-to-month","title":"INTERVAL YEAR TO MONTH","text":"<ul> <li>Stores a period of time using the YEAR and MONTH datetime fields.</li> </ul> <pre><code>INTERVAL YEAR [(year_precision)] TO MONTH\n</code></pre>"},{"location":"sql/17_DML_DDL/#interval-day-to-second","title":"INTERVAL DAY TO SECOND","text":"<ul> <li>Stores a period of time in terms of days, hours, minutes, and seconds.</li> </ul> <pre><code>INTERVAL DAY [(day_precision)] TO SECOND [(fractional_seconds_precision)]\n</code></pre>"},{"location":"sql/17_DML_DDL/#including-constraints","title":"Including Constraints","text":"<ul> <li>Constraints enforce rules at the table level.</li> <li>Constraints prevent the deletion of a table if there are dependencies.</li> <li>They ensure data integrity by restricting what data can be inserted, updated, or deleted.</li> </ul>"},{"location":"sql/17_DML_DDL/#valid-constraint-types","title":"Valid Constraint Types","text":"Constraint Type Description Example Use Case NOT NULL Column cannot contain NULL values email, last_name UNIQUE All values in the column (or combination) must be unique employee_id (if not PK), email PRIMARY KEY Combines NOT NULL + UNIQUE; uniquely identifies each row employee_id, dept_id FOREIGN KEY Enforces referential integrity \u2014 value must exist in referenced table/key department_id references departments(dept_id) CHECK Ensures column value satisfies a specific condition salary &gt; 0, job_id IN ('SA_REP','IT_PROG')"},{"location":"sql/17_DML_DDL/#constraint-guidelines","title":"Constraint Guidelines","text":"<ul> <li>You can name a constraint, or the Oracle server generates a name by using the SYS_Cn format.</li> <li>Create a constraint at either of the following times:<ul> <li>At the same time as the table is created</li> <li>After the table has been created</li> </ul> </li> <li>Define a constraint at the column or table level.</li> <li>View a constraint in the data dictionary.</li> </ul>"},{"location":"sql/17_DML_DDL/#defining-constraints","title":"Defining Constraints","text":"<pre><code>CREATE TABLE [schema.]table\n(\n    column datatype [DEFAULT expr]\n        [column_constraint],\n    ...\n    [table_constraint] [, ...]\n);\n</code></pre> <p>Column-Level Constraint</p> <pre><code>column [CONSTRAINT constraint_name] constraint_type\n</code></pre> <pre><code>CREATE TABLE employees (\n    employee_id NUMBER(6)\n        CONSTRAINT emp_emp_id_pk PRIMARY KEY,\n    first_name  VARCHAR2(20),\n    ...\n);\n</code></pre> <p>Table-Level Constraint</p> <pre><code>[CONSTRAINT constraint_name] constraint_type (column [, ...])\n</code></pre> <pre><code>CREATE TABLE employees (\n    employee_id NUMBER(6),\n    first_name  VARCHAR2(20),\n    ...\n    job_id      VARCHAR2(10) NOT NULL,\n    CONSTRAINT emp_emp_id_pk PRIMARY KEY (employee_id)\n);\n</code></pre>"},{"location":"sql/17_DML_DDL/#not-null-constraint","title":"NOT NULL Constraint","text":"<ul> <li>Ensures that null values are not permitted for the column.</li> </ul>"},{"location":"sql/17_DML_DDL/#unique-constraint","title":"UNIQUE Constraint","text":""},{"location":"sql/17_DML_DDL/#primary-key-constraint","title":"PRIMARY KEY Constraint","text":""},{"location":"sql/17_DML_DDL/#foreign-key-constraint","title":"FOREIGN KEY Constraint","text":""},{"location":"sql/17_DML_DDL/#foreign-key-constraint-keywords","title":"FOREIGN KEY Constraint: Keywords","text":"<ul> <li>FOREIGN KEY: Defines the column in the child table at the table-constraint level</li> <li>REFERENCES: Identifies the table and column in the parent table</li> <li>ON DELETE CASCADE: Deletes the dependent rows in the child table when a row in the parent table is deleted</li> <li>ON DELETE SET NULL: Converts dependent foreign key values to null</li> </ul>"},{"location":"sql/17_DML_DDL/#check-constraint","title":"CHECK Constraint","text":"<ul> <li>Defines a condition that each row must satisfy</li> <li>The following expressions are not allowed:<ul> <li>References to CURRVAL, NEXTVAL, LEVEL, and ROWNUM pseudocolumns</li> <li>Calls to SYSDATE, UID, USER, and USERENV functions</li> <li>Queries that refer to other values in other rows</li> </ul> </li> </ul> <pre><code>..., salary NUMBER(2)\n    CONSTRAINT emp_salary_min\n    CHECK (salary &gt; 0), ...\n</code></pre>"},{"location":"sql/17_DML_DDL/#violating-constraints-1","title":"Violating Constraints 1","text":"<pre><code>UPDATE employees\nSET    department_id = 55\nWHERE  department_id = 110;\n</code></pre> <pre><code>UPDATE employees\n*\nERROR at line 1:\nORA-02291: integrity constraint (HR.EMP_DEPT_FK)\nviolated - parent key not found\n</code></pre> <p>Department 55 does not exist.</p>"},{"location":"sql/17_DML_DDL/#violating-constraints-2","title":"Violating Constraints 2","text":"<ul> <li>You cannot delete a row that contains a primary key that is used as a foreign key in</li> </ul> <pre><code>DELETE FROM departments\nWHERE  department_id = 60;\n</code></pre> <pre><code>DELETE FROM departments\n*\nERROR at line 1:\nORA-02292: integrity constraint (HR.EMP_DEPT_FK)\nviolated - child record found\n</code></pre>"},{"location":"sql/17_DML_DDL/#creating-a-table-by-using-a-subquery","title":"Creating a Table by Using a Subquery","text":"<ul> <li>Create a table and insert rows by combining the <code>CREATE TABLE</code> statement and the <code>AS subquery</code> option.</li> </ul> <pre><code>CREATE TABLE table\n    [(column, column...)]\nAS subquery;\n</code></pre> <ul> <li>Match the number of specified columns to the number of subquery columns.</li> <li>Define columns with column names and default values.</li> </ul>"},{"location":"sql/17_DML_DDL/#creating-a-table-by-using-a-subquery_1","title":"Creating a Table by Using a Subquery","text":"<pre><code>CREATE TABLE dept80\nAS\n    SELECT  employee_id, last_name,\n            salary*12 ANNSAL,\n            hire_date\n    FROM    employees\n    WHERE   department_id = 80;\n</code></pre>"},{"location":"sql/17_DML_DDL/#alter-table-statement","title":"ALTER TABLE Statement","text":"<ul> <li>Use the ALTER TABLE statement to:<ul> <li>Add a new column</li> <li>Modify an existing column</li> <li>Define a default value for the new column</li> <li>Drop a column</li> </ul> </li> </ul>"},{"location":"sql/17_DML_DDL/#dropping-a-table","title":"Dropping a Table","text":"<ul> <li>All data and structure in the table are deleted.</li> <li>Any pending transactions are committed.</li> <li>All indexes are dropped.</li> <li>All constraints are dropped.</li> <li>You cannot roll back the DROP TABLE statement.</li> </ul> <pre><code>DROP TABLE dept80;\n</code></pre>"},{"location":"sql/18_Views/","title":"Views","text":""},{"location":"sql/18_Views/#what-is-a-view","title":"What is a VIEW?","text":"<p>You can present logical subsets or combinations of data by creating views of tables.</p> <p>A view is a logical table based on a table or another view.</p> <p>A view contains no data of its own but is like a window through which data from tables can be viewed or changed.</p> <p>The tables on which a view is based are called base tables. The view is stored as a SELECT statement in the data dictionary.</p>"},{"location":"sql/18_Views/#advantages-of-views","title":"Advantages of Views","text":""},{"location":"sql/18_Views/#simple-views-and-complex-views","title":"Simple Views and Complex Views","text":"Feature Simple Views Complex Views Number of tables One One or more Contain functions No Yes Contain groups of data No Yes DML operations through a view Yes Not always"},{"location":"sql/18_Views/#creating-a-view","title":"Creating a View","text":"<ul> <li>You embed a subquery in the CREATE VIEW statement:</li> </ul> <pre><code>CREATE [OR REPLACE] [FORCE|NOFORCE] VIEW view\n    [(alias[, alias]...)]\nAS subquery\n[WITH CHECK OPTION [CONSTRAINT constraint]]\n[WITH READ ONLY [CONSTRAINT constraint]];\n</code></pre> <ul> <li>The subquery can contain complex SELECT syntax.</li> </ul> <p>Create the EMPVU80 view, which contains details of employees in department 80:</p> <pre><code>CREATE VIEW empvu80\nAS SELECT  employee_id, last_name, salary\n   FROM    employees\n   WHERE   department_id = 80;\n\nView created.\n</code></pre> <p>Describe the structure of the view by using the SQL*Plus DESCRIBE command:</p> <pre><code>DESCRIBE empvu80\n</code></pre> <p>Retrieving Data from a View</p> <pre><code>SELECT *\nFROM   salvu50;\n</code></pre>"},{"location":"sql/18_Views/#modifying-a-view","title":"Modifying a View","text":"<ul> <li>Modify the EMPVU80 view by using a CREATE OR REPLACE VIEW clause. Add an alias for each column name:</li> </ul> <pre><code>CREATE OR REPLACE VIEW empvu80\n    (id_number, name, sal, department_id)\nAS SELECT  employee_id, first_name || ' ' || last_name, salary, department_id\n   FROM    employees\n   WHERE   department_id = 80;\n\nView created.\n</code></pre> <p>Column aliases in the CREATE OR REPLACE VIEW clause are listed in the same order as the columns in the subquery.</p>"},{"location":"sql/18_Views/#creating-a-complex-view","title":"Creating a Complex View","text":"<ul> <li>Create a complex view that contains group functions to display values from two tables:</li> </ul> <pre><code>CREATE OR REPLACE VIEW dept_sum_vu\n    (name, minsal, maxsal, avgsal)\nAS SELECT   d.department_name, MIN(e.salary),\n            MAX(e.salary), AVG(e.salary)\n   FROM     employees e JOIN departments d\n            ON (e.department_id = d.department_id)\n   GROUP BY d.department_name;\n</code></pre>"},{"location":"sql/18_Views/#rules-for-performing-dml-operations-on-a-view","title":"Rules for Performing DML Operations on a View","text":"<ul> <li>You can usually perform DML operations on simple views.</li> <li>You cannot remove a row if the view contains the following:<ul> <li>Group functions</li> <li>A GROUP BY clause</li> <li>The DISTINCT keyword</li> <li>The pseudocolumn ROWNUM keyword</li> </ul> </li> <li>You cannot modify data in a view if it contains:<ul> <li>Group functions</li> <li>A GROUP BY clause</li> <li>The DISTINCT keyword</li> <li>The pseudocolumn ROWNUM keyword</li> <li>Columns defined by expressions</li> </ul> </li> <li>You cannot add data through a view if the view includes:<ul> <li>Group functions</li> <li>A GROUP BY clause</li> <li>The DISTINCT keyword</li> <li>The pseudocolumn ROWNUM keyword</li> <li>Columns defined by expressions</li> <li>NOT NULL columns in the base tables that are not selected by the view</li> </ul> </li> </ul>"},{"location":"sql/18_Views/#using-the-with-check-option-clause","title":"Using the WITH CHECK OPTION Clause","text":"<ul> <li>You can ensure that DML operations performed on the view stay in the domain of the view by using the WITH CHECK OPTION clause:</li> </ul> <pre><code>CREATE OR REPLACE VIEW empvu20\nAS SELECT *\n   FROM   employees\n   WHERE  department_id = 20\n   WITH CHECK OPTION CONSTRAINT empvu20_ck;\n</code></pre> <p>Any attempt to change the department number for any row in the view fails because it violates the WITH CHECK OPTION constraint.</p>"},{"location":"sql/18_Views/#denying-dml-operations","title":"Denying DML Operations","text":"<ul> <li>You can ensure that no DML operations occur by adding the WITH READ ONLY option to your view definition.</li> <li>Any attempt to perform a DML operation on any row in the view results in an Oracle server error.</li> </ul> <pre><code>CREATE OR REPLACE VIEW empvu10\n    (employee_number, employee_name, job_title)\nAS SELECT  employee_id, last_name, job_id\n   FROM    employees\n   WHERE   department_id = 10\n   WITH READ ONLY;\n</code></pre>"},{"location":"sql/18_Views/#removing-a-view","title":"Removing a View","text":"<ul> <li>You can remove a view without losing data because a view is based on underlying tables in the database.</li> </ul> <pre><code>DROP VIEW view;\n</code></pre>"},{"location":"sql/19_Relational_algebra/","title":"Relational Algebra","text":""},{"location":"sql/19_Relational_algebra/#relation-algebra","title":"Relation Algebra","text":""},{"location":"sql/19_Relational_algebra/#a-relational-algebra-calculator-relax","title":"A relational algebra calculator - RelaX","text":"<ul> <li>https://dbis-uibk.github.io/relax/landing</li> <li>An online tool designed to help users learn and practice relational algebra by executing queries and visualizing the results</li> <li>How to create relations and insert tuples into them:<ol> <li>Click on 'Group Editor' tab</li> <li>Copy into 'Group Editor' window your data. Find below my examples!</li> <li>Click on \"preview\" button then double click on \"use Group in editor\" button</li> <li>Now you can run your queries clicking on 'Relational Algebra' or 'SQL' tab.</li> </ol> </li> <li>This implementation allows only sets and not multisets.</li> <li>There are differences between Oracle and Relax SQL syntax.</li> <li>Name of a relation is case-sensitive.</li> </ul>"},{"location":"sql/19_Relational_algebra/#relax-example","title":"RelaX Example","text":""},{"location":"sql/19_Relational_algebra/#relax-website","title":"RelaX Website","text":"<p>(Free online tool to practice relational algebra expressions with instant results and SQL comparison.)</p>"},{"location":"sql/19_Relational_algebra/#core-relational-algebra","title":"Core Relational Algebra","text":"<ul> <li>Union, intersection, and difference.<ul> <li>Usual set operations, but both operands must have the same relation schema.</li> </ul> </li> <li>Selection: picking certain rows.</li> <li>Projection: picking certain columns.</li> <li>Products and joins: compositions of relations.</li> <li>Renaming of relations and attributes.</li> </ul>"},{"location":"sql/19_Relational_algebra/#union-intersection-difference","title":"Union, intersection, difference","text":"<ul> <li>\\( R \\cup S \\)<ul> <li><code>SELECT ... UNION SELECT ...;</code></li> <li>(Duplicate elimination: UNION ALL: multiset, UNION: set)</li> </ul> </li> <li>\\( R \\cap S \\)<ul> <li><code>SELECT ... INTERSECT SELECT ...;</code></li> </ul> </li> <li>\\( R - S \\)<ul> <li><code>SELECT ... MINUS SELECT ...;</code></li> <li>(Some DBMS uses EXCEPT)</li> </ul> </li> </ul>"},{"location":"sql/19_Relational_algebra/#selection","title":"Selection","text":"<ul> <li>\\( R1 := \\sigma_{C}(R2) \\)<ul> <li>\\( C \\) is a condition (as in \"if\" statements) that refers to attributes of \\( R2 \\).</li> <li>\\( R1 \\) is all those tuples of \\( R2 \\) that satisfy \\( C \\).</li> <li><code>SELECT * FROM R2 WHERE C;</code></li> </ul> </li> </ul>"},{"location":"sql/19_Relational_algebra/#projection","title":"Projection","text":"<ul> <li>\\( R1 := \\pi_{L}(R2) \\)<ul> <li>\\( L \\) is a list of attributes from the schema of \\( R2 \\).</li> <li>\\( R1 \\) is constructed by looking at each tuple of \\( R2 \\), extracting the attributes on list \\( L \\), in the order specified, and creating from those components a tuple for \\( R1 \\).</li> <li>Eliminate duplicate tuples, if any.</li> <li><code>SELECT DISTINCT L FROM R2;</code></li> </ul> </li> </ul>"},{"location":"sql/19_Relational_algebra/#extended-projection","title":"Extended Projection","text":"<ul> <li>Using the same \\( \\pi_L \\) operator, we allow the list \\( L \\) to contain arbitrary expressions involving attributes:<ol> <li>Arithmetic on attributes, e.g., \\( A+B \\rightarrow C \\).</li> <li>Duplicate occurrences of the same attribute.</li> </ol> </li> <li><code>SELECT A+B AS C FROM R;</code></li> <li>(AS -&gt; optional)</li> </ul>"},{"location":"sql/19_Relational_algebra/#product","title":"Product","text":"<ul> <li>\\( R3 := R1 \\times R2 \\)<ul> <li>Pair each tuple \\( t1 \\) of \\( R1 \\) with each tuple \\( t2 \\) of \\( R2 \\).</li> <li>Concatenation \\( t1t2 \\) is a tuple of \\( R3 \\).</li> <li>Schema of \\( R3 \\) is the attributes of \\( R1 \\) and then \\( R2 \\), in order.</li> <li>But beware attribute \\( A \\) of the same name in \\( R1 \\) and \\( R2 \\): use \\( R1.A \\) and \\( R2.A \\).</li> </ul> </li> <li><code>SELECT * FROM R1, R2;</code> or</li> <li><code>SELECT * FROM R1 CROSS JOIN R2;</code></li> </ul>"},{"location":"sql/19_Relational_algebra/#theta-join","title":"Theta-Join","text":"<ul> <li>\\( R3 := R1 \\bowtie_{C} R2 \\)<ul> <li>Take the product \\( R1 \\times R2 \\).</li> <li>Then apply \\( \\sigma_{C} \\) to the result.</li> </ul> </li> <li>As for \\( \\sigma \\), \\( C \\) can be any boolean-valued condition.<ul> <li>Historic versions of this operator allowed only \\( A\\ \\theta\\ B \\), where \\( \\theta \\) is \\( =, &lt; \\), etc.; hence the name \"theta-join.\"</li> </ul> </li> <li><code>SELECT * FROM R1 JOIN R2 ON (C);</code></li> </ul>"},{"location":"sql/19_Relational_algebra/#natural-join","title":"Natural Join","text":"<ul> <li>A useful join variant (natural join) connects two relations by:<ul> <li>Equating attributes of the same name, and</li> <li>Projecting out one copy of each pair of equated attributes.</li> </ul> </li> <li>Denoted \\( R3 := R1 \\bowtie R2 \\).</li> <li><code>SELECT * FROM R1 NATURAL JOIN R2;</code></li> </ul>"},{"location":"sql/19_Relational_algebra/#renaming","title":"Renaming","text":"<ul> <li>The \\( \\rho \\) operator gives a new schema to a relation.</li> <li>\\( R1 := \\rho_{R1(A1, ..., An)}(R2) \\) makes \\( R1 \\) be a relation with attributes \\( A1, ..., An \\) and the same tuples as \\( R2 \\).</li> <li>Simplified notation: \\( R1(A1, ..., An) := R2 \\).</li> <li><code>SELECT X1 A1, X2 A2, ... Xn An FROM R2;</code></li> <li><code>CREATE TABLE R1 AS SELECT X1 A1, X2 A2, ... Xn An FROM R2;</code></li> </ul>"},{"location":"sql/19_Relational_algebra/#sequences-of-assignments","title":"Sequences of Assignments","text":"<ul> <li>Create temporary relation names.</li> <li>Renaming can be implied by giving relations a list of attributes.</li> <li>Example: \\( R3 := R1 \\bowtie_{C} R2 \\) can be written:<ul> <li>\\( R4 := R1 \\times R2 \\) (<code>CREATE TABLE R4 ...</code>)</li> <li>\\( R3 := \\sigma_{C}(R4) \\) (<code>SELECT ... FROM R4 ...</code>)</li> </ul> </li> </ul>"},{"location":"sql/19_Relational_algebra/#expressions-in-a-single-assignment","title":"Expressions in a Single Assignment","text":"<ul> <li>Example: the theta-join \\( R3 := R1 \\bowtie_{C} R2 \\) can be written:<ul> <li>\\( R3 := \\sigma_{C}(R1 \\times R2) \\)</li> </ul> </li> <li>Precedence of relational operators:<ol> <li>\\( [\\sigma, \\pi, \\rho] \\) (highest).</li> <li>\\( [\\times, \\bowtie] \\).</li> <li>\\( \\cap \\).</li> <li>\\( [\\cup, -] \\).</li> </ol> </li> </ul>"},{"location":"sql/19_Relational_algebra/#the-extended-algebra","title":"The Extended Algebra","text":"<ul> <li>\\( \\pi_{L} \\) extended projection</li> <li>\\( \\delta \\) = eliminate duplicates from bags.</li> <li>\\( \\tau \\) = sort tuples.</li> <li>\\( \\gamma \\) = grouping and aggregation.</li> <li>Outerjoin: avoids \"dangling tuples\" = tuples that do not join with anything.</li> </ul>"},{"location":"sql/19_Relational_algebra/#extended-projection_1","title":"Extended Projection","text":"<ul> <li>Using the same \\( \\pi_{L} \\) operator, we allow the list \\( L \\) to contain arbitrary expressions involving attributes:<ol> <li>Arithmetic on attributes, e.g., \\( A+B \\rightarrow C \\)<ul> <li>\"\u2192\" stands for renaming the attribute in the result to \"\\( C \\)\"</li> </ul> </li> <li>Duplicate occurrences of the same attribute.</li> </ol> </li> <li><code>SELECT A+B AS C FROM R;</code></li> <li>(\"AS\" is optional)</li> </ul>"},{"location":"sql/19_Relational_algebra/#duplicate-elimination","title":"Duplicate Elimination","text":"<ul> <li>\\( R1 := \\delta(R2) \\).</li> <li>\\( R1 \\) consists of one copy of each tuple that appears in \\( R2 \\) one or more times.</li> </ul>"},{"location":"sql/19_Relational_algebra/#sorting","title":"Sorting","text":"<ul> <li>\\( R1 := \\tau_{L}(R2) \\).<ul> <li>\\( L \\) is a list of some of the attributes of \\( R2 \\).</li> </ul> </li> <li>\\( R1 \\) is the list of tuples of \\( R2 \\) sorted first on the value of the first attribute on \\( L \\), then on the second attribute of \\( L \\), and so on.<ul> <li>Break ties arbitrarily.</li> </ul> </li> <li>\\( \\tau \\) is the only operator whose result is neither a set nor a bag.</li> </ul>"},{"location":"sql/19_Relational_algebra/#aggregation-operators","title":"Aggregation Operators","text":"<ul> <li>Aggregation operators are not operators of relational algebra.</li> <li>Rather, they apply to entire columns of a table and produce a single result.</li> <li>The most important examples: SUM, AVG, COUNT, MIN, and MAX.<ul> <li>Example with Table \\( R(A, B) \\):<ul> <li>\\( SUM(A) = 7 \\)</li> <li>\\( COUNT(A) = 3 \\)</li> <li>\\( MAX(B) = 4 \\)</li> <li>\\( AVG(B) = 3 \\)</li> </ul> </li> </ul> </li> </ul>"},{"location":"sql/19_Relational_algebra/#grouping-operator","title":"Grouping Operator","text":"<ul> <li>\\( R1 := \\gamma_{L}(R2) \\). \\( L \\) is a list of elements that are either:<ol> <li>Individual (grouping) attributes.</li> <li>\\( AGG(A) \\), where \\( AGG \\) is one of the aggregation operators and \\( A \\) is an attribute.<ul> <li>An arrow and a new attribute name renames the component.</li> </ul> </li> </ol> </li> </ul>"},{"location":"sql/19_Relational_algebra/#applying-gamma-l-r","title":"Applying \\( \\gamma\\ L\\ (R) \\)","text":"<ul> <li>Group \\( R \\) according to all the grouping attributes on list \\( L \\).<ul> <li>That is: form one group for each distinct list of values for those attributes in \\( R \\).</li> </ul> </li> <li>Within each group, compute \\( AGG(A) \\) for each aggregation on list \\( L \\).</li> <li>Result has one tuple for each group:<ol> <li>The grouping attributes and</li> <li>Their group\u2019s aggregations.</li> </ol> </li> </ul>"},{"location":"sql/19_Relational_algebra/#outer-join","title":"Outer join","text":"<ul> <li>Suppose we join \\( R \\bowtie_{C} S \\).</li> <li>A tuple of \\( R \\) that has no tuple of \\( S \\) with which it joins is said to be dangling.<ul> <li>Similarly for a tuple of \\( S \\).</li> </ul> </li> <li>Outerjoin preserves dangling tuples by padding them NULL.</li> </ul>"},{"location":"sql/19_Relational_algebra/#examples","title":"Examples","text":"Relational Algebra Expression SQL Equivalent \\( \\pi_{A, B+C \\rightarrow X}(R) \\) <code>SELECT A, B+C AS X FROM R;</code> \\( \\delta(R) \\) <code>SELECT DISTINCT * FROM R;</code> \\( R \\cup S \\) <code>SELECT * FROM R UNION ALL SELECT * FROM S;</code> (multiset) \\( R \\cap S \\) <code>SELECT * FROM R INTERSECT ALL SELECT * FROM S;</code> (!) \\( R - S \\) <code>SELECT * FROM R MINUS ALL SELECT * FROM S;</code> (!) \\( \\delta(R \\cup S) \\) <code>SELECT * FROM R UNION SELECT * FROM S;</code> (set) \\( \\delta(R \\cap S) \\) <code>SELECT * FROM R INTERSECT SELECT * FROM S;</code> (set) \\( \\delta(R) - \\delta(S) \\) <code>SELECT * FROM R MINUS SELECT * FROM S;</code> (set) \\( R \\bowtie S \\) <code>SELECT * FROM R NATURAL JOIN S;</code> \\( R \\bowtie_{\\theta} S \\) <code>SELECT * FROM R JOIN S ON (\\theta);</code> \\( R \\times S \\) <code>SELECT * FROM R CROSS JOIN S;</code> or <code>SELECT * FROM R, S;</code> \\( \\gamma_{A, SUM(B)}(R) \\) <code>SELECT A, SUM(B) FROM R GROUP BY A;</code> \\( \\gamma_{A, COUNT(B)}(\\delta \\pi_{A,B} R) \\) <code>SELECT A, COUNT(DISTINCT B) FROM R GROUP BY A;</code> \\( \\tau_{A, B+C}(R) \\) <code>SELECT * FROM R ORDER BY A, B+C;</code> Outer join <code>SELECT * FROM R NATURAL LEFT OUTER JOIN S;</code> Outer join <code>SELECT * FROM R LEFT OUTER JOIN S ON R.B &gt; S.D;</code>"},{"location":"sql/19_Relational_algebra/#execution-steps","title":"Execution steps","text":"<p>Execution steps of a SELECT statement expressed in relational algebra:</p> <ol> <li>Replace all usages of the temporary-tables defined in the WITH-clause.</li> <li>\\( \\bowtie \\) joins or product operations after FROM-clause.</li> <li>\\( \\sigma \\) selection based on the WHERE-clause.</li> <li>\\( \\gamma \\) creating groups and computing aggregations, based on GROUP BY-clause.</li> <li>\\( \\sigma \\) selection for the groups or tuples created from the groups, based on HAVING-clause.</li> <li>\\( \\pi \\) projection based on SELECT-clause.</li> <li>\\( \\rho \\) rename result attributes based on AS keyword.</li> <li>\\( \\cup \\cap - \\) UNION, INTERSECT, MINUS set operations.</li> <li>\\( \\delta \\) duplicate elimination if we have DISTINCT.</li> <li>\\( \\tau \\) sorting based on ORDER BY clause.</li> </ol>"}]}