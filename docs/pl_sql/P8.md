# Benefits of PL/SQL

Improved Performance

![alt text](../assets/P8/plsql.png){ width=700 }

Parts of a PL/SQL block: declaration, executable, exception handling

```sql
set serveroutput on  -- required if we want to see the output
DECLARE                 
  v NUMBER := 0;
BEGIN
  DBMS_OUTPUT.PUT_LINE('It''s ok ...');  -- notice the double quotes
  v := 1/v;
  DBMS_OUTPUT.PUT_LINE('It is not ...');
EXCEPTION
  WHEN ZERO_DIVIDE THEN
    DBMS_OUTPUT.PUT_LINE('Division by zero');
END;
/        -- !!! Always end PL/SQL blocks with a '/' character !!!
```

<pre>
Results:
---------
It's ok ...
Division by zero
</pre>


# Block Types

![alt text](../assets/P8/block.png){ width=700 }

# Lexical elements of the PL/SQL language: 
# Delimiters, identifiers, literals, comments

Examples for delimiters:

- '+'   Addition operator
- ':=' Assignment operator
- '<<'  Label delimiter (begin)
- '>>'  Label delimiter (end)
- '!='  Relational operator (not equal)

# Identifiers can denote the following PL/SQL objects:

- Constants, Cursors,  Exceptions, Keywords, Labels,  Packages Reserved words, Subprograms, Variables, Types
- Predefined identifiers in STANDARD package, e.g. ZERO_DIVIDE exception

# Literals (numeric, character, string, logical, date)

- integer:       12
- real:          12.0
- char:          'a'
- string:      'abc', ''  (null string, actually NULL)
- logical:     TRUE, FALSE, NULL
- date:        DATE '2011-12-25' 


# Comments: single line and multiline

-- single line comment

/* multiline
   comment
*/


# Variables

- PL/SQL variables:

    - Scalar
    - Composite
    - Reference
    - LOB (large objects)

- Non-PL/SQL variables: Bind and host variables

```sql
-- we cannot put a space into delimiters ( := )
BEGIN
  count := count + 1;   -- correct
  count : = count + 1;  -- incorrect
END;
/
```

```sql
-- DATETIME and INTERVAL literals
DECLARE
  d1 DATE      := DATE '1998-12-25';
  t1 TIMESTAMP := TIMESTAMP '1997-10-22 13:01:01';
  t2 TIMESTAMP WITH TIME ZONE :=   TIMESTAMP '1997-01-31 09:26:56.66 +02:00';
  
  -- Three years and two months
  -- For greater precision, use the day-to-second interval
  i1 INTERVAL YEAR TO MONTH := INTERVAL '3-2' YEAR TO MONTH;
 
  -- Five days, four hours, three minutes, two and 1/100 seconds
   i2 INTERVAL DAY TO SECOND := INTERVAL '5 04:03:02.01' DAY TO SECOND;
BEGIN
  NULL;
END;
/
```

# Variable Initialization and Keywords

Using:

- Assignment operator (:=)
- DEFAULT keyword
- NOT NULL constraint

# Base Scalar Datatypes

- VARCHAR2 (maximum_length)
- NUMBER [(precision, scale)]
- DATE
- CHAR [(maximum_length)]
- LONG
- LONG RAW
- BOOLEAN
- BINARY_INTEGER
- PLS_INTEGER

```sql
-- variable declarations
DECLARE
  part_number       NUMBER(6);     -- SQL data type
  part_name         VARCHAR2(20);  -- SQL data type
  in_stock          BOOLEAN;       -- PL/SQL-only data type
  part_price        NUMBER(6,2);   -- SQL data type
  part_description  VARCHAR2(50);  -- SQL data type
BEGIN
  NULL;
END;
/
```

```sql
-- Constant declarations
DECLARE
  credit_limit     CONSTANT REAL    := 5000.00;  -- SQL data type
  max_days_in_year CONSTANT INTEGER := 366;      -- SQL data type
  urban_legend     CONSTANT BOOLEAN := FALSE;     -- PL/SQL-only data type;
BEGIN
  NULL;
END;
/
```

# Declaring Boolean Variables

- Only the values TRUE, FALSE, and NULL can be assigned to a Boolean variable.
- The variables are connected by the logical operators AND, OR, and NOT.
- The variables always yield TRUE, FALSE, or NULL.
- Arithmetic, character, and date expressions can be used to return a Boolean value.


# Composite Datatypes

- PL/SQL TABLES
- PL/SQL RECORDS

```sql
-- Initialization
DECLARE
  hours_worked    INTEGER := 40;
  employee_count  INTEGER := 0;
  pi     CONSTANT REAL := 3.14159;
  radius          REAL := 1;
  area            REAL := (pi * radius**2);
BEGIN
  NULL;
END;
/
```

```sql
-- Default initializations
DECLARE
  counter INTEGER;  -- initial value is NULL by default
BEGIN
  counter := counter + 1;  -- NULL + 1 is still NULL
  IF counter IS NULL THEN
    DBMS_OUTPUT.PUT_LINE('counter is NULL.');
  END IF;
END;
/
```

<pre>
Results:
---------
counter is NULL.
</pre>

```sql
-- All variables will be NULL
DECLARE
  null_string  VARCHAR2(80) := TO_CHAR('');
  address      VARCHAR2(80);
  zip_code     VARCHAR2(80) := SUBSTR(address, 25, 0);
  name         VARCHAR2(80);
  valid        BOOLEAN      := (name != '');
BEGIN
  NULL;
END;
/
```

```sql
-- %TYPE type inheritance from a column or from other variable
-- in case of column it doesn't inherit constraint, only data type
DECLARE
  v_name  emp.ename%TYPE;
BEGIN
  DBMS_OUTPUT.PUT_LINE('name=' || v_name);
END;
/
```

- Declare a variable according to:

  - A database column definition
  - Another previously declared variable

- Prefix %TYPE with:

  - The database table and column
  - The previously declared variable name

```sql
DECLARE
  name     VARCHAR(25) NOT NULL := 'Smith';
  surname  name%TYPE := 'Jones';               -- inherits NOT NULL constraint too
BEGIN
  DBMS_OUTPUT.PUT_LINE('name=' || name);
  DBMS_OUTPUT.PUT_LINE('surname=' || surname);
END;
/
```

<pre>
Results:
---------
name=Smith
surname=Jones
</pre>

```sql
-- %ROWTYPE record type inheritance (from table, view, cursor, record)
CREATE TABLE employees_temp (
  empid NUMBER(6) NOT NULL PRIMARY KEY,
  deptid NUMBER(6) CONSTRAINT c_employees_temp_deptid CHECK (deptid BETWEEN 100 AND 200),
  deptname VARCHAR2(30) DEFAULT 'Sales' );

DECLARE
  emprec  employees_temp%ROWTYPE;
BEGIN
  emprec.empid := NULL;         -- NOT Null constraint not inherited
  emprec.deptid := 50;          -- Check constraint not inherited
  DBMS_OUTPUT.PUT_LINE ('emprec.deptname: ' || emprec.deptname);  -- Initial value not inherited
END;
/
```

```sql
-- Error if identical names within a PL/SQL unit
DECLARE
  id  BOOLEAN;
  id  VARCHAR2(5);  -- duplicate identifier
BEGIN
  id := FALSE;
END;
/
```

# PL/SQL units are the following:

- PL/SQL anonymous block
- FUNCTION
- LIBRARY
- PACKAGE
- PACKAGE BODY
- PROCEDURE
- TRIGGER
- TYPE
- TYPE BODY

```sql
-- qualified names (within the procedure it refers to local identifier)
-- 'echo' -> name of a label and a procedure
SET SERVEROUTPUT ON
<<echo>>    -- name of a label (we can use labels to qualify PL/SQL program blocks)
DECLARE
  x  NUMBER := 5;
  
  PROCEDURE echo IS   -- name of a procedure
    x  NUMBER := 0;
  BEGIN
    DBMS_OUTPUT.PUT_LINE('x = ' || x);             -- output: x = 0
    DBMS_OUTPUT.PUT_LINE('echo.x = ' || echo.x);   -- output: echo.x = 0 (variable of the procedure)
  END;
 
BEGIN
  echo;
END;
/
```

<pre>
Results:
---------
x = 0
echo.x = 0
</pre>

```sql
-- initialization of a logical variable
DECLARE
  done    BOOLEAN;               -- Initial value is NULL by default
  counter NUMBER := 0;
BEGIN
  done := FALSE;                 -- Assign literal value
  WHILE done != TRUE             -- Compare to literal value
  LOOP
    counter := counter + 1;
    done := (counter > 500);     -- Assign value of BOOLEAN expression
  END LOOP;
  DBMS_OUTPUT.PUT_LINE(counter);  -- output: 501
END;
/
```

<pre>
Results:
---------
501
</pre>

# Operators in PL/SQL

Examples:

- Increment the index for a loop.

    - v_count := v_count + 1;

- Set the value of a Boolean flag.

    - v_equal := (v_n1 = v_n2);

- Validate an employee number if it contains a value.

    - v_valid := (v_empno IS NOT NULL);

```sql
-- SELECT data from a table into a variable
set serveroutput on
DECLARE
  bonus   NUMBER(7,2);
BEGIN
  SELECT sal * 0.10 INTO bonus
  FROM emp                        -- you need table EMP !!!
  WHERE empno = 7900;
  DBMS_OUTPUT.PUT_LINE('bonus = ' || TO_CHAR(bonus));
END;
/
```

<pre>
Results:
---------
bonus = 95
</pre>

# Datatype Conversion

- Convert data to comparable datatypes.
- Mixed datatypes can result in an error and affect performance.
- Conversion functions:

  - TO_CHAR
  - TO_DATE
  - TO_NUMBER

Example:

```sql
DECLARE
    v_date VARCHAR2(15);
BEGIN
    SELECT TO_CHAR(hiredate, 'MON. DD, YYYY')
    INTO v_date
    FROM emp
    WHERE empno = 7839;
END;
```

```sql
-- Two NULLs are not equal. Neither != is TRUE for them.
set serveroutput on
DECLARE
  a NUMBER := NULL;
  b NUMBER := NULL;
BEGIN
  IF a = b THEN                         -- yields NULL, not TRUE
    DBMS_OUTPUT.PUT_LINE('a = b');      -- not run
  ELSIF a != b THEN                     -- yields NULL, not TRUE
    DBMS_OUTPUT.PUT_LINE('a != b');     -- not run
  ELSE
    DBMS_OUTPUT.PUT_LINE('Can''t tell if two NULLs are equal');
  END IF;
END;
/
```

<pre>
Results:
---------
Can't tell if two NULLs are equal
</pre>

```sql
-- Concatenation operator ignores NULL.
set serveroutput on
BEGIN
  DBMS_OUTPUT.PUT_LINE ('apple' || NULL || NULL || 'sauce');  -- output: applesauce
END;
/
```

<pre>
Results:
---------
applesauce
</pre>

```sql
-- use brackets
DECLARE
  a INTEGER := 2**2*3**2;
  b INTEGER := (2**2)*(3**2);
BEGIN
  DBMS_OUTPUT.PUT_LINE('a = ' || TO_CHAR(a));   -- output: a = 36
  DBMS_OUTPUT.PUT_LINE('b = ' || TO_CHAR(b));   -- output: b = 36
END;
/
```

<pre>
Results:
---------
a = 36
b = 36
</pre>

```sql
-- lazy evaluation
DECLARE
  on_hand  INTEGER := 0;
  on_order INTEGER := 100;
BEGIN 
  IF (on_hand = 0) OR ((on_order / on_hand) < 5) THEN   -- Will not cause ZERO_DIVIDE exception
    DBMS_OUTPUT.PUT_LINE('On hand quantity is zero.');
  END IF;
END;
/
```

<pre>
Results:
---------
On hand quantity is zero.
</pre>

