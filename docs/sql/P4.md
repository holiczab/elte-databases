# Creating Groups of Data

![alt text](../assets/P4/group.png){ width=700 }

# Creating Groups of Data: GROUP BY Clause Syntax

```sql
SELECT     column, group_function(column)
FROM       table
[WHERE     condition]
[GROUP BY  group_by_expression]
[ORDER BY  column];
```

You can divide rows in a table into smaller groups by using the GROUP BY clause.

# Using the GROUP BY Clause

All columns in the SELECT list that are not in group functions must be in the GROUP BY clause.

```sql
SELECT department_id, AVG(salary)
FROM nikovits.employees
GROUP BY department_id;
```

| DEPARTMENT_ID        | AVG(SALARY)          |
|----------------------|----------------------|
| 100                  | 8600                 |
| 30                   | 4150                 |
| NULL                 | 7000                 |
| 90                   | 19333.33333333333333 |
| 20                   | 9500                 |
| 70                   | 10000                |
| 110                  | 10150                |
| 50                   | 3475.555555555555555 |
| 80                   | 8955.882352941176470 |
| 40                   | 6500                 |
| 60                   | 5760                 |
| 10                   | 4400                 |

# Using the GROUP BY Clause

The GROUP BY column does not have to be in the SELECT list.

```sql
SELECT AVG(salary)
FROM nikovits.employees
GROUP BY department_id;
```

| AVG(SALARY)          |
|----------------------|
| 8600                 |
| 4150                 |
| 7000                 |
| 19333.33333333333333 |
| 9500                 |
| 10000                |
| 10150                |
| 3475.555555555555555 |
| 8955.882352941176470 |
| 6500                 |
| 5760                 |
| 4400                 |

# Grouping by More Than One Column

![alt text](../assets/P4/more.png){ width=700 }

# Using the GROUP BY Clause on Multiple Columns

```sql
SELECT department_id dept_id, job_id, SUM(salary)
FROM nikovits.employees
GROUP BY department_id, job_id ;
```

| DEPT_ID              | JOB_ID               | SUM(SALARY)          |
|----------------------|----------------------|----------------------|
| 110                  | AC_ACCOUNT           | 8300                 |
| 90                   | AD_VP                | 34000                |
| 50                   | ST_CLERK             | 55700                |
| 80                   | SA_REP               | 243500               |
| 50                   | ST_MAN               | 36400                |
| 80                   | SA_MAN               | 61000                |
| 110                  | AC_MGR               | 12000                |
| 90                   | AD_PRES              | 24000                |
| 60                   | IT_PROG              | 28800                |
| 100                  | FI_MGR               | 12000                |
| 30                   | PU_CLERK             | 13900                |
| 50                   | SH_CLERK             | 64300                |
| 20                   | MK_MAN               | 13000                |
| 100                  | FI_ACCOUNT           | 39600                |
| NULL                 | SA_REP               | 7000                 |
| 70                   | PR_REP               | 10000                |
| 30                   | PU_MAN               | 11000                |
| 10                   | AD_ASST              | 4400                 |
| 20                   | MK_REP               | 6000                 |
| 40                   | HR_REP               | 6500                 |

# Illegal Queries Using Group Functions

Any column or expression in the SELECT list that is not an aggregate function **must** be in the GROUP BY clause:

```sql
SELECT   department_id, COUNT(last_name)
FROM     employees;
```

![alt text](../assets/P4/error1.png){ width=700 }

Column missing in the GROUP BY clause

# Illegal Queries Using Group Functions

- You cannot use the **WHERE** clause to restrict groups.
- You use the **HAVING** clause to restrict groups.
- You cannot use group functions in the **WHERE** clause.

```sql
SELECT   department_id, AVG(salary)
FROM     employees
WHERE    AVG(salary) > 8000
GROUP BY department_id;
```

![alt text](../assets/P4/error2.png){ width=700 }

Cannot use the WHERE clause to restrict groups

# Restricting Group Functions

![alt text](../assets/P4/restriction.png){ width=700 }

# Restricting Group Results with the HAVING Clause

- When you use the HAVING clause, the Oracle server restricts groups as follows:
  1. Rows are grouped.
  2. The group function is applied.
  3. Groups matching the HAVING clause are displayed.

```sql
SELECT     column, group_function
FROM       table
[WHERE     condition]
[GROUP BY  group_by_expression]
[HAVING    group_condition]
[ORDER BY  column];
```

# Using the HAVING Clause

```sql
SELECT department_id, MAX(salary)
FROM nikovits.employees
GROUP BY department_id
HAVING MAX(salary)>10000 ;
```

| DEPARTMENT_ID        | MAX(SALARY)          |
|----------------------|----------------------|
| 100                  | 12000                |
| 30                   | 11000                |
| 90                   | 24000                |
| 20                   | 13000                |
| 110                  | 12000                |
| 80                   | 14000                |

```sql
SELECT job_id, SUM(salary) PAYROLL
FROM nikovits.employees
WHERE job_id NOT LIKE '%REP%'
GROUP BY job_id
HAVING SUM(salary) > 13000
ORDER BY SUM(salary);
```

| JOB_ID               | PAYROLL              |
|----------------------|----------------------|
| PU_CLERK             | 13900                |
| AD_PRES              | 24000                |
| IT_PROG              | 28800                |
| AD_VP                | 34000                |
| ST_MAN               | 36400                |
| FI_ACCOUNT           | 39600                |
| ST_CLERK             | 55700                |
| SA_MAN               | 61000                |
| SH_CLERK             | 64300                |

# Nesting Group Functions

- Display the maximum average salary:
- Group functions can be nested to a depth of two.
- The example displays the maximum average salary.

```sql
SELECT MAX(AVG(salary))
FROM nikovits.employees
GROUP BY department_id;
```

| MAX(AVG(SALARY))     |
|----------------------|
| 19333.33333333333333 |

# Obtaining Data from Multiple Tables

![alt text](../assets/P4/multiple.png){ width=700 }

# Types of Joins

- Joins that are compliant with the SQL:1999 standard include the following:
    – Cross joins
    – Natural joins
    – USING clause
    – Full (or two-sided) outer joins
    – Arbitrary join conditions for outer joins

# Joining Tables Using SQL:1999 Syntax

Use a join to query data from more than one table:

```sql
SELECT table1.column, table2.column
FROM   table1
[NATURAL JOIN table2] |
[JOIN table2 USING (column_name)] |
[JOIN table2
 ON (table1.column_name = table2.column_name)] |
[LEFT|RIGHT|FULL OUTER JOIN table2
 ON (table1.column_name = table2.column_name)] |
[CROSS JOIN table2];
```

# Creating Natural Joins

- The NATURAL JOIN clause is based on all columns in the two tables that have the same name.
- It selects rows from the two tables that have equal values in all matched columns.
- If the columns having the same names have different data types, an error is returned.

# Retrieving Records with Natural Joins

```sql
SELECT department_id, department_name,
location_id, city
FROM nikovits.departments
NATURAL JOIN nikovits.locations ;
```

| DEPARTMENT_ID        | DEPARTMENT_NAME      | LOCATION_ID          | CITY                 |
|----------------------|----------------------|----------------------|----------------------|
| 10                   | Administration       | 1700                 | Seattle              |
| 20                   | Marketing            | 1800                 | Toronto              |
| 30                   | Purchasing           | 1700                 | Seattle              |
| 40                   | Human Resources      | 2400                 | London               |
| 50                   | Shipping             | 1500                 | South San Francisco  |
| 60                   | IT                   | 1400                 | Southlake            |
| 70                   | Public Relations     | 2700                 | Munich               |
| 80                   | Sales                | 2500                 | Oxford               |
| 90                   | Executive            | 1700                 | Seattle              |
| 100                  | Finance              | 1700                 | Seattle              |
| 110                  | Accounting           | 1700                 | Seattle              |
| 120                  | Treasury             | 1700                 | Seattle              |

# Creating Joins with the USING Clause

- If several columns have the same names but the data types do not match, the NATURAL JOIN clause can be modified with the USING clause to specify the columns that should be used for an equijoin.
- Use the USING clause to match only one column when more than one column matches.
- Do not use a table name or alias in the referenced columns.
- The NATURAL JOIN and USING clauses are mutually exclusive.

# Joining Column Names

![alt text](../assets/P4/join.png){ width=700 }

```sql
SELECT nikovits.employees.employee_id, nikovits.employees.last_name,
nikovits.departments.location_id, department_id
FROM nikovits.employees JOIN nikovits.departments
USING (department_id) ;
```

| EMPLOYEE_ID          | LAST_NAME            | LOCATION_ID          | DEPARTMENT_ID        |
|----------------------|----------------------|----------------------|----------------------|
| 100                  | King                 | 1700                 | 90                   |
| 101                  | Kochhar              | 1700                 | 90                   |
| 102                  | De Haan              | 1700                 | 90                   |
| 103                  | Hunold               | 1400                 | 60                   |
| 104                  | Ernst                | 1400                 | 60                   |
| 105                  | Austin               | 1400                 | 60                   |
| 106                  | Pataballa            | 1400                 | 60                   |
| 107                  | Lorentz              | 1400                 | 60                   |
| 108                  | Greenberg            | 1700                 | 100                  |
| 109                  | Faviet               | 1700                 | 100                  |
| 110                  | Chen                 | 1700                 | 100                  |

# Qualifying Ambiguous

# Column Names

- Use table prefixes to qualify column names that are in multiple tables.
- Use table prefixes to improve performance.
- Use column aliases to distinguish columns that have identical names but reside in different tables.
- Do not use aliases on columns that are identified in the USING clause and listed elsewhere in the SQL statement.

# Using Table Aliases

- Use table aliases to simplify queries.
- Use table aliases to improve performance.

```sql
SELECT e.employee_id, e.last_name,
       d.location_id, department_id
FROM   employees e JOIN departments d
USING  (department_id) ;
```

# Creating Joins with the ON Clause

- The join condition for the natural join is basically an equijoin of all columns with the same name.
- Use the ON clause to specify arbitrary conditions or specify columns to join.
- The join condition is separated from other search conditions.
- The ON clause makes code easy to understand.

```sql
SELECT e.employee_id, e.last_name, e.department_id,
d.department_id, d.location_id
FROM nikovits.employees e JOIN nikovits.departments d
ON (e.department_id = d.department_id);
```

| EMPLOYEE_ID          | LAST_NAME            | DEPARTMENT_ID        | DEPARTMENT_ID        | LOCATION_ID          |
|----------------------|----------------------|----------------------|----------------------|----------------------|
| 100                  | King                 | 90                   | 90                   | 1700                 |
| 101                  | Kochhar              | 90                   | 90                   | 1700                 |
| 102                  | De Haan              | 90                   | 90                   | 1700                 |
| 103                  | Hunold               | 60                   | 60                   | 1400                 |
| 104                  | Ernst                | 60                   | 60                   | 1400                 |
| 105                  | Austin               | 60                   | 60                   | 1400                 |
| 106                  | Pataballa            | 60                   | 60                   | 1400                 |
| 107                  | Lorentz              | 60                   | 60                   | 1400                 |
| 108                  | Greenberg            | 100                  | 100                  | 1700                 |
| 109                  | Faviet               | 100                  | 100                  | 1700                 |
| 110                  | Chen                 | 100                  | 100                  | 1700                 |
| 111                  | Sciarra              | 100                  | 100                  | 1700                 |
| 112                  | Urman                | 100                  | 100                  | 1700                 |
| 113                  | Popp                 | 100                  | 100                  | 1700                 |
| 114                  | Raphaely             | 30                   | 30                   | 1700                 |

# Self-Joins Using the ON Clause

![alt text](../assets/P4/self.png){ width=700 }

```sql
SELECT e.last_name emp, m.last_name mgr
FROM nikovits.employees e JOIN nikovits.employees m
ON (e.manager_id = m.employee_id);
```

| EMP                  | MGR                  |
|----------------------|----------------------|
| Kochhar              | King                 |
| De Haan              | King                 |
| Raphaely             | King                 |
| Weiss                | King                 |
| Fripp                | King                 |
| Kaufling             | King                 |
| Vollman              | King                 |
| Mourgos              | King                 |
| Russell              | King                 |
| Partners             | King                 |
| Errazuriz            | King                 |
| Cambrault            | King                 |
| Zlotkey              | King                 |

# Applying Additional Conditions to a Join

```sql
SELECT e.employee_id, e.last_name, e.department_id,
       d.department_id, d.location_id
FROM   employees e JOIN departments d
ON     (e.department_id = d.department_id)
AND    e.manager_id = 149;
```

| EMPLOYEE_ID | LAST_NAME | DEPARTMENT_ID | DEPARTMENT_ID | LOCATION_ID |
|-------------|-----------|---------------|---------------|-------------|
| 174         | Abel      | 80            | 80            | 2500        |
| 178         | Taylor    | 80            | 80            | 2500        |

Alternatively, you can use a WHERE clause to apply additional conditions:

```sql
SELECT e.employee_id, e.last_name, e.department_id,
       d.department_id, d.location_id
FROM   employees e JOIN departments d
ON     (e.department_id = d.department_id)
WHERE  e.manager_id = 149;
```

# Creating Three-Way Joins with the ON Clause

```sql
SELECT employee_id, city, department_name
FROM nikovits.employees e
JOIN nikovits.departments d
ON d.department_id = e.department_id
JOIN nikovits.locations l
ON d.location_id = l.location_id;
```

| EMPLOYEE_ID          | CITY                 | DEPARTMENT_NAME      |
|----------------------|----------------------|----------------------|
| 100                  | Seattle              | Executive            |
| 101                  | Seattle              | Executive            |
| 102                  | Seattle              | Executive            |
| 103                  | Southlake            | IT                   |
| 104                  | Southlake            | IT                   |
| 105                  | Southlake            | IT                   |
| 106                  | Southlake            | IT                   |
| 107                  | Southlake            | IT                   |
| 108                  | Seattle              | Finance              |
| 109                  | Seattle              | Finance              |
| 110                  | Seattle              | Finance              |
| 111                  | Seattle              | Finance              |
| 112                  | Seattle              | Finance              |
| 113                  | Seattle              | Finance              |

# Non-Equijoin

![alt text](../assets/P4/non.png){ width=700 }

```sql
SELECT e.last_name, e.salary, j.grade_level
FROM nikovits.employees e JOIN nikovits.job_grades j
ON e.salary
BETWEEN j.lowest_sal AND j.highest_sal;
```

| LAST_NAME            | SALARY               | GRADE_LEVEL          |
|----------------------|----------------------|----------------------|
| Olson                | 2100                 | A                    |
| Markle               | 2200                 | A                    |
| Philtanker           | 2200                 | A                    |
| Landry               | 2400                 | A                    |
| Gee                  | 2400                 | A                    |
| Colmenares           | 2500                 | A                    |
| Marlow               | 2500                 | A                    |
| Patel                | 2500                 | A                    |
| Vargas               | 2500                 | A                    |
| Sullivan             | 2500                 | A                    |
| Perkins              | 2500                 | A                    |
| Himuro               | 2600                 | A                    |

# Outer Joins

![alt text](../assets/P4/outer.png){ width=700 }

# INNER Versus OUTER Joins

- In SQL:1999, the join of two tables returning only matched rows is called an **inner join**.
- A join between two tables that returns the results of the inner join as well as the **unmatched rows** from the left (or right) tables is called a **left (or right) outer join**.
- A join between two tables that returns the results of an inner join as well as the results of a left and right join is a **full outer join**.

# LEFT OUTER JOIN

```sql
SELECT e.last_name, e.department_id, d.department_name
FROM nikovits.employees e LEFT OUTER JOIN nikovits.departments d
ON (e.department_id = d.department_id) ;
```

| LAST_NAME            | DEPARTMENT_ID        | DEPARTMENT_NAME      |
|----------------------|----------------------|----------------------|
| Whalen               | 10                   | Administration       |
| Hartstein            | 20                   | Marketing            |
| Fay                  | 20                   | Marketing            |
| Raphaely             | 30                   | Purchasing           |
| Khoo                 | 30                   | Purchasing           |
| Baida                | 30                   | Purchasing           |
| Tobias               | 30                   | Purchasing           |
| Himuro               | 30                   | Purchasing           |
| Colmenares           | 30                   | Purchasing           |
| Mavris               | 40                   | Human Resources      |
| Weiss                | 50                   | Shipping             |
| Fripp                | 50                   | Shipping             |
| Kaufling             | 50                   | Shipping             |

# RIGHT OUTER JOIN

```sql
SELECT e.last_name, e.department_id, d.department_name
FROM nikovits.employees e RIGHT OUTER JOIN nikovits.departments d
ON (e.department_id = d.department_id) ;
```

| LAST_NAME            | DEPARTMENT_ID        | DEPARTMENT_NAME      |
|----------------------|----------------------|----------------------|
| King                 | 90                   | Executive            |
| Kochhar              | 90                   | Executive            |
| De Haan              | 90                   | Executive            |
| Hunold               | 60                   | IT                   |
| Ernst                | 60                   | IT                   |
| Austin               | 60                   | IT                   |
| Pataballa            | 60                   | IT                   |
| Lorentz              | 60                   | IT                   |
| Greenberg            | 100                  | Finance              |
| Faviet               | 100                  | Finance              |

# FULL OUTER JOIN

```sql
SELECT e.last_name, d.department_id, d.department_name
FROM nikovits.employees e FULL OUTER JOIN nikovits.departments d
ON (e.department_id = d.department_id) ;
```

| LAST_NAME            | DEPARTMENT_ID        | DEPARTMENT_NAME      |
|----------------------|----------------------|----------------------|
| King                 | 90                   | Executive            |
| Kochhar              | 90                   | Executive            |
| De Haan              | 90                   | Executive            |
| Hunold               | 60                   | IT                   |
| Ernst                | 60                   | IT                   |
| Austin               | 60                   | IT                   |
| Pataballa            | 60                   | IT                   |
| Lorentz              | 60                   | IT                   |
| Greenberg            | 100                  | Finance              |
| Faviet               | 100                  | Finance              |
| Chen                 | 100                  | Finance              |
| Sciarra              | 100                  | Finance              |

# Cartesian Products

- A Cartesian product is formed when:

  - A join condition is omitted
  - A join condition is invalid
  - All rows in the first table are joined to all rows in the second table

- To avoid a Cartesian product, always include a valid join condition.

# Generating a Cartesian Product

![alt text](../assets/P4/cartesian.png){ width=700 }

# Creating Cross Joins

- The CROSS JOIN clause produces the crossproduct of two tables.
- This is also called a Cartesian product between the two tables.

```sql
SELECT last_name, department_name
FROM nikovits.employees
CROSS JOIN nikovits.departments ;
```

| LAST_NAME            | DEPARTMENT_NAME      |
|----------------------|----------------------|
| King                 | Administration       |
| Kochhar              | Administration       |
| De Haan              | Administration       |
| Hunold               | Administration       |
| Ernst                | Administration       |
| Austin               | Administration       |
| Pataballa            | Administration       |
| Lorentz              | Administration       |
| Greenberg            | Administration       |
| Faviet               | Administration       |
| Chen                 | Administration       |
| Sciarra              | Administration       |

# Using a Subquery to Solve a Problem

![alt text](../assets/P4/sub.png){ width=700 }

# Subquery Syntax

```sql
SELECT  select_list
FROM    table
WHERE   expr operator
        (SELECT select_list
         FROM   table);
```

- The subquery (inner query) executes once before the main query (outer query).
- The result of the subquery is used by the main query.

```sql
SELECT last_name
FROM nikovits.employees
WHERE salary >
(SELECT salary
FROM nikovits.employees
WHERE last_name = 'Abel');
```

| LAST_NAME            |
|----------------------|
| King                 |
| Kochhar              |
| De Haan              |
| Greenberg            |
| Russell              |
| Partners             |
| Errazuriz            |
| Ozer                 |
| Hartstein            |
| Higgins              |

# Guidelines for Using Subqueries

- Enclose subqueries in parentheses.
- Place subqueries on the right side of the comparison condition.
- The ORDER BY clause in the subquery is not needed unless you are performing Top-N analysis.
- Use single-row operators with single-row subqueries, and use multiple-row operators with multiple-row subqueries.

# Types of Subqueries

![alt text](../assets/P4/typessub.png){ width=700 }

# Single-Row Subqueries

- Return **only one row**
- Use single-row comparison operators

| Operator | Meaning                  |
|----------|--------------------------|
| =        | Equal to                 |
| >        | Greater than             |
| >=       | Greater than or equal to |
| <        | Less than                |
| <=       | Less than or equal to    |
| <>       | Not equal to             |

# Executing Single-Row Subqueries

```sql
SELECT last_name, job_id, salary
FROM nikovits.employees
WHERE job_id =
(SELECT job_id
FROM nikovits.employees
WHERE employee_id = 141)
AND salary >
(SELECT salary
FROM nikovits.employees
WHERE employee_id = 143);
```

| LAST_NAME            | JOB_ID               | SALARY               |
|----------------------|----------------------|----------------------|
| Nayer                | ST_CLERK             | 3200                 |
| Mikkilineni          | ST_CLERK             | 2700                 |
| Bissot               | ST_CLERK             | 3300                 |
| Atkinson             | ST_CLERK             | 2800                 |
| Mallin               | ST_CLERK             | 3300                 |
| Rogers               | ST_CLERK             | 2900                 |
| Ladwig               | ST_CLERK             | 3600                 |
| Stiles               | ST_CLERK             | 3200                 |
| Seo                  | ST_CLERK             | 2700                 |

# Using Group Functions in a Subquery

```sql
SELECT last_name, job_id, salary
FROM nikovits.employees
WHERE salary =
(SELECT MIN(salary)
FROM nikovits.employees);
```

| LAST_NAME            | JOB_ID               | SALARY               |
|----------------------|----------------------|----------------------|
| Olson                | ST_CLERK             | 2100                 |

# The HAVING Clause with Subqueries

- The Oracle server executes subqueries first.
- The Oracle server returns results into the HAVING clause of the main query.

```sql
SELECT   department_id, MIN(salary)
FROM     employees
GROUP BY department_id
HAVING   MIN(salary) > 
         (SELECT MIN(salary)
          FROM   employees
          WHERE  department_id = 50);
```

# What Is Wrong with This Statement?

```sql
SELECT employee_id, last_name
FROM   employees
WHERE  salary =
       (SELECT   MIN(salary)
        FROM     employees
        GROUP BY department_id);
``` 

![alt text](../assets/P4/error3.png){ width=700 }

Single-row operator with multiple-row subquery

# Will This Statement Return Rows?

```sql
SELECT last_name, job_id
FROM   employees
WHERE  job_id =
       (SELECT job_id
        FROM   employees
        WHERE  last_name = 'Haas');
```

![alt text](../assets/P4/error4.png){ width=700 }

Subquery returns no values.

# Multiple-Row Subqueries

- Return **more than one row**
- Use multiple-row comparison operators

| Operator | Meaning                                      |
|----------|----------------------------------------------|
| IN       | Equal to any member in the list              |
| ANY      | Compare value to each value returned by the subquery |
| ALL      | Compare value to every value returned by the subquery |

# Using the ANY Operator in Multiple-Row Subqueries

```sql
SELECT employee_id, last_name, job_id, salary
FROM nikovits.employees
WHERE salary < ANY
(SELECT salary
FROM nikovits.employees
WHERE job_id = 'IT_PROG')
AND job_id <> 'IT_PROG';
```

| EMPLOYEE_ID          | LAST_NAME            | JOB_ID               | SALARY               |
|----------------------|----------------------|----------------------|----------------------|
| 132                  | Olson                | ST_CLERK             | 2100                 |
| 136                  | Philtanker           | ST_CLERK             | 2200                 |
| 128                  | Markle               | ST_CLERK             | 2200                 |
| 135                  | Gee                  | ST_CLERK             | 2400                 |
| 127                  | Landry               | ST_CLERK             | 2400                 |
| 191                  | Perkins              | SH_CLERK             | 2500                 |
| 182                  | Sullivan             | SH_CLERK             | 2500                 |
| 144                  | Vargas               | ST_CLERK             | 2500                 |
| 140                  | Patel                | ST_CLERK             | 2500                 |

# Using the ALL Operator in Multiple-Row Subqueries

```sql
SELECT employee_id, last_name, job_id, salary
FROM nikovits.employees
WHERE salary < ALL
(SELECT salary
FROM nikovits.employees
WHERE job_id = 'IT_PROG')
AND job_id <> 'IT_PROG';
```

| EMPLOYEE_ID          | LAST_NAME            | JOB_ID               | SALARY               |
|----------------------|----------------------|----------------------|----------------------|
| 185                  | Bull                 | SH_CLERK             | 4100                 |
| 192                  | Bell                 | SH_CLERK             | 4000                 |
| 193                  | Everett              | SH_CLERK             | 3900                 |
| 188                  | Chung                | SH_CLERK             | 3800                 |
| 137                  | Ladwig               | ST_CLERK             | 3600                 |
| 189                  | Dilly                | SH_CLERK             | 3600                 |
| 141                  | Rajs                 | ST_CLERK             | 3500                 |
| 186                  | Dellinger            | SH_CLERK             | 3400                 |
| 133                  | Mallin               | ST_CLERK             | 3300                 |
| 129                  | Bissot               | ST_CLERK             | 3300                 |
| 180                  | Taylor               | SH_CLERK             | 3200                 |
| 138                  | Stiles               | ST_CLERK             | 3200                 |

# Null Values in a Subquery

```sql
SELECT  emp.last_name
FROM    employees emp
WHERE   emp.employee_id NOT IN
        (SELECT mgr.manager_id
         FROM   employees mgr);
```

no rows selected

x NOT IN (A, B, NULL) → Unknown

# Joins Summary

![alt text](../assets/P4/joinsummary.png){ width=700 }